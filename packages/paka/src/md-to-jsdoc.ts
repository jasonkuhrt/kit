import { Fs } from '@kitz/fs'
import { Syn } from '@kitz/syn'

export interface MarkdownToJsDocMetadata {
  moduleName: string
  generatorPath: Fs.Path.RelFile
}

/**
 * Convert markdown documentation to JSDoc format for generated files.
 *
 * @remarks
 * Markdown structure is mapped to JSDoc tags:
 * - Content before first heading → Summary
 * - `# Description` → `@description`
 * - `# Remarks` → `@remarks`
 * - `# Example` with `## Subheading` → `@example Subheading`
 * - `# See Also` with links → `@see {@link url | text}`
 */
export const markdownToJsDoc = (markdown: string, metadata: MarkdownToJsDocMetadata): string => {
  const lines = markdown.trim().split('\n')
  const sections: Record<string, string[]> = {}
  let currentSection: string | null = null
  let summary: string[] = []

  // Parse markdown into sections
  for (const line of lines) {
    const h1Match = line.match(/^# (.+)$/)

    if (h1Match) {
      // Level 1 heading starts a new section
      currentSection = h1Match[1]!.toLowerCase()
      sections[currentSection] = []
    } else if (currentSection) {
      // Add line to current section
      sections[currentSection]!.push(line)
    } else {
      // Content before first heading is the summary
      summary.push(line)
    }
  }

  // Build JSDoc content using TSDoc builder
  const doc = Syn.TSDoc.builder()

  // Add banner
  doc`====================================================================================`
  doc`GENERATED FILE - DO NOT EDIT MANUALLY`
  doc`====================================================================================`
  doc.blank()
  doc`Generated by: Graffle Code Generator`
  doc`Source: ${metadata.generatorPath.toString()}`
  doc.blank()
  doc.addRaw(`@module ${metadata.moduleName}`)

  // Add summary
  if (summary.length > 0) {
    doc.blank()
    for (const line of summary) {
      doc.add(line || '')
    }
  }

  // Add description section
  if (sections['description']) {
    doc.blank()
    doc.addRaw('@description')
    for (const line of sections['description']) {
      doc.add(line || '')
    }
  }

  // Add remarks section
  if (sections['remarks']) {
    doc.blank()
    doc.addRaw('@remarks')
    for (const line of sections['remarks']) {
      doc.add(line || '')
    }
  }

  // Add example section(s)
  if (sections['example']) {
    doc.blank()
    let currentExampleLabel = ''
    let inCodeBlock = false
    let codeLines: string[] = []

    for (const line of sections['example']) {
      const h2Match = line.match(/^## (.+)$/)

      if (h2Match) {
        // New example subsection - flush previous code block if any
        if (inCodeBlock && codeLines.length > 0) {
          doc.$example(currentExampleLabel, 'typescript', codeLines.join('\n'))
          codeLines = []
          inCodeBlock = false
        }
        currentExampleLabel = h2Match[1]!
      } else if (line.trim().startsWith('```')) {
        // Code block delimiter
        if (!inCodeBlock) {
          inCodeBlock = true
        } else {
          // End of code block - emit example
          doc.$example(currentExampleLabel, 'typescript', codeLines.join('\n'))
          codeLines = []
          inCodeBlock = false
        }
      } else if (inCodeBlock) {
        codeLines.push(line)
      } else if (line.trim()) {
        doc.add(line)
      }
    }

    // Close final example if still open
    if (inCodeBlock && codeLines.length > 0) {
      doc.$example(currentExampleLabel, 'typescript', codeLines.join('\n'))
    }
  }

  // Add see also section
  if (sections['see also']) {
    doc.blank()
    for (const line of sections['see also']) {
      // Parse markdown links: [text](url)
      const linkMatch = line.match(/\[(.+?)\]\((.+?)\)/)
      if (linkMatch) {
        const text = linkMatch[1]!
        const url = linkMatch[2]!
        doc.$see(url, text)
      }
    }
  }

  return Syn.TSDoc.format(doc.build())
}
