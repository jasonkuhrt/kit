{
  "name": "@wollybeard/kit",
  "version": "0.0.0-dripip",
  "entrypoints": [
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./arr",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "arr"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Array utilities for working with readonly and mutable arrays.  Provides functional utilities for array operations including mapping, filtering, type guards, and conversions. Emphasizes immutable operations and type safety.",
        "exports": [
          {
            "name": "Eq",
            "signature": "Eq<Any>",
            "description": "Eq trait implementation for immutable arrays.  Provides deep structural equality for readonly arrays by recursively comparing elements using their appropriate Eq implementations.",
            "examples": [
              {
                "code": "import { Arr } from '@wollybeard/kit'\n\n// Basic array equality\nArr.Eq.is([1, 2, 3], [1, 2, 3]) // true\nArr.Eq.is([1, 2, 3], [1, 2, 4]) // false\nArr.Eq.is([1, 2], [1, 2, 3]) // false (different lengths)\n\n// Nested arrays\nArr.Eq.is(\n  [[1, 2], [3, 4]],\n  [[1, 2], [3, 4]]\n) // true\n\n// Mixed types\nArr.Eq.is(\n  [1, 'hello', true],\n  [1, 'hello', true]\n) // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<Any>",
            "description": "Type trait implementation for immutable arrays.  Provides type checking for readonly array values using Array.isArray.",
            "examples": [
              {
                "code": "import { Arr } from '@wollybeard/kit'\n\nArr.Type.is([1, 2, 3])     // true\nArr.Type.is([])            // true\nArr.Type.is('not array')   // false\nArr.Type.is(null)          // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 21
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "assert",
            "signature": "function assert(value: unknown): void",
            "description": "Assert that a value is an array. Throws a TypeError if the value is not an array.",
            "examples": [
              {
                "code": "function process(value: unknown) {\n  Arr.assert(value)\n  // value is now typed as unknown[]\n  value.forEach(item => console.log(item))\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {
              "throws": "TypeError If the value is not an array"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 124
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Unknown",
            "signature": "type Unknown = readonly unknown[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Any",
            "signature": "type Any = readonly any[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Empty",
            "signature": "type Empty = readonly []",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "All",
            "signature": "type All<$Tuple extends [...boolean[]]> = $Tuple[number] extends true ? true : false",
            "description": "Check if all booleans in a tuple are true.",
            "examples": [
              {
                "code": "type T1 = All<[true, true, true]>  // true\ntype T2 = All<[true, false, true]>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsTupleMultiple",
            "signature": "type IsTupleMultiple<$T> = $T extends [unknown, unknown, ...unknown[]] ? true : false",
            "description": "Check if a tuple has multiple elements.",
            "examples": [
              {
                "code": "type T1 = IsTupleMultiple<[1, 2]>  // true\ntype T2 = IsTupleMultiple<[1]>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 39
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Push",
            "signature": "type Push<$T extends any[], $V> = [...$T, $V]",
            "description": "Push a value onto a tuple.",
            "examples": [
              {
                "code": "type T = Push<[1, 2], 3>  // [1, 2, 3]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "FirstNonUnknownNever",
            "signature": "type FirstNonUnknownNever<$T extends any[]> = $T extends [infer __first__, ...infer __rest__]\n  ? unknown extends __first__ ? 0 extends 1 & __first__ ? FirstNonUnknownNever<__rest__> // is any\n    : FirstNonUnknownNever<__rest__> // is unknown\n  : __first__ extends never ? FirstNonUnknownNever<__rest__>\n  : __first__\n  : never",
            "description": "Get the first non-unknown, non-never element from a tuple.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 57
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "empty",
            "signature": "readonly []",
            "description": "Empty array constant.",
            "examples": [
              {
                "code": "import { Arr } from '@wollybeard/kit'\n\nconst emptyArray = Arr.empty\nconsole.log(emptyArray) // []",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use Array.empty from Effect instead",
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 78
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "emptyArray",
            "signature": "readonly []",
            "description": "Empty array constant (frozen). Useful as a default value or sentinel.",
            "examples": [
              {
                "code": "const arr = items ?? Arr.emptyArray",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 90
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "EmptyArray",
            "signature": "type EmptyArray = typeof emptyArray",
            "description": "Type for the empty array constant.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 97
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "includes",
            "signature": "<$T>(array: $T[], value: unknown) => value is $T",
            "description": "Type-safe array includes check that narrows the type of the value. Unlike the standard includes, this provides proper type narrowing.",
            "examples": [
              {
                "code": "const fruits = ['apple', 'banana', 'orange'] as const\nconst value: unknown = 'apple'\n\nif (Arr.includes(fruits, value)) {\n  // value is now typed as 'apple' | 'banana' | 'orange'\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Search",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 148
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensure",
            "signature": "<$T>(value: $T | $T[]) => $T[]",
            "description": "Ensure a value is an array. If the value is already an array, return it as-is. Otherwise, wrap it in an array.",
            "examples": [
              {
                "code": "Arr.ensure('hello')  // ['hello']\nArr.ensure(['a', 'b'])  // ['a', 'b']\nArr.ensure(42)  // [42]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Normalization",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 169
            },
            "_tag": "value",
            "type": "function"
          }
        ],
        "category": "Core Data Structures"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./err",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "err"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Error handling utilities for robust error management.  Provides utilities for error inspection, stack trace manipulation, try-catch wrappers, type guards, and null safety. Features formatted error logging and error wrapping utilities.",
        "exports": [
          {
            "name": "log",
            "signature": "(error: Error, options?: { color?: boolean; stackTraceColumns?: number; identColumns?: number; showHelp?: boolean; } | undefined) => void",
            "description": "Log an error to console with nice formatting.",
            "examples": [],
            "category": "Inspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 21
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "throwNull",
            "signature": "<V>(value: V, message?: string | undefined) => Exclude<V, null>",
            "description": "Throw an error if the value is null, otherwise return the non-null value.",
            "examples": [
              {
                "code": "const result = throwNull(maybeNull) // throws if null\nconst safe = throwNull(maybeNull, 'Custom error message')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {
              "throws": "Error if the value is null"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 39
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "defaultThrowNullMessage",
            "signature": "\"Unexpected null value.\"",
            "description": "Default error message used by throwNull when no custom message is provided.",
            "examples": [],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "guardNull",
            "signature": "<fn extends Fn.AnyAny>(fn: fn, message?: string | undefined) => ReturnExclude<null, fn>",
            "description": "Wrap a function to throw an error if it returns null.",
            "examples": [
              {
                "code": "const find = (id: string) => items.find(item => item.id === id) ?? null\nconst findOrThrow = guardNull(find, 'Item not found')\n\nconst item = findOrThrow('123') // throws if not found",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 67
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "InferOptions",
            "signature": "type InferOptions<$EnvironmentConfigurableOptions extends EnvironmentConfigurableOptionSpec[]> = Ts.Simplify<\n  ArrMut.ReduceWithIntersection<_InferOptions<$EnvironmentConfigurableOptions>>\n>",
            "description": "Type helper for inferring option types from environment configurable option specifications. Transforms an array of option specs into a typed options object.   $EnvironmentConfigurableOptions - Array of option specifications",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 34
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "_InferOptions",
            "signature": "type _InferOptions<$EnvironmentConfigurableOptions extends EnvironmentConfigurableOptionSpec[]> = {\n  [i in keyof $EnvironmentConfigurableOptions]: {\n    [_ in $EnvironmentConfigurableOptions[i]['name']]?: ReturnType<$EnvironmentConfigurableOptions[i]['parse']>\n  }\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 38
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "InspectOptions",
            "signature": "type InspectOptions = InferOptions<typeof optionSpecs>",
            "description": "Options for configuring error inspection output. All options can be overridden via environment variables.   color - Whether to use ANSI color codes for better readability (default: true, env: ERROR_DISPLAY_COLOR)  stackTraceColumns - Maximum column width before truncating stack trace lines (default: 120, env: ERROR_DISPLAY_STACK_TRACE_COLUMNS)  identColumns - Number of spaces to use for indentation (default: 4, env: ERROR_DISPLAY_IDENT_COLUMNS)  showHelp - Whether to display the environment variable help section (default: true, env: ERROR_DISPLAY_SHOW_HELP)",
            "examples": [
              {
                "code": "// Use default options\nErr.inspect(error)\n\n// Customize options\nErr.inspect(error, {\n  color: false,\n  stackTraceColumns: 200,\n  showHelp: false\n})\n\n// Set via environment variables\nprocess.env.ERROR_DISPLAY_COLOR = 'false'\nprocess.env.ERROR_DISPLAY_SHOW_HELP = 'false'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Inspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 164
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "InspectConfig",
            "signature": "type InspectConfig = Resolve<typeof optionSpecs>",
            "description": "Resolved configuration for error inspection with values and sources. Contains the final values after merging defaults, user options, and environment variables.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 172
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "inspect",
            "signature": "(error: Error, options?: { color?: boolean; stackTraceColumns?: number; identColumns?: number; showHelp?: boolean; } | undefined) => string",
            "description": "Render an error to a string with detailed formatting.  Features: - Nested error support (causes and aggregate errors) - Context object formatting - Stack trace cleaning with filtering indicators - Tree-like visual guides for nested structures - Configurable via options or environment variables",
            "examples": [
              {
                "code": "// Simple error\nconst error = new Error('Something went wrong')\nconsole.log(Err.inspect(error))\n\n// Error with context\nconst contextError = new Error('API failed')\ncontextError.context = { userId: 123, endpoint: '/api/users' }\nconsole.log(Err.inspect(contextError))\n\n// Aggregate error with multiple failures\nconst errors = [\n  new Error('Database connection failed'),\n  new Error('Redis timeout')\n]\nconst aggregate = new AggregateError(errors, 'Multiple services failed')\nconsole.log(Err.inspect(aggregate))\n\n// Disable help section\nconsole.log(Err.inspect(error, { showHelp: false }))",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Inspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 228
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "StackOptions",
            "signature": "interface StackOptions {\n  /**\n   * Remove internal library frames from the stack trace.\n   * @default true\n   */\n  removeInternal?: boolean\n\n  /**\n   * Patterns to filter out from stack traces.\n   * @default ['node_modules', 'node:internal']\n   */\n  filterPatterns?: string[]\n\n  /**\n   * Maximum number of frames to show.\n   * @default 10\n   */\n  maxFrames?: number\n\n  /**\n   * Include source code context around error location.\n   * @default false\n   */\n  includeSource?: boolean\n\n  /**\n   * Number of source lines to show before and after error.\n   * @default 2\n   */\n  sourceContext?: number\n}",
            "description": "Options for cleaning and formatting stack traces.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "StackFrame",
            "signature": "interface StackFrame {\n  /**\n   * Function name or <anonymous>\n   */\n  function: string\n\n  /**\n   * File path\n   */\n  file: string\n\n  /**\n   * Line number\n   */\n  line: number\n\n  /**\n   * Column number\n   */\n  column: number\n\n  /**\n   * Whether this is internal to the library\n   */\n  isInternal: boolean\n\n  /**\n   * Whether this is a native V8 frame\n   */\n  isNative: boolean\n\n  /**\n   * Raw frame string\n   */\n  raw: string\n}",
            "description": "Parsed stack frame information.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 46
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "parseStack",
            "signature": "(stack: string) => StackFrame[]",
            "description": "Parse a stack trace string into structured frames.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 88
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "StackCleanStats",
            "signature": "interface StackCleanStats {\n  /**\n   * Total number of frames before filtering.\n   */\n  totalFrames: number\n\n  /**\n   * Number of frames filtered out.\n   */\n  filteredFrames: number\n\n  /**\n   * Number of node_modules frames filtered.\n   */\n  nodeModulesFrames: number\n\n  /**\n   * Number of internal frames filtered.\n   */\n  internalFrames: number\n\n  /**\n   * Number of frames shown.\n   */\n  shownFrames: number\n\n  /**\n   * Whether the output was truncated due to maxFrames.\n   */\n  wasTruncated: boolean\n}",
            "description": "Statistics about stack trace filtering. Provides detailed information about what was filtered during stack cleaning.",
            "examples": [
              {
                "code": "const result = cleanStackWithStats(error.stack)\nconsole.log(`Filtered ${result.stats.filteredFrames} frames`)\nconsole.log(`Showing ${result.stats.shownFrames} of ${result.stats.totalFrames} total`)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 167
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "CleanStackResult",
            "signature": "interface CleanStackResult {\n  /**\n   * The cleaned stack trace string.\n   */\n  stack: string\n\n  /**\n   * Statistics about what was filtered.\n   */\n  stats: StackCleanStats\n}",
            "description": "Result of cleaning a stack trace. Contains both the cleaned stack string and statistics about what was filtered.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 207
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "cleanStackWithStats",
            "signature": "(stack: string, options?: StackOptions | undefined) => CleanStackResult",
            "description": "Clean a stack trace by removing internal frames and applying filters. Returns both the cleaned stack and detailed statistics about filtering.",
            "examples": [
              {
                "code": "const error = new Error('Something failed')\nconst result = cleanStackWithStats(error.stack, {\n  removeInternal: true,\n  filterPatterns: ['node_modules'],\n  maxFrames: 10\n})\n\nconsole.log(result.stack) // Cleaned stack trace\nconsole.log(`Filtered ${result.stats.nodeModulesFrames} node_modules frames`)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 242
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "cleanStack",
            "signature": "(stack: string, options?: StackOptions | undefined) => string",
            "description": "Clean a stack trace by removing internal frames and applying filters.",
            "examples": [],
            "deprecated": "Use cleanStackWithStats for detailed filtering information",
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 317
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "formatFrame",
            "signature": "(frame: StackFrame) => string",
            "description": "Format a stack frame for better readability.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 326
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "CleanError",
            "signature": "export class CleanError extends Error {\n  /**\n   * Original uncleaned stack trace.\n   */\n  originalStack?: string\n\n  /**\n   * Additional context for the error.\n   */\n  context?: Context\n\n  constructor(message: string, options?: ErrorOptions & { context?: Context; stackOptions?: StackOptions }) {\n    super(message, options)\n    this.name = this.constructor.name\n\n    if (options?.context) {\n      this.context = options.context\n    }\n\n    // Clean the stack trace\n    if (this.stack) {\n      this.originalStack = this.stack\n      this.stack = cleanStackWithStats(this.stack, options?.stackOptions).stack\n    }\n\n    // Ensure proper prototype chain\n    Object.setPrototypeOf(this, new.target.prototype)\n  }\n}",
            "description": "Enhanced Error class that automatically cleans stack traces.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 338
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "mergeStacks",
            "signature": "(wrapper: Error, cause: Error) => string",
            "description": "Merge stack traces from multiple errors (useful for wrapped errors). This preserves the full error chain while removing duplicates.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 374
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "captureStackTrace",
            "signature": "(message?: string) => string",
            "description": "Capture the current stack trace at a specific point. Useful for adding trace information without throwing.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 422
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getCaller",
            "signature": "(depth?: number) => StackFrame | undefined",
            "description": "Get the caller information from the current stack.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 431
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryCatch",
            "signature": "function tryCatch<returned, thrown>(promise: Promise<returned>, predicates?: readonly [Bool.TypePredicate<thrown>, ...readonly Bool.TypePredicate<thrown>[]]): Promise<returned | (IsUnknown<thrown> extends true ? Error : thrown)>",
            "description": "Try to execute a function or resolve a promise, catching errors instead of throwing. Returns either the successful result or the caught error.",
            "examples": [
              {
                "code": "// With function\nconst result = tryCatch(() => JSON.parse(input)) // parsed value | Error\n\n// With promise\nconst data = await tryCatch(fetch(url)) // Response | Error\n\n// With custom predicates\nconst isNetworkError = (e: unknown): e is NetworkError =>\n  e instanceof Error && e.name === 'NetworkError'\n\nconst response = tryCatch(\n  () => fetch(url),\n  [isNetworkError]\n) // Response | NetworkError",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 100
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrRethrow",
            "signature": "function tryOrRethrow<$Return>(fn: () => $Return, wrapper: string | WrapOptions | ((cause: Error) => Error)): $Return extends Promise<any> ? $Return : $Return",
            "description": "Try to execute a function and wrap any thrown errors with a higher-level message. Handles both synchronous and asynchronous functions automatically.",
            "examples": [
              {
                "code": "// Simple string message\nconst data = await tryOrRethrow(\n  fetchData,\n  'Failed to fetch data'\n)\n\n// With options\nconst user = await tryOrRethrow(\n  () => fetchUser(userId),\n  { message: 'Failed to fetch user', context: { userId } }\n)\n\n// With wrapper function\nconst result = await tryOrRethrow(\n  riskyOperation,\n  wrapWith('Operation failed')\n)\n\n// Custom error wrapper\nconst config = await tryOrRethrow(\n  loadConfig,\n  (cause) => new ConfigError('Failed to load config', { cause })\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {
              "throws": "The wrapped error if the function throws"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 420
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryAllOrRethrow",
            "signature": "function tryAllOrRethrow<$Fns extends readonly [() => any, ...Array<() => any>]>(fns: $Fns, wrapper: string | WrapOptions | ((cause: Error) => Error)): Promise<{ [K in keyof $Fns]: Awaited<ReturnType<$Fns[K]>>; }>",
            "description": "Try multiple functions and wrap any errors with a higher-level message. If any function throws, all errors are collected into an AggregateError.",
            "examples": [
              {
                "code": "const [users, posts] = await tryAllOrRethrow(\n  [fetchUsers, fetchPosts],\n  'Failed to load data'\n)\n\n// With context\nconst [config, schema, data] = await tryAllOrRethrow(\n  [loadConfig, loadSchema, loadData],\n  { message: 'Failed to initialize', context: { env: 'production' } }\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {
              "throws": "AggregateError with wrapped individual errors if any fail"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 461
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "TryCatchDefaultPredicateTypes",
            "signature": "type TryCatchDefaultPredicateTypes = Error",
            "description": "Default error types caught by try/catch functions when no predicates are specified.",
            "examples": [],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 26
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "tryCatchify",
            "signature": "<fn extends Fn.AnyAny, thrown>(fn: fn, predicates?: readonly [TypePredicate<thrown>, ...TypePredicate<thrown>[]]) => (...args: Parameters<fn>) => AwaitedUnion<ReturnType<fn>, IsUnknown<thrown> extends true ? Error : thrown>",
            "description": "Transform a function to return caught errors instead of throwing them. The transformed function will return either the result or the caught error.",
            "examples": [
              {
                "code": "// Transform a throwing function\nconst parseJsonSafe = tryCatchify(JSON.parse)\nconst result = parseJsonSafe('{\"valid\": true}') // { valid: true }\nconst error = parseJsonSafe('invalid') // SyntaxError\n\n// With custom error predicates\nconst isNetworkError = (e: unknown): e is NetworkError =>\n  e instanceof Error && e.name === 'NetworkError'\n\nconst fetchSafe = tryCatchify(fetch, [isNetworkError])\nconst response = await fetchSafe(url) // Response | NetworkError",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 54
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryCatchIgnore",
            "signature": "<$Return>(fn: () => $Return) => $Return",
            "description": "Try to execute a function and silently ignore any errors. Returns the result if successful, or undefined if it throws. For async functions, errors are silently caught without rejection.",
            "examples": [
              {
                "code": "// Sync function\ntryCatchIgnore(() => JSON.parse(invalidJson)) // returns undefined\n\n// Async function\nawait tryCatchIgnore(async () => {\n  throw new Error('Network error')\n}) // returns undefined, no rejection",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 163
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOr",
            "signature": "<success, fallback>(fn: () => success, fallback: LazyMaybe<fallback>) => TryOrReturn<success, fallback>",
            "description": "Try to execute a function and return a fallback value if it throws.  **Type constraints:** - If fn is synchronous, fallback must also be synchronous - If fn is asynchronous, fallback can be either sync or async - For sync functions with async fallbacks, use tryOrAsync instead",
            "examples": [
              {
                "code": "// Sync function with sync fallback\nconst data = tryOr(\n  () => JSON.parse(input),\n  { error: 'Invalid JSON' }\n)\n\n// Async function with sync fallback\nconst config = await tryOr(\n  async () => loadConfig(),\n  () => getDefaultConfig()\n)\n\n// Async function with async fallback\nconst data = await tryOr(\n  async () => fetchFromPrimary(),\n  async () => fetchFromSecondary()\n)\n\n// This would be a TYPE ERROR:\n// const bad = tryOr(\n//   () => 42,                    // sync\n//   async () => 'fallback'       // async - not allowed!\n// )",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 212
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsync",
            "signature": "<success, fallback>(fn: () => success, fallback: LazyMaybe<fallback>) => Promise<Awaited<success> | Awaited<fallback>>",
            "description": "Try to execute a function and return a fallback value if it throws. Always returns a Promise, allowing async fallbacks for sync functions.  Use this when: - You have a sync function with an async fallback - You want consistent async behavior regardless of input types",
            "examples": [
              {
                "code": "// Sync function with async fallback\nconst data = await tryOrAsync(\n  () => readFileSync('config.json'),\n  async () => fetchDefaultConfig()\n)\n\n// Ensures consistent Promise return\nconst result = await tryOrAsync(\n  () => 42,\n  () => 'fallback'\n) // Always Promise<number | string>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 262
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsyncOn",
            "signature": "<success>(fn: () => success) => <fallback>(fallback: LazyMaybe<fallback>) => Promise<Awaited<success> | Awaited<fallback>>",
            "description": "Curried version of tryOrAsync that takes the function first. Useful for creating reusable async error handlers.",
            "examples": [
              {
                "code": "const parseJsonOrFetch = tryOrAsyncOn(() => JSON.parse(input))\nconst data = await parseJsonOrFetch(async () => fetchDefault())",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 287
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsyncWith",
            "signature": "<fallback>(fallback: LazyMaybe<fallback>) => <success>(fn: () => success) => Promise<Awaited<success> | Awaited<fallback>>",
            "description": "Curried version of tryOrAsync that takes the fallback first. Always returns a Promise regardless of input types.",
            "examples": [
              {
                "code": "const orFetchDefault = tryOrAsyncWith(async () => fetchDefault())\nconst data1 = await orFetchDefault(() => localData())\nconst data2 = await orFetchDefault(() => cachedData())",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 306
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrOn",
            "signature": "<success>(fn: () => success) => <fallback>(fallback: LazyMaybe<fallback>) => TryOrReturn<success, fallback>",
            "description": "Curried version of tryOr that takes the function first. Useful for creating reusable error handlers.  **Note:** Same type constraints as tryOr apply - sync functions require sync fallbacks.",
            "examples": [
              {
                "code": "const parseJsonOr = tryOrOn(() => JSON.parse(input))\nconst data = parseJsonOr({ error: 'Invalid JSON' })",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 326
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrWith",
            "signature": "<fallback>(fallback: LazyMaybe<fallback>) => <success>(fn: () => success) => TryOrReturn<success, fallback>",
            "description": "Curried version of tryOr that takes the fallback first. Useful for creating reusable fallback patterns.  **Note:** Same type constraints as tryOr apply - sync functions require sync fallbacks.",
            "examples": [
              {
                "code": "const orDefault = tryOrWith({ status: 'unknown', data: null })\n\nconst result1 = orDefault(() => fetchStatus())\nconst result2 = orDefault(() => getLatestData())",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 348
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrUndefined",
            "signature": "<success>(fn: () => success) => TryOrReturn<success, undefined>",
            "description": "Try to execute a function and return undefined if it throws. Shorthand for tryOrWith(undefined).",
            "examples": [
              {
                "code": "const data = tryOrUndefined(() => localStorage.getItem('key'))\n// data is string | undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 365
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "tryOrNull",
            "signature": "<success>(fn: () => success) => TryOrReturn<success, null>",
            "description": "Try to execute a function and return null if it throws. Shorthand for tryOrWith(null).",
            "examples": [
              {
                "code": "const user = await tryOrNull(async () => fetchUser(id))\n// user is User | null",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 379
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "is",
            "signature": "(value: unknown) => value is Error",
            "description": "Type predicate to check if a value is an Error instance.",
            "examples": [
              {
                "code": "is(new Error('test')) // true\nis('not an error') // false\nis(null) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isAggregateError",
            "signature": "(value: unknown) => value is AggregateError",
            "description": "Check if a value is an AggregateError instance.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isAbortError",
            "signature": "(error: any) => error is DOMException & { name: \"AbortError\"; }",
            "description": "Check if an error is an AbortError (from AbortController/AbortSignal).",
            "examples": [
              {
                "code": "const controller = new AbortController()\ncontroller.abort()\n\ntry {\n  await fetch(url, { signal: controller.signal })\n} catch (error) {\n  if (isAbortError(error)) {\n    console.log('Request was aborted')\n  }\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensure",
            "signature": "(value: unknown) => Error",
            "description": "Ensure that the given value is an error and return it. If it is not an error than wrap it in one, passing the given value as the error message.",
            "examples": [],
            "category": "Conversion",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Context",
            "signature": "type Context = object",
            "description": "Context information that can be attached to errors. Must be an object to ensure it can be properly serialized and inspected.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "types",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ErrorWithContext",
            "signature": "interface ErrorWithContext extends Error {\n  /**\n   * Additional context information about the error.\n   */\n  context?: Context\n}",
            "description": "An error that includes additional context information.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "types",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "WrapOptions",
            "signature": "interface WrapOptions {\n  /**\n   * The error message for the wrapper error.\n   */\n  message: string\n  /**\n   * Additional context to attach to the error.\n   */\n  context?: Context\n}",
            "description": "Options for wrapping errors with additional context.",
            "examples": [],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "wrap",
            "signature": "(cause: unknown, messageOrOptions: string | WrapOptions) => Error",
            "description": "Wrap an error with a higher-level error message. If the input is not an Error, it will be converted to one using ensure.",
            "examples": [
              {
                "code": "try {\n  await fetchData()\n} catch (error) {\n  throw wrap(error, 'Failed to fetch data')\n}\n\n// With context\ntry {\n  await fetchUser(userId)\n} catch (error) {\n  throw wrap(error, {\n    message: 'Failed to fetch user',\n    context: { userId }\n  })\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 51
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrapOn",
            "signature": "(cause: unknown) => (messageOrOptions: string | WrapOptions) => Error",
            "description": "Curried version of wrap that takes the error first. Useful for error handling pipelines.",
            "examples": [
              {
                "code": "const wrapFetchError = wrapOn(networkError)\nthrow wrapFetchError('Failed to fetch data')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 83
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "wrapWith",
            "signature": "(messageOrOptions: string | WrapOptions) => (cause: unknown) => Error",
            "description": "Curried version of wrap that takes the message/options first. Useful for creating reusable error wrappers.",
            "examples": [
              {
                "code": "const wrapAsFetchError = wrapWith('Failed to fetch data')\n\ntry {\n  await fetchData()\n} catch (error) {\n  throw wrapAsFetchError(error)\n}\n\n// With context\nconst wrapAsUserError = wrapWith({\n  message: 'Failed to process user',\n  context: { operation: 'update' }\n})",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 108
            },
            "_tag": "value",
            "type": "const"
          }
        ],
        "category": "Error Handling & Values"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./fn",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "fn"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Function utilities for functional programming patterns.  Provides utilities for function composition, currying, partial application, piping, and common functional patterns like identity and constant functions. Includes function analysis tools and endomorphism utilities.",
        "exports": [
          {
            "name": "Parameter",
            "signature": "type Parameter = { type: 'name'; value: string } | { type: 'destructured'; names: string[] }",
            "examples": [],
            "category": "Introspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "analyze",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 6
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "analyzeFunction",
            "signature": "(fn: (...args: any[]) => unknown) => { body: string; parameters: Parameter[]; }",
            "description": "Analyze a function to extract its parameter information and body.  Parses a function's string representation to extract: - Parameter names (both regular and destructured parameters) - Function body (both statement and expression forms)",
            "examples": [
              {
                "code": "const fn = (a, { b, c }) => a + b + c\nconst info = analyzeFunction(fn)\n// info.parameters: [{ type: 'name', value: 'a' }, { type: 'destructured', names: ['b', 'c'] }]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Introspection",
            "tags": {
              "throws": "Error If the function cannot be parsed or has invalid structure"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "analyze",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AnyAny",
            "signature": "type AnyAny = (...args: any[]) => any",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 8
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParameters2",
            "signature": "type AnyAnyParameters2 = (arg1: any, arg2: any) => any",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin1",
            "signature": "type AnyAnyParametersMin1 = (...args: [any, ...any[]]) => any",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin2",
            "signature": "type AnyAnyParametersMin2 = (...args: [any, any, ...any[]]) => any",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 23
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin3",
            "signature": "type AnyAnyParametersMin3 = (...args: [any, any, any, ...any[]]) => any",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 28
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "is",
            "signature": "TypeGuard<AnyAny>",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 33
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "AnyAnyAsync",
            "signature": "type AnyAnyAsync = (...args: any[]) => Prom.AnyAny",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 38
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GuardedType",
            "signature": "type GuardedType<$T> = $T extends (x: any) => x is infer __u__ ? __u__ : never",
            "description": "Extract the guarded type from a type guard function.",
            "examples": [
              {
                "code": "const isString = (x: any): x is string => typeof x === 'string'\ntype T = GuardedType<typeof isString>  // string",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExtract",
            "signature": "type ReturnExtract<$Type, $Fn extends AnyAny> =\n\t$Fn extends (...args: infer __args__) => infer __return__\n\t\t\t? (...args: __args__) =>\n        __return__ extends Prom.AnyAny\n          ? Promise<Extract<Awaited<__return__>, $Type>>\n          : Extract<__return__, $Type>\n\t\t\t: never",
            "description": "Modify function such that it only returns the given type.  Automatically handles async functions by unwrapping the Promise, extracting the type, and rewrapping in a Promise. For sync functions, the type is extracted directly.  Assumes that the given type is among the possible return types of the function.",
            "examples": [
              {
                "code": "// Sync function\ntype Fn1 = (x: number) => string | number\ntype Result1 = ReturnExtract<string, Fn1>  // (x: number) => string\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string | number>\ntype Result2 = ReturnExtract<string, Fn2>  // (x: number) => Promise<string>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 73
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnReplace",
            "signature": "type ReturnReplace<$Fn extends AnyAny, $Type> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => $Type\n    : never",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 85
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExclude",
            "signature": "type ReturnExclude<$Type, $Fn extends AnyAny> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => (\n        __return__ extends Prom.AnyAny\n          ? Promise<Exclude<Awaited<__return__>, $Type>>\n          : Exclude<__return__, $Type>\n    )\n    : never",
            "description": "Modify function such that it does not return the given type.  Automatically handles async functions by unwrapping the Promise, excluding the type, and rewrapping in a Promise. For sync functions, the type is excluded directly.  If function does not return the given the type, then this is effectively an identity function.",
            "examples": [
              {
                "code": "// Sync function\ntype Fn1 = (x: number) => string | null\ntype Result1 = ReturnExclude<null, Fn1>  // (x: number) => string\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string | null>\ntype Result2 = ReturnExclude<null, Fn2>  // (x: number) => Promise<string>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 111
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExcludeNull",
            "signature": "type ReturnExcludeNull<$Fn extends AnyAny> = ReturnExclude<null, $Fn>",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 123
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnInclude",
            "signature": "type ReturnInclude<$Type, $Fn extends AnyAny> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => (\n        __return__ extends Prom.AnyAny\n          ? Promise<$Type | Awaited<__return__>>\n          : $Type | __return__\n    )\n    : never",
            "description": "Modify function such that it can return an additional type along with its original return types.  Automatically handles async functions by unwrapping the Promise, adding the type to the union, and rewrapping in a Promise. For sync functions, the type is added directly to the return type union.  This is useful for functions that may return early with a specific type (like void).",
            "examples": [
              {
                "code": "// Sync function\ntype Fn1 = (x: number) => string\ntype Result1 = ReturnInclude<null, Fn1>  // (x: number) => string | null\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string>\ntype Result2 = ReturnInclude<null, Fn2>  // (x: number) => Promise<string | null>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 146
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "bind",
            "signature": "<fn extends AnyAny>(fn: AnyAnyParametersMin1 extends fn ? fn : { Error: \"Given function must have at least one parameter\"; }, arg: Parameters<fn>[0]) => bind<fn>",
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 160
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "noop",
            "signature": "() => void",
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 183
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "$identityPartial",
            "signature": "<value>(value: PartialDeep<value>) => value",
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 188
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "applySecond",
            "signature": "<fn extends (...args: any[]) => (arg: any) => any, arg>(fn: fn, arg: arg) => applySecond<fn, arg>",
            "description": "Apply the second parameter of a curried function. For a function (a) = (b) = c and a value b, returns (a) = c Useful for creating service interfaces from curried operations.",
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 199
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "constant",
            "signature": "<value>(value: value) => () => value",
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "constant",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AnyAny2Curried",
            "signature": "type AnyAny2Curried = (arg1: any) => (arg2: any) => any",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "curry",
            "signature": "<fn extends AnyAny>(fn: AnyAnyParametersMin1 extends fn ? fn : { Error: \"Given function must have at least one parameter\"; }) => curry<fn>",
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 12
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "uncurry",
            "signature": "<fn extends AnyAny2Curried>(fn: fn) => uncurry<fn>",
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 66
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "flipCurried",
            "signature": "<fn extends AnyAny2Curried>(fn: fn) => flipCurried<fn>",
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 84
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "endo",
            "signature": "type endo<$T = any> = ($value: $T) => $T",
            "description": "Endomorphism - a function from a type to itself.  Unlike identity, this doesn't preserve the exact value, just ensures the output type matches the input type.",
            "examples": [
              {
                "code": "// Builder pattern\ntype BuilderOp = Fn.endo<StringBuilder>\nconst addText: BuilderOp = sb => sb.append('text')\n\n// Transformations\ntype StringTransform = Fn.endo<string>\nconst uppercase: StringTransform = s => s.toUpperCase()\nconst trim: StringTransform = s => s.trim()\n\n// Chainable operations\ntype ChainOp = Fn.endo<ChainableAPI>\nconst configure: ChainOp = api => api.setOption('key', 'value')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Endomorphisms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "endo",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 24
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "identity",
            "signature": "identity<any>",
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "identity",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "_",
            "signature": "typeof _",
            "description": "Symbol used to represent a hole in partial application. When used as an argument, indicates that the parameter should be deferred.",
            "examples": [
              {
                "code": "const add = (a: number, b: number) => a + b\nconst addOne = partial(add, _, 1) // (a: number) => number\naddOne(5) // 6",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 15
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isHole",
            "signature": "(value: unknown) => value is typeof _",
            "description": "Type guard to check if a value is a hole.",
            "examples": [],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "partial",
            "signature": "<$Fn extends Fn.AnyAny, const $Args extends readonly unknown[]>(fn: $Fn, ...args: $Args) => any",
            "description": "Create a partially applied function by providing some arguments upfront. Use the hole symbol (_) to defer parameters.",
            "examples": [
              {
                "code": "// Basic usage\nconst add = (a: number, b: number) => a + b\nconst addOne = partial(add, _, 1)\naddOne(5) // 6\n\n// Multiple holes\nconst greet = (greeting: string, name: string, punctuation: string) =>\n  `${greeting}, ${name}${punctuation}`\nconst casualGreet = partial(greet, 'Hey', _, '!')\ncasualGreet('Alice') // 'Hey, Alice!'\n\n// All arguments provided - executes immediately\nconst result = partial(add, 1, 2) // 3",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 55
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "apply",
            "signature": "<$Fn extends Fn.AnyAny, const $Args extends readonly unknown[]>(fn: $Fn, ...args: $Args) => any",
            "description": "Type-safe partial application with automatic type inference. This is an alias for partial with a more explicit name.",
            "examples": [
              {
                "code": "const multiply = (a: number, b: number, c: number) => a * b * c\nconst double = apply(multiply, 2, _, 1)\ndouble(5) // 10",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 97
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "defer",
            "signature": "<$Fn extends Fn.AnyAny>(fn: $Fn, ...args: Parameters<$Fn>) => () => ReturnType<$Fn>",
            "description": "Helper to create a deferred computation using partial application. Useful for creating thunks or delayed evaluations.",
            "examples": [
              {
                "code": "const expensiveComputation = (a: number, b: number) => {\n  console.log('Computing...')\n  return a * b\n}\n\nconst deferred = defer(expensiveComputation, 5, 10)\n// Nothing logged yet\n\nconst result = deferred() // Logs: 'Computing...'\n// result: 50",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 118
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isPartialArg",
            "signature": "(_value: unknown) => _value is unknown",
            "description": "Check if a value is potentially a partially applicable argument (either a hole or a regular value).",
            "examples": [],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 131
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "pipe",
            "signature": "function pipe<value>(value: value): value",
            "description": "Pipe a value through a series of unary functions.",
            "examples": [
              {
                "code": "const add1 = (x: number) => x + 1\nconst double = (x: number) => x * 2\nconst toString = (x: number) => x.toString()\n\npipe(5, add1, double) // 12\npipe(5, add1, double, toString) // \"12\"",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Composition",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "pipe",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 26
            },
            "_tag": "value",
            "type": "function"
          }
        ],
        "category": "Core Data Structures"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./json",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "json"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "JSON utilities with Effect Schema integration.  Provides type-safe JSON operations including type guards, parsing, encoding, and validation using Effect Schema. Supports JSON primitives, objects, and recursive value structures with comprehensive error handling.",
        "exports": [
          {
            "name": "Primitive",
            "signature": "type Primitive = string | number | boolean | null",
            "description": "JSON primitive type. Matches: string, number, boolean, or null.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "Obj",
            "signature": "type Obj = { [key in string]?: Value }",
            "description": "JSON object type.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Value",
            "signature": "type Value = Primitive | Obj | Value[]",
            "description": "JSON value type. Matches any valid JSON value: primitives, objects, or arrays (recursively).",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 33
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "Object",
            "signature": "type Obj = { [key in string]?: Value }",
            "description": "JSON object type.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isPrimitive",
            "signature": "(value: unknown) => value is Primitive",
            "description": "Type guard to check if a value is a JSON primitive.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 51
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isValue",
            "signature": "(value: unknown) => value is Value",
            "description": "Type guard to check if a value is a valid JSON value.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isObject",
            "signature": "(value: unknown) => value is Obj",
            "description": "Type guard to check if a value is a JSON object.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 87
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PrimitiveSchema",
            "signature": "Union<[typeof String, typeof Number, typeof Boolean, typeof Null]>",
            "description": "JSON primitive value schema. Matches: string, number, boolean, or null.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 110
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ValueSchema",
            "signature": "Schema<Value, Value, never>",
            "description": "JSON value schema. Matches any valid JSON value: primitives, objects, or arrays (recursively).",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 124
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ObjectSchema",
            "signature": "Record$<typeof String, Schema<Value, Value, never>>",
            "description": "JSON object schema. Matches objects with string keys and JSON values.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 138
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parseJsonSchema",
            "signature": "SchemaClass<unknown, string, never>",
            "description": "Schema for parsing JSON strings to unknown values. Uses Effect's parseJson for better error handling.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 146
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parseJsonAs",
            "signature": "<A>(schema: Schema<A, A, never>) => transform<SchemaClass<unknown, string, never>, Schema<A, A, never>>",
            "description": "Schema for parsing JSON with type validation.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 153
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "codec",
            "signature": "Codec<Value>",
            "description": "Codec for JSON values with pretty-printing. Uses Effect's parseJson for decoding.",
            "examples": [],
            "category": "Codec",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 169
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "encode",
            "signature": "Encode<Value>",
            "description": "Encode a JSON value to a pretty-printed string.",
            "examples": [],
            "category": "Codec",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 187
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "decode",
            "signature": "Decode<Value>",
            "description": "Parse a JSON string to a typed value. Uses Effect's parseJson for better error messages.",
            "examples": [],
            "category": "Codec",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 195
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ObjectParser",
            "signature": "{ parse: (value: unknown) => { readonly [x: string]: Value; }; }",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 225
            },
            "_tag": "value",
            "type": "const"
          }
        ],
        "category": "Serialization & Network"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./num",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "num"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Numeric types and utilities with branded types for mathematical constraints.  Provides branded number types (Positive, Negative, Even, Odd, etc.) with runtime validation, mathematical operations, range types, and specialized numeric domains like Complex, Ratio, and BigInt. Includes type guards, ordering, and equivalence utilities.",
        "exports": [
          {
            "_tag": "value",
            "name": "Degrees",
            "type": "namespace",
            "signature": "export * as Degrees",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "degrees"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "degrees"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Degrees",
                  "signature": "type Degrees = number & { [DegreesBrand]: true }",
                  "description": "Angle in degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 14
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Degrees",
                  "description": "Type predicate to check if value is a valid degree angle. Note: Any finite number can represent an angle in degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 20
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Construct a Degrees angle. Throws if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 28
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }) | null",
                  "description": "Try to construct a Degrees angle. Returns null if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 39
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromRadians",
                  "signature": "(radians: number) => number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Convert radians to degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toRadians",
                  "signature": "(deg: Degrees) => number",
                  "description": "Convert degrees to radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 53
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "normalize",
                  "signature": "(deg: Degrees) => number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Normalize degrees to the range [0, 360).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Even",
            "type": "namespace",
            "signature": "export * as Even",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "even"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "even"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Even",
                  "signature": "type Even = number & { [EvenBrand]: true }",
                  "description": "Even integer.  Even integers are whole numbers that are divisible by 2. They include zero and alternate with odd numbers on the number line. Note: This type combines with Int brand for maximum type safety.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 27
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is number & { [EvenBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Type predicate to check if value is even. Returns Even & Int when the value is an even integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 44
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [EvenBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Construct an Even integer. Throws if the value is not an even integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not an even integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 65
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [EvenBrand]: true; } & { [IntBrand]: true; }) | null",
                  "description": "Try to construct an Even integer. Returns null if the value is not an even integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 88
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": "(value: number) => number & { [EvenBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Get the next even number (rounds up if odd). For any number, returns the smallest even integer greater than or equal to it.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 106
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": "(value: number) => number & { [EvenBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Get the previous even number (rounds down if odd). For any number, returns the largest even integer less than or equal to it.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 125
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Finite",
            "type": "namespace",
            "signature": "export * as Finite",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "finite"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "finite"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Finite",
                  "signature": "type Finite = number & { [FiniteBrand]: true }",
                  "description": "Finite number (excludes NaN, Infinity, -Infinity).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Finite",
                  "description": "Type predicate to check if value is a finite number. Excludes NaN, Infinity, and -Infinity.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 17
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => Finite",
                  "description": "Construct a Finite number. Throws if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 25
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => Finite | null",
                  "description": "Try to construct a Finite number. Returns null if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 36
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Float",
            "type": "namespace",
            "signature": "export * as Float",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "float"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "float"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Float",
                  "signature": "type Float = number & { [FloatBrand]: true }",
                  "description": "Float (non-integer finite number).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 13
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Float",
                  "description": "Type predicate to check if value is a float (non-integer number).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [FloatBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Construct a Float. Throws if the value is not a float.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 26
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [FloatBrand]: true; } & { [FiniteBrand]: true; }) | null",
                  "description": "Try to construct a Float. Returns null if the value is not a float.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 40
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toFloat",
                  "signature": "(value: number) => number & { [FloatBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Convert an integer to a float by adding a small decimal.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "InRange",
            "type": "namespace",
            "signature": "export * as InRange",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "in-range"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "in-range"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "InRange",
                  "signature": "type InRange<Min extends number, Max extends number> = number & {\n  [InRangeBrand]: { min: Min; max: Max }\n}",
                  "description": "Range-constrained number.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "<Min extends number, Max extends number>(value: unknown, min: Min, max: Max) => value is InRange<Min, Max>",
                  "description": "Type predicate to check if value is within a specific range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "<Min extends number, Max extends number>(value: number, min: Min, max: Max) => InRange<Min, Max>",
                  "description": "Construct an InRange number. Throws if the value is outside the range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 30
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "<Min extends number, Max extends number>(value: number, min: Min, max: Max) => InRange<Min, Max> | null",
                  "description": "Try to construct an InRange number. Returns null if the value is outside the range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 45
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "Clamp",
                  "signature": "type Clamp<_T extends number, Min extends number, Max extends number> = InRange<Min, Max>",
                  "description": "Type-level clamp transformation. Ensures the result type is within the specified range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 57
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "clamp",
                  "signature": "<_T extends number, Min extends number, Max extends number>(value: _T, min: Min, max: Max) => Clamp<_T, Min, Max>",
                  "description": "Clamp a number to a range. Forces the value to be within the specified minimum and maximum bounds.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 63
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "clampOn",
                  "signature": "<_T extends number>(value: _T) => <Min extends number, Max extends number>(min: Min, max: Max) => Clamp<_T, Min, Max>",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 74
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "clampWith",
                  "signature": "<Min extends number, Max extends number>(min: Min, max: Max) => <_T extends number>(value: _T) => Clamp<_T, Min, Max>",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 82
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isOn",
                  "signature": "(value: unknown) => <Min extends number, Max extends number>(min: Min, max: Max) => boolean",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 90
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isWith",
                  "signature": "<Min extends number, Max extends number>(min: Min, max: Max) => (value: unknown) => value is InRange<Min, Max>",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 98
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Int",
            "type": "namespace",
            "signature": "export * as Int",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Int",
                  "signature": "type Int = number & { [IntBrand]: true }",
                  "description": "Integer number.  Integers are whole numbers without fractional parts. They can be positive, negative, or zero. In JavaScript, integers are represented as floating-point numbers but are guaranteed to have no decimal part.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 25
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Int",
                  "description": "Type predicate to check if value is an integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => Int",
                  "description": "Construct an Int. Throws if the value is not an integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not an integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 64
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => Int | null",
                  "description": "Try to construct an Int. Returns null if the value is not an integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 85
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "parse",
                  "signature": "(value: string) => Int | null",
                  "description": "Parse a string to an Int. Uses parseInt with base 10.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "round",
                  "signature": "(value: number) => Int",
                  "description": "Round a number to the nearest integer. Uses standard rounding rules (0.5 rounds up).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 127
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Natural",
            "type": "namespace",
            "signature": "export * as Natural",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "natural"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "natural"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Natural",
                  "signature": "type Natural = number & { [NaturalBrand]: true }",
                  "description": "Natural number (positive integer: 1, 2, 3, ...). These are the counting numbers used in everyday life.  Natural numbers are both integers and positive, so they combine both brands for maximum type safety.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 31
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }",
                  "description": "Type predicate to check if value is a natural number. Returns true for positive integers (1, 2, 3, ...).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }",
                  "description": "Construct a Natural number. Throws if the value is not a positive integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not a positive integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 68
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }) | null",
                  "description": "Try to construct a Natural number. Returns null if the value is not a positive integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 91
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "parseAsNatural",
                  "signature": "(value: string) => (number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }) | null",
                  "description": "Parse a string as a natural number. Returns null if the string doesn't represent a positive integer. Note: parseInt(\"1.5\") returns 1, but we check if the original string represents an integer by comparing with the parsed result.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 112
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": "(value: number) => number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }",
                  "description": "Get the next natural number. For any number, returns the smallest natural number greater than the input.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 135
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": "(value: number) => (number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }) | null",
                  "description": "Get the previous natural number. Returns null if there is no previous natural (i.e., for values = 1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 154
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Negative",
            "type": "namespace",
            "signature": "export * as Negative",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Negative",
                  "signature": "type Negative = number & { [NegativeBrand]: true }",
                  "description": "Negative number ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Negative",
                  "description": "Type predicate to check if value is negative ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => Negative",
                  "description": "Construct a Negative number. Throws if the value is not negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => Negative | null",
                  "description": "Try to construct a Negative number. Returns null if the value is not negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "negate",
                  "signature": "(value: number) => Negative",
                  "description": "Negate a positive number to make it negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "NonNegative",
            "type": "namespace",
            "signature": "export * as NonNegative",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "NonNegative",
                  "signature": "type NonNegative = number & { [NonNegativeBrand]: true }",
                  "description": "Non-negative number (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is NonNegative",
                  "description": "Type predicate to check if value is non-negative (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => NonNegative",
                  "description": "Construct a NonNegative number. Throws if the value is negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => NonNegative | null",
                  "description": "Try to construct a NonNegative number. Returns null if the value is negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "NonPositive",
            "type": "namespace",
            "signature": "export * as NonPositive",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "NonPositive",
                  "signature": "type NonPositive = number & { [NonPositiveBrand]: true }",
                  "description": "Non-positive number (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is NonPositive",
                  "description": "Type predicate to check if value is non-positive (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => NonPositive",
                  "description": "Construct a NonPositive number. Throws if the value is positive.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => NonPositive | null",
                  "description": "Try to construct a NonPositive number. Returns null if the value is positive.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "NonZero",
            "type": "namespace",
            "signature": "export * as NonZero",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "NonZero",
                  "signature": "type NonZero = number & { [NonZeroBrand]: true }",
                  "description": "Non-zero number ( 0).  Non-zero numbers are all numbers except zero. They are essential for safe division operations and other mathematical contexts where zero would cause errors or undefined behavior.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 25
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is NonZero",
                  "description": "Type predicate to check if value is non-zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => NonZero",
                  "description": "Construct a NonZero number. Throws if the value is zero.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 63
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => NonZero | null",
                  "description": "Try to construct a NonZero number. Returns null if the value is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 83
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDivide",
                  "signature": "(dividend: number, divisor: NonZero) => number",
                  "description": "Safely divide a number by a NonZero divisor. This operation is guaranteed to never throw.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 100
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDiv",
                  "signature": "(dividend: number, divisor: number) => number | null",
                  "description": "Try to divide two numbers safely. Returns null if the divisor is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 118
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDivOn",
                  "signature": "(dividend: number) => (divisor: number) => number | null",
                  "description": "Create a function that safely divides a fixed dividend by any divisor.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 137
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDivWith",
                  "signature": "(divisor: number) => (dividend: number) => number | null",
                  "description": "Create a function that safely divides any dividend by a fixed divisor.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 155
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Odd",
            "type": "namespace",
            "signature": "export * as Odd",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "odd"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "odd"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Odd",
                  "signature": "type Odd = number & { [OddBrand]: true }",
                  "description": "Odd integer. Note: This stacks with Int brand to allow Int & Odd.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is number & { [OddBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Type predicate to check if value is odd. Returns Odd & Int when the value is an odd integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 21
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [OddBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Construct an Odd integer. Throws if the value is not an odd integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 29
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [OddBrand]: true; } & { [IntBrand]: true; }) | null",
                  "description": "Try to construct an Odd integer. Returns null if the value is not an odd integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 43
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": "(value: number) => number & { [OddBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Get the next odd number (rounds up if even).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 50
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": "(value: number) => number & { [OddBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Get the previous odd number (rounds down if even).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 58
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Percentage",
            "type": "namespace",
            "signature": "export * as Percentage",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "percentage"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "percentage"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Percentage",
                  "signature": "type Percentage = InRange<0, 1> & { [PercentageBrand]: true }",
                  "description": "Percentage (0-1). Represents a value between 0% (0.0) and 100% (1.0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 14
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Percentage",
                  "description": "Type predicate for percentage (0-1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 19
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => Percentage",
                  "description": "Construct a Percentage. Throws if the value is not between 0 and 1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 27
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => Percentage | null",
                  "description": "Try to construct a Percentage. Returns null if the value is not between 0 and 1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 38
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromPercent",
                  "signature": "(value: number) => Percentage",
                  "description": "Convert a percentage value (0-100) to a decimal (0-1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 45
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toPercent",
                  "signature": "(value: Percentage) => number",
                  "description": "Convert a decimal (0-1) to a percentage value (0-100).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 52
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "clamp",
                  "signature": "(value: number) => Percentage",
                  "description": "Clamp a value to percentage range (0-1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 59
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Positive",
            "type": "namespace",
            "signature": "export * as Positive",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Positive",
                  "signature": "type Positive = number & { [PositiveBrand]: true }",
                  "description": "Positive number ( 0).  Positive numbers are all numbers greater than zero. They represent quantities, counts, and measurements in the real world.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Positive",
                  "description": "Type predicate to check if value is positive ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 40
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => Positive",
                  "description": "Construct a Positive number. Throws if the value is not positive.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not positive ( 0)"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => Positive | null",
                  "description": "Try to construct a Positive number. Returns null if the value is not positive.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 80
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Radians",
            "type": "namespace",
            "signature": "export * as Radians",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "radians"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "radians"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Radians",
                  "signature": "type Radians = number & { [RadiansBrand]: true }",
                  "description": "Angle in radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 14
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Radians",
                  "description": "Type predicate to check if value is a valid radian angle. Note: Any finite number can represent an angle in radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 20
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Construct a Radians angle. Throws if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 28
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }) | null",
                  "description": "Try to construct a Radians angle. Returns null if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 39
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromDegrees",
                  "signature": "(degrees: number) => number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Convert degrees to radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toDegrees",
                  "signature": "(rad: Radians) => number",
                  "description": "Convert radians to degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 53
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "normalize",
                  "signature": "(rad: Radians) => number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }",
                  "description": "Normalize radians to the range [0, 2).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "SafeInt",
            "type": "namespace",
            "signature": "export * as SafeInt",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "safe-int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "safe-int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "SafeInt",
                  "signature": "type SafeInt = number & { [SafeIntBrand]: true }",
                  "description": "Safe integer (within Number.MAX_SAFE_INTEGER).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 13
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is SafeInt",
                  "description": "Type predicate to check if value is a safe integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }",
                  "description": "Construct a SafeInt. Throws if the value is not a safe integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 26
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }) | null",
                  "description": "Try to construct a SafeInt. Returns null if the value is not a safe integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 37
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "MAX_SAFE_INT",
                  "signature": "number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }",
                  "description": "The maximum safe integer constant.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 44
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "MIN_SAFE_INT",
                  "signature": "number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }",
                  "description": "The minimum safe integer constant.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Whole",
            "type": "namespace",
            "signature": "export * as Whole",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "whole"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "whole"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Whole",
                  "signature": "type Whole = number & { [WholeBrand]: true }",
                  "description": "Whole number (non-negative integer: 0, 1, 2, 3, ...). These are the natural numbers plus zero.  Whole numbers are both integers and non-negative, so they combine both brands for maximum type safety.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 30
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }",
                  "description": "Type predicate to check if value is a whole number. Returns true for non-negative integers (0, 1, 2, 3, ...).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }",
                  "description": "Construct a Whole number. Throws if the value is not a non-negative integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not a non-negative integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 66
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => (number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }) | null",
                  "description": "Try to construct a Whole number. Returns null if the value is not a non-negative integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 89
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "parseAsWhole",
                  "signature": "(value: string) => (number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }) | null",
                  "description": "Parse a string as a whole number. Returns null if the string doesn't represent a non-negative integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": "(value: number) => number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }",
                  "description": "Get the next whole number. For any number, returns the smallest whole number greater than the input.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 127
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": "(value: number) => (number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }) | null",
                  "description": "Get the previous whole number. Returns null if there is no previous whole (i.e., for values = 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 146
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Zero",
            "type": "namespace",
            "signature": "export * as Zero",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Zero",
                  "signature": "type Zero = 0 & { [ZeroBrand]: true }",
                  "description": "Zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Zero",
                  "description": "Type predicate to check if value is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: number) => Zero",
                  "description": "Construct a Zero. Throws if the value is not zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: number) => Zero | null",
                  "description": "Try to construct a Zero. Returns null if the value is not zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "ZERO",
                  "signature": "Zero",
                  "description": "The zero constant.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Prime",
            "type": "namespace",
            "signature": "export * as Prime",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "prime"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "prime"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Prime",
                  "signature": "type Prime = Natural & { [PrimeBrand]: true }",
                  "description": "Prime number (natural number  1 with no divisors except 1 and itself).  Prime numbers are fundamental in mathematics and essential for: - Cryptography (RSA keys, Diffie-Hellman) - Hash table sizing (reduces collisions) - Random number generation - Number theory algorithms",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 26
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Prime",
                  "description": "Type predicate to check if value is a prime number. Uses trial division optimization up to sqrt(n).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 41
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: Natural) => Prime",
                  "description": "Construct a Prime number. Throws if the value is not prime.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not prime"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 74
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": "(value: Natural) => Prime | null",
                  "description": "Try to construct a Prime number. Returns null if the value is not prime.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 96
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": "(value: number) => Prime",
                  "description": "Find the next prime number after the given value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 114
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": "(value: number) => Prime | null",
                  "description": "Find the previous prime number before the given value. Returns null if no prime exists before the value (i.e., value = 2).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 141
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "nth",
                  "signature": "(n: Natural) => Prime",
                  "description": "Get the nth prime number (1-indexed). Uses a simple sieve for small n, trial division for larger.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if n  1"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 173
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "factorize",
                  "signature": "(value: Natural) => Map<Prime, Natural>",
                  "description": "Prime factorization of a number. Returns a map of prime factors to their exponents.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value  2"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 211
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Ratio",
            "type": "namespace",
            "signature": "export * as Ratio",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "ratio"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "ratio"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Ratio",
                  "signature": "type Ratio = {\n  readonly numerator: Int\n  readonly denominator: NonZero\n} & { [RatioBrand]: true }",
                  "description": "Ratio (rational number) - a number expressible as p/q where q  0.  Ratios provide exact arithmetic without floating-point errors, making them ideal for: - Financial calculations (no lost pennies) - Music theory (frequency ratios like 3:2 for perfect fifth) - Aspect ratios and proportions - Probability calculations - Any domain requiring exact fractional values",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 30
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Ratio",
                  "description": "Type predicate to check if value is a Ratio.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(numerator: Int, denominator: NonZero) => Ratio",
                  "description": "Construct a Ratio from numerator and denominator. Automatically simplifies to lowest terms and normalizes sign.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 79
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromWith",
                  "signature": "(denominator: NonZero) => (numerator: Int) => Ratio",
                  "description": "Create a function that constructs ratios with a fixed numerator. Useful for creating unit fractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 110
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromOn",
                  "signature": "(numerator: Int) => (denominator: NonZero) => Ratio",
                  "description": "Create a function that constructs ratios with a fixed denominator. Useful for working with common denominators.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 125
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromDecimal",
                  "signature": "(value: number, maxDenominator?: number) => Ratio",
                  "description": "Convert a decimal number to a Ratio with specified precision. Useful for converting floats to exact ratios.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 145
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "simplify",
                  "signature": "(ratio: Ratio) => Ratio",
                  "description": "Simplify a ratio to lowest terms. Note: from() already does this, but this is useful for ratios from other sources.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 202
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toDecimal",
                  "signature": "(ratio: Ratio) => number",
                  "description": "Convert ratio to decimal number. Note: This may lose precision for ratios like 1/3.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 219
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "add",
                  "signature": "(a: Ratio, b: Ratio) => Ratio",
                  "description": "Add two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 239
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": "(a: Ratio) => (b: Ratio) => Ratio",
                  "description": "Create a function that adds a specific ratio. Useful for repeated additions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 257
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": "(b: Ratio) => (a: Ratio) => Ratio",
                  "description": "Create a function that adds to a specific ratio. Useful for accumulating values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 271
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtract",
                  "signature": "(a: Ratio, b: Ratio) => Ratio",
                  "description": "Subtract two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 286
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subtractWith",
                  "signature": "(a: Ratio) => (b: Ratio) => Ratio",
                  "description": "Create a function that subtracts from a specific ratio. Useful for calculating remainders.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 304
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtractOn",
                  "signature": "(a: Ratio) => (b: Ratio) => Ratio",
                  "description": "Create a function that subtracts a specific ratio. Useful for repeated subtractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 318
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": "(a: Ratio, b: Ratio) => Ratio",
                  "description": "Multiply two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 337
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": "(a: Ratio) => (b: Ratio) => Ratio",
                  "description": "Create a function that multiplies by a specific ratio. Useful for scaling.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 355
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": "(b: Ratio) => (a: Ratio) => Ratio",
                  "description": "Create a function that multiplies a specific ratio. Useful for applying ratios to values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 369
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divide",
                  "signature": "(a: Ratio, b: Ratio) => Ratio",
                  "description": "Divide two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if b is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 387
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "divideWith",
                  "signature": "(a: Ratio) => (b: Ratio) => Ratio",
                  "description": "Create a function that divides from a specific ratio. Useful for finding proportions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 408
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divideOn",
                  "signature": "(a: Ratio) => (b: Ratio) => Ratio",
                  "description": "Create a function that divides by a specific ratio. Useful for repeated divisions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 422
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compare",
                  "signature": "(a: Ratio, b: Ratio) => 0 | 1 | -1",
                  "description": "Compare two ratios. Returns -1 if a  b, 0 if a = b, 1 if a  b.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 437
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compareOn",
                  "signature": "(a: Ratio) => (b: Ratio) => 0 | 1 | -1",
                  "description": "Create a function that compares against a specific ratio. Useful for filtering or sorting.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 459
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compareWith",
                  "signature": "(b: Ratio) => (a: Ratio) => 0 | 1 | -1",
                  "description": "Create a function that compares a specific ratio. Useful for finding where a ratio fits in a range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 473
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "reciprocal",
                  "signature": "(ratio: Ratio) => Ratio",
                  "description": "Get the reciprocal (inverse) of a ratio.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if ratio is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 487
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toMixedNumber",
                  "signature": "(ratio: Ratio) => { whole: Int; fraction: Ratio; }",
                  "description": "Convert ratio to mixed number representation. Returns whole part and fractional part.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 507
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Frac",
            "type": "namespace",
            "signature": "export * as Frac",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "frac"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "frac"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Frac",
                  "signature": "type Frac = Ratio & { [FracBrand]: true }",
                  "description": "Fraction (proper fraction) - a positive ratio where 0  numerator  denominator.  Fractions represent parts of a whole, always between 0 and 1 (exclusive). They're ideal for: - Probabilities (1/6 for dice roll) - Portions and percentages (3/4 of a pizza) - UI measurements (2/3 width) - Musical note durations (1/4 note, 1/8 note)",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 32
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Frac",
                  "description": "Type predicate to check if value is a proper fraction.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 48
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(numerator: Natural, denominator: Natural) => Frac",
                  "description": "Construct a Fraction from numerator and denominator. Both must be positive and numerator must be less than denominator.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if not a proper fraction"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 76
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromWith",
                  "signature": "(numerator: Natural) => (denominator: Natural) => Frac",
                  "description": "Create a function that constructs fractions with a fixed numerator. Useful for creating series of fractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 100
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromOn",
                  "signature": "(denominator: Natural) => (numerator: Natural) => Frac",
                  "description": "Create a function that constructs fractions with a fixed denominator. Useful for working with common denominators.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 115
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "tryFrom",
                  "signature": "(numerator: Natural, denominator: Natural) => Frac | null",
                  "description": "Try to construct a Fraction. Returns null if not a proper fraction.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 131
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromDecimal",
                  "signature": "(value: number, maxDenominator?: number) => Frac",
                  "description": "Convert a decimal to a fraction. The decimal must be between 0 and 1 (exclusive).",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not between 0 and 1"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 158
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toDecimal",
                  "signature": "(frac: Frac) => number",
                  "description": "Convert fraction to decimal.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 183
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toPercentage",
                  "signature": "(frac: Frac) => number",
                  "description": "Convert fraction to percentage.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 199
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "complement",
                  "signature": "(frac: Frac) => Frac",
                  "description": "Get the complement of a fraction (1 - fraction).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 218
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "add",
                  "signature": "(a: Frac, b: Frac) => Ratio",
                  "description": "Add two fractions. Note: The result might not be a fraction if the sum = 1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 244
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": "(a: Frac) => (b: Frac) => Ratio",
                  "description": "Create a function that adds to a specific fraction. Data-first pattern: fix the first argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 260
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": "(b: Frac) => (a: Frac) => Ratio",
                  "description": "Create a function that adds with a specific fraction. Data-second pattern: fix the second argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 274
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": "(a: Frac, b: Frac) => Frac",
                  "description": "Multiply two fractions. The result is always a fraction (product of two numbers  1 is  1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 294
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": "(a: Frac) => (b: Frac) => Frac",
                  "description": "Create a function that multiplies a specific fraction. Data-first pattern: fix the first argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 311
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": "(b: Frac) => (a: Frac) => Frac",
                  "description": "Create a function that multiplies with a specific fraction. Data-second pattern: fix the second argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 325
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compare",
                  "signature": "(a: Frac, b: Frac) => 0 | 1 | -1",
                  "description": "Compare two fractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 339
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compareOn",
                  "signature": "(a: Frac) => (b: Frac) => 0 | 1 | -1",
                  "description": "Create a function that compares a specific fraction. Data-first pattern: fix the first argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 355
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compareWith",
                  "signature": "(b: Frac) => (a: Frac) => 0 | 1 | -1",
                  "description": "Create a function that compares with a specific fraction. Data-second pattern: fix the second argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 369
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Complex",
            "type": "namespace",
            "signature": "export * as Complex",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "complex"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "complex"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Complex",
                  "signature": "type Complex = {\n  readonly real: number\n  readonly imaginary: number\n} & { [ComplexBrand]: true }",
                  "description": "Complex number - a number with both real and imaginary parts, written as a + bi.  The 'i' represents the imaginary unit, which is the square root of -1. Complex numbers extend regular numbers to solve problems that regular numbers can't, like finding the square root of negative numbers.  Common uses: - **Signal processing**: Analyzing sound waves and digital signals - **Electrical engineering**: Calculating power in AC circuits - **Physics**: Describing quantum states and wave behavior - **Computer graphics**: Rotating points and creating fractals - **Control systems**: Analyzing system stability",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 34
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is Complex",
                  "description": "Type predicate to check if value is a Complex number.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 52
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(real: number, imaginary?: number) => Complex",
                  "description": "Construct a Complex number from real and imaginary parts.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 83
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromWith",
                  "signature": "(real: number) => (imaginary?: number | undefined) => Complex",
                  "description": "Create a function that constructs complex numbers with a fixed real part. Useful for creating pure imaginary numbers or series.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromOn",
                  "signature": "(imaginary?: number | undefined) => (real: number) => Complex",
                  "description": "Create a function that constructs complex numbers with a fixed imaginary part. Useful for creating real numbers or series with constant imaginary component.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 122
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "real",
                  "signature": "(real: number) => Complex",
                  "description": "Create a real complex number (imaginary part = 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 135
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "imaginary",
                  "signature": "(imaginary: number) => Complex",
                  "description": "Create a pure imaginary complex number (real part = 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 148
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "I",
                  "signature": "Complex",
                  "description": "The imaginary unit i (0 + 1i). Satisfies i = -1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 158
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "ZERO",
                  "signature": "Complex",
                  "description": "Zero complex number (0 + 0i).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 163
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "ONE",
                  "signature": "Complex",
                  "description": "One complex number (1 + 0i).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 168
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "add",
                  "signature": "(a: Complex, b: Complex) => Complex",
                  "description": "Add two complex numbers together.  When adding complex numbers, you add the real parts together and the imaginary parts together. Formula: (a + bi) + (c + di) = (a + c) + (b + d)i",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 193
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": "(a: Complex) => (b: Complex) => Complex",
                  "description": "Create a function that adds its input to a specific complex number.  This is the data-first curried version where the input becomes the first parameter. Useful for operations where you want to add various numbers to a fixed base value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 217
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": "(b: Complex) => (a: Complex) => Complex",
                  "description": "Create a function that adds a specific complex number to other complex numbers.  This is the data-second curried version where the fixed value is added to various inputs. Useful when you want to add the same complex number to many different values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 242
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtract",
                  "signature": "(a: Complex, b: Complex) => Complex",
                  "description": "Subtract two complex numbers. (a + bi) - (c + di) = (a - c) + (b - d)i",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 256
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subtractWith",
                  "signature": "(a: Complex) => (b: Complex) => Complex",
                  "description": "Create a function that subtracts from a specific complex number.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 270
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtractOn",
                  "signature": "(a: Complex) => (b: Complex) => Complex",
                  "description": "Create a function that subtracts from a specific complex number.  This is the data-first curried version where the input becomes the subtrahend. Useful for operations where you want to subtract various numbers from a fixed value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 286
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": "(a: Complex, b: Complex) => Complex",
                  "description": "Multiply two complex numbers. (a + bi)(c + di) = (ac - bd) + (ad + bc)i",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 306
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": "(a: Complex) => (b: Complex) => Complex",
                  "description": "Create a function that multiplies a specific complex number by others.  This is the data-first curried version where the input becomes the second factor. Useful for operations where you want to multiply a fixed base by various values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 332
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": "(b: Complex) => (a: Complex) => Complex",
                  "description": "Create a function that multiplies with a specific complex number.  This is the data-second curried version where the fixed multiplier is applied to various inputs. Useful when you want to scale or rotate many complex numbers by the same amount. In 2D graphics, multiplying by a complex number rotates and scales points around the origin.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 359
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divide",
                  "signature": "(a: Complex, b: Complex) => Complex",
                  "description": "Divide two complex numbers. (a + bi) / (c + di) = [(a + bi)(c - di)] / (c + d)",
                  "examples": [],
                  "tags": {
                    "throws": "Error if divisor is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 375
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "divideWith",
                  "signature": "(a: Complex) => (b: Complex) => Complex",
                  "description": "Create a function that divides from a specific complex number.  This creates a function where the provided complex number is the dividend (numerator) and the function's input becomes the divisor (denominator).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 408
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divideOn",
                  "signature": "(a: Complex) => (b: Complex) => Complex",
                  "description": "Create a function that divides a specific complex number by others.  This is the data-first curried version where the input becomes the divisor. Useful for operations where you want to divide a fixed dividend by various values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 430
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "conjugate",
                  "signature": "(z: Complex) => Complex",
                  "description": "Get the complex conjugate by flipping the sign of the imaginary part.  The complex conjugate is useful for: - Converting division into multiplication (z/w = z*w/|w|) - Finding the magnitude squared (z*z = |z|) - Extracting real parts from complex expressions  If z = a + bi, then z* = a - bi",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 462
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "abs",
                  "signature": "(z: Complex) => number",
                  "description": "Get the absolute value (magnitude/modulus) of a complex number.  The magnitude represents the distance from the origin to the point in the complex plane. This is always a non-negative real number, calculated using the Pythagorean theorem.  Formula: |a + bi| = (a + b)",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 496
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "arg",
                  "signature": "(z: Complex) => number",
                  "description": "Get the argument (phase/angle) of a complex number in radians.  The argument is the angle from the positive real axis to the line connecting the origin to the complex number, measured counterclockwise. This is essential for polar form representation and rotation operations.  Formula: arg(a + bi) = atan2(b, a)",
                  "examples": [],
                  "tags": {
                    "throws": "Error if z is zero (argument is undefined for zero)"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 534
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toPolar",
                  "signature": "(z: Complex) => { magnitude: number; angle: number; }",
                  "description": "Convert complex number to polar form (magnitude, angle).  Polar form represents a complex number as r*e^(i) where r is the magnitude and  is the angle. This form is especially useful for multiplication and power operations, as it turns them into simple arithmetic on the components.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 566
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromPolar",
                  "signature": "(magnitude: number, angle: number) => Complex",
                  "description": "Create complex number from polar form (magnitude, angle).  This converts from polar coordinates (r, ) to rectangular coordinates (a, bi) using Euler's formula: r*e^(i) = r(cos  + i sin )",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 600
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "power",
                  "signature": "(z: Complex, n: number) => Complex",
                  "description": "Raise a complex number to a real power using De Moivre's theorem.  This uses the polar form to compute powers efficiently: If z = r*e^(i), then z^n = r^n * e^(in) This avoids the complexity of repeated multiplication for integer powers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 646
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "powerOn",
                  "signature": "(z: Complex) => (n: number) => Complex",
                  "description": "Create a function that raises a specific complex number to various powers.  This is the data-first curried version where the input becomes the exponent. Useful for operations where you want to raise a fixed base to different powers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 684
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "powerWith",
                  "signature": "(n: number) => (z: Complex) => Complex",
                  "description": "Create a function that raises complex numbers to a specific power.  This is the data-second curried version where the fixed exponent is applied to various bases. Useful for applying the same power operation to multiple complex numbers, such as when processing arrays or in mathematical transformations.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 719
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "sqrt",
                  "signature": "(z: Complex) => Complex",
                  "description": "Get the square root of a complex number.  Returns the principal (primary) square root using the power function. The principal root is the one with argument in the range (-/2, /2]. Note that every non-zero complex number has exactly two square roots.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 749
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "exp",
                  "signature": "(z: Complex) => Complex",
                  "description": "Natural exponential function for complex numbers.  Uses Euler's formula: e^(a + bi) = e^a * (cos b + i sin b) This fundamental function connects exponentials with trigonometry and is essential for signal processing, quantum mechanics, and many areas of mathematics.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 785
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "log",
                  "signature": "(z: Complex) => Complex",
                  "description": "Natural logarithm for complex numbers.  Uses the formula: log(z) = log|z| + i*arg(z) This gives the principal branch of the complex logarithm. Note that complex logarithms are multi-valued; this returns the principal value.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if z is zero (logarithm undefined)"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 823
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "equals",
                  "signature": "(a: Complex, b: Complex, tolerance?: number) => boolean",
                  "description": "Check if two complex numbers are equal within a tolerance.  Due to floating-point arithmetic limitations, exact equality is rarely achievable for computed complex numbers. This function allows for small differences that arise from numerical precision issues.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 865
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "equalsOn",
                  "signature": "(a: Complex) => (b: Complex) => (tolerance?: number | undefined) => boolean",
                  "description": "Create a function that checks if its input equals a specific complex number.  This is the data-first curried version where the reference value is the first parameter. Useful for checking if various numbers equal a fixed reference value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 898
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "equalsWith",
                  "signature": "(b: Complex) => (a: Complex) => (tolerance?: number | undefined) => boolean",
                  "description": "Create a function that checks equality with a specific complex number.  This is the data-second curried version where the comparison value is fixed. Useful for filtering, validation, or when you need to check many numbers against the same reference value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 932
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "toString",
                  "signature": "(z: Complex, precision?: number) => string",
                  "description": "Convert complex number to string representation.  Creates a human-readable string in standard mathematical notation (a + bi). Handles special cases like pure real numbers, pure imaginary numbers, and the imaginary unit to provide clean, readable output.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 973
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "BigInteger",
            "type": "namespace",
            "signature": "export * as BigInteger",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "big-integer"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "big-integer"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "BigInteger",
                  "signature": "type BigInteger = bigint & { [BigIntegerBrand]: true }",
                  "description": "BigInteger - arbitrary precision integer with branded type safety.  Provides exact arithmetic for integers of any size, without the limitations of JavaScript's Number type (which loses precision beyond 2^53-1).  Common uses: - **Cryptography**: Large prime numbers, key generation, modular arithmetic - **Financial systems**: Precise monetary calculations without rounding errors - **Mathematical computing**: Factorials, combinatorics, number theory - **Blockchain**: Transaction values, block numbers, hash computations - **Scientific computing**: Large dataset indexing, ID generation",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 34
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": "(value: unknown) => value is BigInteger",
                  "description": "Type predicate to check if value is a BigInteger.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 48
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": "(value: string | number | bigint) => BigInteger",
                  "description": "Construct a BigInteger from various input types.  Accepts numbers, strings, and existing bigints, providing a safe way to create arbitrary precision integers from different sources.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 73
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "ZERO",
                  "signature": "BigInteger",
                  "description": "BigInteger constants for common values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 84
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "ONE",
                  "signature": "BigInteger",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 85
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "TWO",
                  "signature": "BigInteger",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 86
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "add",
                  "signature": "(a: BigInteger, b: BigInteger) => BigInteger",
                  "description": "Add two BigIntegers together.  Performs exact addition without precision loss, regardless of the size of the numbers involved.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 108
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                  "description": "Create a function that operates on a specific BigInteger by adding to it. Data-first pattern: the fixed value is the first parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 129
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                  "description": "Create a function that adds with a specific BigInteger value. Data-second pattern: the fixed value is the second parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 147
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtract",
                  "signature": "(a: BigInteger, b: BigInteger) => BigInteger",
                  "description": "Subtract two BigIntegers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 161
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subtractWith",
                  "signature": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                  "description": "Create a function that subtracts with a specific BigInteger. Data-second pattern: the fixed value is the second parameter (subtrahend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 177
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtractOn",
                  "signature": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                  "description": "Create a function that operates on a specific BigInteger by subtracting from it. Data-first pattern: the fixed value is the first parameter (minuend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 191
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": "(a: BigInteger, b: BigInteger) => BigInteger",
                  "description": "Multiply two BigIntegers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 210
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                  "description": "Create a function that operates on a specific BigInteger by multiplying it. Data-first pattern: the fixed value is the first parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 227
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                  "description": "Create a function that multiplies with a specific BigInteger. Data-second pattern: the fixed value is the second parameter (multiplier).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 244
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divide",
                  "signature": "(a: BigInteger, b: BigInteger) => BigInteger",
                  "description": "Divide two BigIntegers using integer division (truncates toward zero).",
                  "examples": [],
                  "tags": {
                    "throws": "Error if divisor is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 262
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "divideOn",
                  "signature": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                  "description": "Create a function that operates on a specific BigInteger by dividing it. Data-first pattern: the fixed value is the first parameter (dividend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 281
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divideWith",
                  "signature": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                  "description": "Create a function that divides by a specific BigInteger. Data-second pattern: the fixed value is the second parameter (divisor).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 298
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "remainder",
                  "signature": "(a: BigInteger, b: BigInteger) => BigInteger",
                  "description": "Get the remainder of BigInteger division.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if divisor is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 315
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "remainderOn",
                  "signature": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                  "description": "Create a function that operates on a specific BigInteger to get its remainder. Data-first pattern: the fixed value is the first parameter (dividend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 335
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "remainderWith",
                  "signature": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                  "description": "Create a function that gets remainder with a specific divisor. Data-second pattern: the fixed value is the second parameter (divisor).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 351
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "power",
                  "signature": "(base: BigInteger, exponent: BigInteger) => BigInteger",
                  "description": "Raise a BigInteger to a power.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if exponent is negative"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 368
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "powerOn",
                  "signature": "(base: BigInteger) => (exponent: BigInteger) => BigInteger",
                  "description": "Create a function that operates on a specific BigInteger base by raising it to powers. Data-first pattern: the fixed value is the first parameter (base).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 388
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "powerWith",
                  "signature": "(exponent: BigInteger) => (base: BigInteger) => BigInteger",
                  "description": "Create a function that raises to a specific power. Data-second pattern: the fixed value is the second parameter (exponent).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 406
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "abs",
                  "signature": "(value: BigInteger) => BigInteger",
                  "description": "Get the absolute value of a BigInteger.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 419
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compare",
                  "signature": "(a: BigInteger, b: BigInteger) => 0 | 1 | -1",
                  "description": "Compare two BigIntegers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 437
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compareOn",
                  "signature": "(a: BigInteger) => (b: BigInteger) => 0 | 1 | -1",
                  "description": "Create a function that operates on a specific BigInteger by comparing it. Data-first pattern: the fixed value is the first parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 456
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compareWith",
                  "signature": "(b: BigInteger) => (a: BigInteger) => 0 | 1 | -1",
                  "description": "Create a function that compares with a specific BigInteger. Data-second pattern: the fixed value is the second parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 474
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "isEven",
                  "signature": "(value: BigInteger) => boolean",
                  "description": "Check if a BigInteger is even.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 487
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isOdd",
                  "signature": "(value: BigInteger) => boolean",
                  "description": "Check if a BigInteger is odd.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 502
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isPositive",
                  "signature": "(value: BigInteger) => boolean",
                  "description": "Check if a BigInteger is positive ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 517
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isNegative",
                  "signature": "(value: BigInteger) => boolean",
                  "description": "Check if a BigInteger is negative ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 532
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isZero",
                  "signature": "(value: BigInteger) => boolean",
                  "description": "Check if a BigInteger is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 546
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toNumber",
                  "signature": "(value: BigInteger) => number",
                  "description": "Convert BigInteger to regular number.  WARNING: May lose precision if the BigInteger is larger than Number.MAX_SAFE_INTEGER.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if the BigInteger is too large for safe conversion"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 564
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toString",
                  "signature": "(value: BigInteger, radix?: number) => string",
                  "description": "Convert BigInteger to string representation.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 588
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Arb",
            "signature": "Arb<number>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arb",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 34
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Eq",
            "signature": "Eq<number>",
            "description": "Eq trait implementation for numbers.  Provides number equality comparison using strict equality (===). Handles special cases like NaN, which is never equal to itself.",
            "examples": [
              {
                "code": "import { Num } from '@wollybeard/kit'\n\nNum.Eq.is(42, 42)           // true\nNum.Eq.is(3.14, 3.14)       // true\nNum.Eq.is(0, -0)            // true (positive and negative zero are equal)\nNum.Eq.is(NaN, NaN)         // false (NaN is never equal to itself)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 21
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<number>",
            "description": "Type trait implementation for numbers.  Provides type checking for number values using typeof.",
            "examples": [
              {
                "code": "import { Num } from '@wollybeard/kit'\n\nNum.Type.is(42)            // true\nNum.Type.is(3.14)          // true\nNum.Type.is(NaN)           // true (NaN is a number)\nNum.Type.is('42')          // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "add",
            "signature": "(a: number, b: number) => number",
            "description": "Add two numbers together.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "addWith",
            "signature": "(a: number) => (b: number) => number",
            "description": "Create a function that adds a specific number to any other number. This is useful when you want to add the same number multiple times.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 48
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "subtract",
            "signature": "(a: number, b: number) => number",
            "description": "Subtract one number from another. Takes the second number away from the first number.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "subtractWith",
            "signature": "(a: number) => (b: number) => number",
            "description": "Create a function that subtracts other numbers from a specific number. This is useful when you have a starting value and want to subtract various amounts from it.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 88
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "multiply",
            "signature": "(a: number, b: number) => number",
            "description": "Multiply two numbers together. This gives you the result of adding a number to itself b times.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 106
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "multiplyWith",
            "signature": "(b: number) => (a: number) => number",
            "description": "Create a function that multiplies any number by a specific factor. This is useful for scaling values or converting units.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 132
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "divide",
            "signature": "(dividend: number, divisor: NonZero) => number",
            "description": "Divide one number by another. This splits the first number into equal parts based on the second number. The divisor must be non-zero.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 151
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "divideWith",
            "signature": "(divisor: NonZero) => (dividend: number) => number",
            "description": "Create a function that divides any number by a specific divisor. This is useful for splitting values into fixed portions.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 177
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "power",
            "signature": "(base: number, exponent: number) => number",
            "description": "Raise a number to a power (exponentiation). This multiplies the base number by itself 'exponent' times. For best results, use finite numbers to avoid NaN/Infinity.",
            "examples": [],
            "category": "Exponentiation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 204
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "powerWith",
            "signature": "(exponent: number) => (base: number) => number",
            "description": "Create a function that raises any number to a specific power. This is useful for repeated exponentiations.",
            "examples": [],
            "category": "Exponentiation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 230
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "round",
            "signature": "(value: number, precision?: number) => number",
            "description": "Round a number to the nearest integer or to a specific number of decimal places. Rounding follows standard rules: 0.5 and above rounds up, below 0.5 rounds down.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 258
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "roundWith",
            "signature": "(precision?: number | undefined) => (value: number) => number",
            "description": "Create a function that rounds numbers to a specific number of decimal places. This is useful when you need consistent precision across multiple values.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 286
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Floor",
            "signature": "type Floor<_T extends number> = Int",
            "description": "Type-level floor transformation. Floor always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 292
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "floor",
            "signature": "<T extends Finite>(value: T) => Int",
            "description": "Round a number down to the nearest integer. This always rounds towards negative infinity, removing any decimal part. The input must be finite to ensure a valid integer result.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 319
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Ceil",
            "signature": "type Ceil<_T extends number> = Int",
            "description": "Type-level ceil transformation. Ceil always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 327
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ceil",
            "signature": "<T extends Finite>(value: T) => Int",
            "description": "Round a number up to the nearest integer. This always rounds towards positive infinity. The input must be finite to ensure a valid integer result.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 355
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Trunc",
            "signature": "type Trunc<_T extends number> = Int",
            "description": "Type-level trunc transformation. Trunc always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 363
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "trunc",
            "signature": "<T extends Finite>(value: T) => Int",
            "description": "Remove the decimal part of a number (truncate). This simply cuts off the decimal portion, always rounding towards zero. The input must be finite to ensure a valid integer result.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 390
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sqrt",
            "signature": "type Sqrt<T extends number> = T extends Positive ? Positive\n  : T extends NonNegative ? NonNegative\n  : number",
            "description": "Type-level sqrt transformation. Square root of non-negative returns non-negative. Square root of positive returns positive (except for 0).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 399
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sqrt",
            "signature": "<T extends NonNegative>(value: T) => Sqrt<T>",
            "description": "Calculate the square root of a non-negative number. The square root is a number that, when multiplied by itself, gives the original number. For type safety, this requires a non-negative input to avoid NaN results.",
            "examples": [],
            "category": "Roots",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 429
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "cbrt",
            "signature": "(value: number) => number",
            "description": "Calculate the cube root of a number. The cube root is a number that, when multiplied by itself three times, gives the original number.",
            "examples": [],
            "category": "Roots",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 451
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log",
            "signature": "(value: Positive) => number",
            "description": "Calculate the natural logarithm (base e) of a number. The logarithm tells you what power you need to raise e (2.718) to get your number. It's the inverse operation of exponential (e^x).",
            "examples": [],
            "category": "Logarithms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 475
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log10",
            "signature": "(value: Positive) => number",
            "description": "Calculate the base-10 logarithm of a number. This tells you what power you need to raise 10 to get your number. It's commonly used for measuring orders of magnitude.",
            "examples": [],
            "category": "Logarithms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 502
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log2",
            "signature": "(value: Positive) => number",
            "description": "Calculate the base-2 logarithm of a number. This tells you what power you need to raise 2 to get your number. It's commonly used in computer science for binary operations.",
            "examples": [],
            "category": "Logarithms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 530
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sin",
            "signature": "type Sin<_T extends number> = InRange<-1, 1>",
            "description": "Type-level sine transformation. Sine always returns a value in the range [-1, 1].",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 538
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sin",
            "signature": "<T extends Finite>(radians: T) => Sin<_T>",
            "description": "Calculate the sine of an angle. Sine is a trigonometric function that represents the ratio of the opposite side to the hypotenuse in a right triangle. The angle must be in radians and finite.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 565
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Cos",
            "signature": "type Cos<_T extends number> = InRange<-1, 1>",
            "description": "Type-level cosine transformation. Cosine always returns a value in the range [-1, 1].",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 573
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "cos",
            "signature": "<T extends Finite>(radians: T) => Cos<_T>",
            "description": "Calculate the cosine of an angle. Cosine is a trigonometric function that represents the ratio of the adjacent side to the hypotenuse in a right triangle. The angle must be in radians and finite.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 600
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tan",
            "signature": "(radians: Finite) => number",
            "description": "Calculate the tangent of an angle. Tangent is the ratio of sine to cosine, or the ratio of the opposite side to the adjacent side in a right triangle. The angle must be in radians and finite.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 628
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "asin",
            "signature": "(value: InRange<-1, 1>) => Radians",
            "description": "Calculate the arcsine (inverse sine) of a value. This gives you the angle whose sine is the input value. The input must be in the range [-1, 1] to get a valid result. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 658
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "acos",
            "signature": "(value: InRange<-1, 1>) => Radians",
            "description": "Calculate the arccosine (inverse cosine) of a value. This gives you the angle whose cosine is the input value. The input must be in the range [-1, 1] to get a valid result. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 689
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan",
            "signature": "(value: Finite) => Radians",
            "description": "Calculate the arctangent (inverse tangent) of a value. This gives you the angle whose tangent is the input value. The input must be finite to get a meaningful angle. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 718
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan2",
            "signature": "(y: Finite, x: Finite) => Radians",
            "description": "Calculate the angle from the positive x-axis to a point (x, y). This is like atan(y/x) but handles all quadrants correctly and avoids division by zero. Both coordinates must be finite to get a meaningful angle. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 749
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan2With",
            "signature": "(y: Finite) => (x: Finite) => Radians",
            "description": "Create a function that calculates atan2 with a fixed y value. Useful for repeated calculations with the same y offset.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 762
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "degToRad",
            "signature": "(degrees: Degrees) => Radians",
            "description": "Convert degrees to radians. Most JavaScript math functions expect angles in radians, but humans often think in degrees. This converts from the familiar degree system (0-360) to radians (0-2).",
            "examples": [],
            "category": "Angle Conversion",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 790
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "radToDeg",
            "signature": "(radians: Radians) => Degrees",
            "description": "Convert radians to degrees. Math functions return angles in radians, but you might want to display them in degrees. This converts from radians (0-2) to the familiar degree system (0-360).",
            "examples": [],
            "category": "Angle Conversion",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 820
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Min",
            "signature": "type Min<A extends number, B extends number> = A | B",
            "description": "Type-level min transformation. Returns the union of both input types (the more general type).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 828
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "min",
            "signature": "<A extends number, B extends number>(a: A, b: B) => Min<A, B>",
            "description": "Find the smaller of two numbers. Returns whichever number is less.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 853
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "minWith",
            "signature": "(a: number) => (b: number) => number",
            "description": "Create a function that finds the minimum with a fixed first value. Useful for clamping or limiting values.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 866
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Max",
            "signature": "type Max<A extends number, B extends number> = A | B",
            "description": "Type-level max transformation. Returns the union of both input types (the more general type).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 872
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "max",
            "signature": "<A extends number, B extends number>(a: A, b: B) => Max<A, B>",
            "description": "Find the larger of two numbers. Returns whichever number is greater.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 897
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "maxWith",
            "signature": "(a: number) => (b: number) => number",
            "description": "Create a function that finds the maximum with a fixed first value. Useful for ensuring minimum values.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 910
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "gcd",
            "signature": "(a: Int, b: Int) => Natural",
            "description": "Find the greatest common divisor (GCD) of two integers. The GCD is the largest positive integer that divides both numbers evenly. Also known as the greatest common factor (GCF).",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 941
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "gcdWith",
            "signature": "(a: Int) => (b: Int) => Natural",
            "description": "Create a function that finds the GCD with a fixed first value. Useful for finding common factors with a specific number.",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 971
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "lcm",
            "signature": "(a: Int, b: Int) => Whole",
            "description": "Find the least common multiple (LCM) of two integers. The LCM is the smallest positive integer that is divisible by both numbers. Returns 0 if either input is 0.",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1002
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lcmWith",
            "signature": "(a: Int) => (b: Int) => Whole",
            "description": "Create a function that finds the LCM with a fixed first value. Useful for finding common multiples with a specific number.",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1020
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "PI",
            "signature": "number",
            "description": "The mathematical constant pi (). Pi is the ratio of a circle's circumference to its diameter. Approximately 3.14159...",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1039
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "E",
            "signature": "number",
            "description": "The mathematical constant e (Euler's number). The base of natural logarithms, approximately 2.71828... It appears naturally in exponential growth and compound interest.",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1059
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "TAU",
            "signature": "number",
            "description": "The mathematical constant tau (). Tau is 2, representing a full circle in radians. Some mathematicians prefer tau over pi for circular calculations. Approximately 6.28318...",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1081
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "GOLDEN_RATIO",
            "signature": "number",
            "description": "The golden ratio (, phi). A special number appearing in nature, art, and architecture. When a line is divided so that the whole length divided by the long part equals the long part divided by the short part. Approximately 1.61803...",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1105
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "is",
            "signature": "(value: unknown) => value is number",
            "description": "Type predicate to check if value is a number. Excludes NaN by default.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 16
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isNaN",
            "signature": "(value: unknown) => value is number",
            "description": "Type predicate to check if value is NaN.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 23
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Abs",
            "signature": "type Abs<T extends number> = T extends Positive ? Positive\n  : T extends Negative ? Positive\n  : T extends NonPositive ? NonNegative\n  : T extends Zero ? Zero\n  : NonNegative",
            "description": "Type-level absolute value transformation. Maps number types to their absolute value types.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "abs",
            "signature": "<T extends number>(value: T) => Abs<T>",
            "description": "Get absolute value. Returns the non-negative magnitude of a number.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sign",
            "signature": "type Sign<T extends number> = T extends Positive ? 1\n  : T extends Negative ? -1\n  : T extends Zero ? 0\n  : -1 | 0 | 1",
            "description": "Type-level sign transformation. Maps number types to their sign (-1, 0, 1).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 58
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sign",
            "signature": "<T extends number>(value: T) => Sign<T>",
            "description": "Get sign of number (-1, 0, 1). Returns -1 for negative numbers, 0 for zero, and 1 for positive numbers.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 78
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "inc",
            "signature": "(value: number) => number",
            "description": "Increment by 1.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 85
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "dec",
            "signature": "(value: number) => number",
            "description": "Decrement by 1.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 92
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Mod",
            "signature": "type Mod<_T extends number, _U extends NonZero> = NonNegative",
            "description": "Type-level modulo transformation. Modulo always returns a non-negative result.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 100
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mod",
            "signature": "<T extends number, U extends NonZero>(dividend: T, divisor: U) => NonNegative",
            "description": "Modulo operation that always returns positive result. Unlike the % operator, this always returns a non-negative result. The divisor must be non-zero for a valid result.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 123
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "modOn",
            "signature": "<T extends number>(dividend: T) => <U extends NonZero>(divisor: U) => NonNegative",
            "description": "Create a function that calculates modulo with a fixed dividend.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 141
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "modWith",
            "signature": "<U extends NonZero>(divisor: U) => <T extends number>(dividend: T) => NonNegative",
            "description": "Create a function that calculates modulo with a fixed divisor. Useful for wrapping values in a fixed range.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 162
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "NumberLiteral",
            "signature": "type NumberLiteral = number",
            "description": "Number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 169
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PlusOne",
            "signature": "type PlusOne<$n extends NumberLiteral> = [\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n  20,\n  21,\n][\n  $n\n]",
            "description": "Add one to a number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 174
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MinusOne",
            "signature": "type MinusOne<$n extends NumberLiteral> = [\n  -1,\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n][\n  $n\n]",
            "description": "Subtract one from a number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 203
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RangeOptions",
            "signature": "interface RangeOptions {\n  /**\n   * The step between each number in the range.\n   * @default 1\n   */\n  step?: number\n  /**\n   * Whether to include the end value in the range.\n   * @default false\n   */\n  inclusive?: boolean\n}",
            "description": "Options for generating numeric ranges.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "range",
            "signature": "(start: number, end: number, options?: RangeOptions | undefined) => number[]",
            "description": "Generate an array of numbers in a range. By default, the range is exclusive of the end value and uses a step of 1.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeFrom",
            "signature": "(start: number) => (end: number, options?: RangeOptions | undefined) => number[]",
            "description": "Create a function that generates a range from a specific start value. Useful for creating ranges with a fixed starting point.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 96
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeTo",
            "signature": "(end: number) => (start: number, options?: RangeOptions | undefined) => number[]",
            "description": "Create a function that generates a range to a specific end value. Useful for creating ranges with a fixed ending point.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 117
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeStep",
            "signature": "(start: number, end: number, step: number) => number[]",
            "description": "Generate a range with a specific step. A convenience function that makes the step explicit.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 136
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeStepWith",
            "signature": "(step: number) => (start: number, end: number) => number[]",
            "description": "Create a function that generates ranges with a specific step. Useful for creating consistent stepped ranges.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 157
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeInclusive",
            "signature": "(start: number, end: number) => number[]",
            "description": "Create an inclusive range. A convenience function that always includes the end value.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 175
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "times",
            "signature": "<T>(n: number, fn: (index: number) => T) => T[]",
            "description": "Execute a function n times and collect the results. The function receives the current index (0-based) as its argument.",
            "examples": [],
            "category": "Iteration",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 200
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "timesWith",
            "signature": "<T>(fn: (index: number) => T) => (n: number) => T[]",
            "description": "Create a function that executes another function n times. Useful for partial application of the times function.",
            "examples": [],
            "category": "Iteration",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 229
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lerp",
            "signature": "(start: number, end: number, t: number) => number",
            "description": "Linear interpolation between two values. Calculates a value between start and end based on the interpolation factor t.",
            "examples": [],
            "category": "Interpolation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 259
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lerpBetween",
            "signature": "(start: number, end: number) => (t: number) => number",
            "description": "Create a function that linearly interpolates between two fixed values. Useful for creating reusable interpolation functions.",
            "examples": [],
            "category": "Interpolation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 309
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mapRange",
            "signature": "(value: number, fromMin: number, fromMax: number, toMin: number, toMax: number) => number",
            "description": "Map a value from one range to another. Converts a value from the source range [fromMin, fromMax] to the target range [toMin, toMax].",
            "examples": [],
            "category": "Range Mapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 339
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mapRangeFrom",
            "signature": "(fromMin: number, fromMax: number, toMin: number, toMax: number) => (value: number) => number",
            "description": "Create a function that maps values from one range to another. Useful for creating reusable range mapping functions.",
            "examples": [],
            "category": "Range Mapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 414
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "sequence",
            "signature": "(n: number) => number[]",
            "description": "Generate a sequence of integers starting from 0. A convenience function equivalent to range(0, n).",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 440
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrap",
            "signature": "(value: number, min: number, max: number) => number",
            "description": "Constrain a value to be within a range, wrapping around if necessary. Unlike clamp which stops at boundaries, wrap continues from the other side.",
            "examples": [],
            "category": "Range Operations",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 471
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrapWithin",
            "signature": "(min: number, max: number) => (value: number) => number",
            "description": "Create a function that wraps values within a specific range.",
            "examples": [],
            "category": "Range Operations",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 534
            },
            "_tag": "value",
            "type": "function"
          }
        ],
        "category": "Core Data Structures"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./obj",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "obj"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Object utilities for working with plain JavaScript objects.  Provides type-safe utilities for object operations including property access, manipulation, merging, filtering, and transformations. Supports both value-level and type-level operations with strong type inference.",
        "exports": [
          {
            "name": "Eq",
            "signature": "Eq<object>",
            "description": "Eq trait implementation for objects.  Provides deep structural equality for objects by recursively comparing properties using their appropriate Eq implementations.",
            "examples": [
              {
                "code": "import { Obj } from '@wollybeard/kit'\n\n// Basic object equality\nObj.Eq.is({ a: 1, b: 2 }, { a: 1, b: 2 }) // true\nObj.Eq.is({ a: 1, b: 2 }, { a: 1, b: 3 }) // false\nObj.Eq.is({ a: 1 }, { a: 1, b: 2 }) // false (different keys)\n\n// Nested objects\nObj.Eq.is(\n  { a: 1, b: { c: 2 } },\n  { a: 1, b: { c: 2 } }\n) // true\n\n// Mixed types in properties\nObj.Eq.is(\n  { a: 1, b: 'hello', c: true },\n  { a: 1, b: 'hello', c: true }\n) // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<object>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 5
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "pick",
            "signature": "<T extends object, K extends keyof T>(obj: T, keys: readonly K[]) => Pick<T, K>",
            "description": "Create a new object with only the specified properties.",
            "examples": [
              {
                "code": "const user = { name: 'Alice', age: 30, email: 'alice@example.com' }\nconst publicInfo = pick(user, ['name', 'email'])\n// Result: { name: 'Alice', email: 'alice@example.com' }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe property selection\ninterface User {\n  id: number\n  name: string\n  password: string\n  email: string\n}\n\nfunction getPublicUser(user: User) {\n  return pick(user, ['id', 'name', 'email'])\n  // Type: Pick<User, 'id' | 'name' | 'email'>\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 45
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "omit",
            "signature": "<T extends object, K extends keyof T>(obj: T, keys: readonly K[]) => Omit<T, K>",
            "description": "Create a new object with the specified properties removed.",
            "examples": [
              {
                "code": "const user = { name: 'Alice', age: 30, password: 'secret' }\nconst safeUser = omit(user, ['password'])\n// Result: { name: 'Alice', age: 30 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Remove sensitive fields\ninterface User {\n  id: number\n  name: string\n  password: string\n  apiKey: string\n}\n\nfunction sanitizeUser(user: User) {\n  return omit(user, ['password', 'apiKey'])\n  // Type: Omit<User, 'password' | 'apiKey'>\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 84
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "policyFilter",
            "signature": "<$Object extends object, $Key extends Keyof<$Object>, $Mode extends \"allow\" | \"deny\">(mode: $Mode, obj: $Object, keys: readonly $Key[]) => PolicyFilter<$Object, $Key, $Mode>",
            "description": "Filter object properties based on a policy mode and set of keys.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2, c: 3 }\n\n// Allow mode: keep only 'a' and 'c'\npolicyFilter('allow', obj, ['a', 'c']) // { a: 1, c: 3 }\n\n// Deny mode: remove 'a' and 'c'\npolicyFilter('deny', obj, ['a', 'c']) // { b: 2 }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 112
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "filter",
            "signature": "<$Object extends object>(obj: $Object, predicate: (key: keyof $Object, value: $Object[keyof $Object], obj: $Object) => boolean) => Partial<$Object>",
            "description": "Filter an object using a predicate function.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2, c: 3 }\nfilter(obj, (k, v) => v > 1) // { b: 2, c: 3 }\nfilter(obj, k => k !== 'b') // { a: 1, c: 3 }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 157
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "partition",
            "signature": "<$Object extends object, $Key extends keyof $Object>(obj: $Object, pickedKeys: readonly $Key[]) => { omitted: Omit<$Object, $Key>; picked: Pick<$Object, $Key>; }",
            "description": "Partition an object into picked and omitted parts.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2, c: 3 }\nconst { picked, omitted } = partition(obj, ['a', 'c'])\n// picked: { a: 1, c: 3 }\n// omitted: { b: 2 }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 187
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "pickMatching",
            "signature": "<T extends object>(obj: T, predicate: (key: string) => boolean) => Partial<T>",
            "description": "Filter object properties by key pattern matching. Useful for extracting properties that match a pattern like data attributes.",
            "examples": [
              {
                "code": "const props = {\n  'data-type': 'button',\n  'data-current': true,\n  onClick: fn,\n  className: 'btn'\n}\nconst dataAttrs = pickMatching(props, key => key.startsWith('data-'))\n// Result: { 'data-type': 'button', 'data-current': true }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 226
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Keyof",
            "signature": "type Keyof<$Object extends object> = object extends $Object ? PropertyKey : (keyof $Object)",
            "description": "Like keyof but returns PropertyKey for object type. Helper type for generic object key operations.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 255
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PolicyFilter",
            "signature": "type PolicyFilter<\n  $Object extends object,\n  $Key extends Keyof<$Object>,\n  $Mode extends 'allow' | 'deny',\n> = $Mode extends 'allow'\n      ? Pick<$Object, Extract<$Key, keyof $Object>>\n      : Omit<$Object, Extract<$Key, keyof $Object>>",
            "description": "Filter object properties based on a policy mode and set of keys.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; email: string; password: string }\n// Allow mode: keep only specified keys\ntype PublicUser = PolicyFilter<User, 'id' | 'name', 'allow'>\n// Result: { id: number; name: string }\n\n// Deny mode: remove specified keys\ntype SafeUser = PolicyFilter<User, 'password', 'deny'>\n// Result: { id: number; name: string; email: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 275
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickWhereValueExtends",
            "signature": "type PickWhereValueExtends<$Obj extends object, $Constraint> = {\n  [k in keyof $Obj as $Obj[k] extends $Constraint ? k : never]: $Obj[k]\n}",
            "description": "Pick properties from an object where the values extend a given constraint.",
            "examples": [
              {
                "code": "type User = { name: string; age: number; isActive: boolean; flag: boolean }\ntype BooleanProps = PickWhereValueExtends<User, boolean>\n// Result: { isActive: boolean; flag: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 295
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "SuffixKeyNames",
            "signature": "type SuffixKeyNames<$Suffix extends string, $Object extends object> = {\n  [k in keyof $Object as k extends string ? `${k}${$Suffix}` : k]: $Object[k]\n}",
            "description": "Add a suffix to all property names in an object.",
            "examples": [
              {
                "code": "type T = SuffixKeyNames<'_old', { a: string; b: number }>\n// { a_old: string; b_old: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 310
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OmitKeysWithPrefix",
            "signature": "type OmitKeysWithPrefix<$Object extends object, $Prefix extends string> = {\n  [k in keyof $Object as k extends `${$Prefix}${string}` ? never : k]: $Object[k]\n}",
            "description": "Omit all keys that start with a specific prefix.",
            "examples": [
              {
                "code": "type T = OmitKeysWithPrefix<{ _a: string; _b: number; c: boolean }, '_'>\n// { c: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 325
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickRequiredProperties",
            "signature": "type PickRequiredProperties<$T extends object> = {\n  [k in keyof $T as {} extends Pick<$T, k> ? never : k]: $T[k]\n}",
            "description": "Pick only the required (non-optional) properties from an object.",
            "examples": [
              {
                "code": "type T = PickRequiredProperties<{ a: string; b?: number }>  // { a: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 339
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RequireProperties",
            "signature": "type RequireProperties<$O extends object, $K extends keyof $O> = Ts.Simplify<$O & { [k in $K]-?: $O[k] }>",
            "description": "Make specific properties required in an object.",
            "examples": [
              {
                "code": "type T = RequireProperties<{ a?: string; b?: number }, 'a'>\n// { a: string; b?: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 354
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PartialOrUndefined",
            "signature": "type PartialOrUndefined<$T> = {\n  [k in keyof $T]?: $T[k] | undefined\n}",
            "description": "Make all properties optional and allow undefined values.",
            "examples": [
              {
                "code": "type T = PartialOrUndefined<{ a: string; b: number }>\n// { a?: string | undefined; b?: number | undefined }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 367
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickOptionalPropertyOrFallback",
            "signature": "type PickOptionalPropertyOrFallback<$Object extends object, $Property extends keyof $Object, $Fallback> =\n  {} extends Pick<$Object, $Property> ? $Object[$Property] : $Fallback",
            "description": "Pick an optional property or use fallback if required.",
            "examples": [
              {
                "code": "type T1 = PickOptionalPropertyOrFallback<{ a?: string }, 'a', never>  // string\ntype T2 = PickOptionalPropertyOrFallback<{ a: string }, 'a', never>  // never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 382
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OnlyKeysInArray",
            "signature": "type OnlyKeysInArray<$Obj extends object, $KeysArray extends readonly string[]> = {\n  [k in keyof $Obj as k extends $KeysArray[number] ? k : never]: $Obj[k]\n}",
            "description": "Pick only the properties from an object that exist in a provided array of keys.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; age: number; email: string }\ntype PublicUser = OnlyKeysInArray<User, ['name', 'email']>\n// Result: { name: string; email: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 397
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "getWith",
            "signature": "<pathInput extends PropertyPathInput>(pathInput: pathInput) => <obj extends InferShapeFromPropertyPath<normalizePropertyPathInput<pathInput>>>(obj: obj) => getWith<normalizePropertyPathInput<pathInput>, obj>",
            "description": "Create a getter function for a specific property path. Returns a function that extracts the value at that path from any compatible object.",
            "examples": [
              {
                "code": "const getCityName = getWith('address.city')\ngetCityName({ address: { city: 'NYC' } }) // 'NYC'\ngetCityName({ address: { city: 'LA' } }) // 'LA'",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe property access\nconst getAge = getWith(['user', 'profile', 'age'])\nconst data = { user: { profile: { age: 30 } } }\nconst age = getAge(data) // number",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for mapping over arrays\nconst users = [\n  { name: 'Alice', score: 95 },\n  { name: 'Bob', score: 87 }\n]\nusers.map(getWith('score')) // [95, 87]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 63
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getOn",
            "signature": "(obj: object) => (pathInput: PropertyPathInput) => unknown",
            "description": "Create a getter function bound to a specific object. Returns a function that can extract values from that object using any property path. Inverse parameter order of getWith.",
            "examples": [
              {
                "code": "const user = {\n  name: 'Alice',\n  address: { city: 'NYC', zip: '10001' }\n}\n\nconst getUserProp = getOn(user)\ngetUserProp('name') // 'Alice'\ngetUserProp('address.city') // 'NYC'\ngetUserProp(['address', 'zip']) // '10001'",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for extracting multiple properties\nconst config = { api: { url: 'https://api.com', key: 'secret' } }\nconst getConfig = getOn(config)\n\nconst apiUrl = getConfig('api.url')\nconst apiKey = getConfig('api.key')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 122
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "entries",
            "signature": "<obj extends Any>(obj: obj) => { [K in keyof obj]-?: undefined extends obj[K] ? {} extends Pick<obj, K> ? [K, Exclude<obj[K]>] : [K, obj[K]] : [K, obj[K]]; }[keyof obj][]",
            "description": "Get an array of key-value pairs from an object. Preserves exact types including optional properties and undefined values.",
            "examples": [
              {
                "code": "entries({ a: 1, b: 'hello', c: true })\n// Returns: [['a', 1], ['b', 'hello'], ['c', true]]",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Handles optional properties and undefined values\nentries({ a: 1, b?: 2, c: undefined })\n// Returns proper types preserving optionality",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 156
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "stringKeyEntries",
            "signature": "<$T extends object>(obj: $T) => [string & keyof $T, $T[keyof $T]][]",
            "description": "Get entries from an object with string keys only.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2 }\nstringKeyEntries(obj)  // [['a', 1], ['b', 2]]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 183
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "entriesStrict",
            "signature": "<$T extends object>(obj: $T) => { [k in keyof $T]: [k, Exclude<$T[k], undefined>]; }[keyof $T][]",
            "description": "Get entries from an object excluding undefined values.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: undefined, c: 2 }\nentriesStrict(obj)  // [['a', 1], ['c', 2]]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 200
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "keysStrict",
            "signature": "<$T extends object>(obj: $T) => (keyof $T)[]",
            "description": "Get keys from an object with proper type inference. Type-safe version of Object.keys.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2 }\nkeysStrict(obj)  // ['a', 'b'] with type ('a' | 'b')[]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 222
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getRandomly",
            "signature": "<obj extends Any>(obj: obj) => keyof obj extends never ? undefined : obj[keyof obj]",
            "description": "Get a random property value from an object",
            "examples": [
              {
                "code": "getRandomly({ a: 1, b: 2, c: 3 }) // Could return 1, 2, or 3\ngetRandomly({ a: 1, b: undefined }) // Could return 1 or undefined\ngetRandomly({}) // Returns undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 241
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getValueAtPath",
            "signature": "<$T, ___Path extends readonly string[]>(obj: $T, path: ___Path) => any",
            "description": "Get a value at a path in an object.",
            "examples": [
              {
                "code": "const obj = { a: { b: { c: 42 } } }\ngetValueAtPath(obj, ['a', 'b', 'c'])  // 42\ngetValueAtPath(obj, ['a', 'x'])  // undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 270
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "values",
            "signature": "<$T extends object>(obj: $T) => values<$T>",
            "description": "Get an array of values from an object. Type-safe version of Object.values.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 'hello', c: true }\nvalues(obj)  // [1, 'hello', true] with type (string | number | boolean)[]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 300
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "GetKeyOr",
            "signature": "type GetKeyOr<$T, $Key, $Or> = $Key extends keyof $T ? $T[$Key] : $Or",
            "description": "Get value at key, or return fallback if key doesn't exist.",
            "examples": [
              {
                "code": "type T1 = GetKeyOr<{ a: string }, 'a', never>  // string\ntype T2 = GetKeyOr<{ a: string }, 'b', never>  // never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 317
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GetOrNever",
            "signature": "type GetOrNever<$O extends object, $P extends string> = $P extends keyof $O ? $O[$P]\n  : $P extends `${infer __head__}.${infer __tail__}`\n    ? __head__ extends keyof $O ? GetOrNever<$O[__head__] & object, __tail__>\n    : never\n  : never",
            "description": "Get value at key or return never.",
            "examples": [
              {
                "code": "type T1 = GetOrNever<{ a: string }, 'a'>  // string\ntype T2 = GetOrNever<{ a: string }, 'b'>  // never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 330
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "keyofOr",
            "signature": "type keyofOr<$Obj extends object, $Or> = [keyof $Obj] extends [never] ? $Or : $Obj[keyof $Obj]",
            "description": "Get the union of all value types from an object, or return fallback if no keys.",
            "examples": [
              {
                "code": "type T1 = keyofOr<{ a: string; b: number }, never>  // string | number\ntype T2 = keyofOr<{}, 'fallback'>  // 'fallback'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 347
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "KeysArray",
            "signature": "type KeysArray<$Obj extends object> = Array<keyof $Obj>",
            "description": "Create an array type containing the keys of an object.",
            "examples": [
              {
                "code": "type User = { name: string; age: number; email: string }\ntype UserKeys = KeysArray<User>\n// Result: Array<'name' | 'age' | 'email'>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 361
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "KeysReadonlyArray",
            "signature": "type KeysReadonlyArray<$Obj extends object> = ReadonlyArray<keyof $Obj>",
            "description": "Create a readonly array type containing the keys of an object.",
            "examples": [
              {
                "code": "type User = { name: string; age: number; email: string }\ntype UserKeys = KeysReadonlyArray<User>\n// Result: ReadonlyArray<'name' | 'age' | 'email'>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 375
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StringKeyof",
            "signature": "type StringKeyof<$T> = keyof $T & string",
            "description": "Extract only string keys from an object.",
            "examples": [
              {
                "code": "type T = StringKeyof<{ a: 1; [x: number]: 2 }>  // 'a'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 387
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "PrimitiveFieldKeys",
            "signature": "type PrimitiveFieldKeys<$T> = {\n  [K in keyof $T]: $T[K] extends string | number | boolean | bigint | null | undefined ? K\n    : $T[K] extends Date ? K\n    : never\n}[keyof $T]",
            "description": "Extract keys from an object type that have primitive values. Useful for serialization scenarios where only primitive values can be safely transferred.",
            "examples": [
              {
                "code": "type User = {\n  id: number\n  name: string\n  createdAt: Date\n  metadata: { tags: string[] }\n  isActive: boolean\n}\ntype SerializableKeys = PrimitiveFieldKeys<User>\n// Result: 'id' | 'name' | 'createdAt' | 'isActive'\n// Note: Date is considered primitive for serialization purposes",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 409
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "DeepObjectValue",
            "signature": "type DeepObjectValue = string | boolean | null | number | DeepObject | DeepObjectValue[]",
            "description": "A deep object value can be any JSON-serializable value including nested objects and arrays.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "map-entries-deep",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 6
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "DeepObject",
            "signature": "type DeepObject = { [key: string]: DeepObjectValue }",
            "description": "A deep object is a plain object with string keys and deep object values.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "map-entries-deep",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mapEntriesDeep",
            "signature": "<$value extends DeepObjectValue>(value: $value, visitor: (key: string, value: DeepObjectValue) => { key: string; value: DeepObjectValue; } | undefined) => $value",
            "description": "Recursively traverse a nested object structure and transform key-value pairs.  This utility applies a visitor function to every object entry in a deeply nested structure, allowing you to transform both keys and values. The visitor can return undefined to leave the entry unchanged, or return a new key, value pair to transform it.",
            "examples": [
              {
                "code": "// Strip dollar signs from all object keys\nmapEntriesDeep(data, (key, value) =>\n  key.startsWith('$') ? { key: key.slice(1), value } : undefined\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Convert all string values to uppercase\nmapEntriesDeep(data, (key, value) =>\n  typeof value === 'string' ? { key, value: value.toUpperCase() } : undefined\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "map-entries-deep",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mergeWith",
            "signature": "(mergers?: MergeOptions | undefined) => <obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "description": "Create a customized merge function with specific merge behavior options. Allows control over how undefined values, defaults, and arrays are handled.",
            "examples": [
              {
                "code": "// Create a merger that ignores undefined values\nconst mergeIgnoreUndefined = mergeWith({ undefined: false })\nmergeIgnoreUndefined({ a: 1 }, { a: undefined, b: 2 })\n// Returns: { a: 1, b: 2 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Create a merger that concatenates arrays\nconst mergeArrays = mergeWith({\n  array: (a, b) => { a.push(...b) }\n})\nmergeArrays({ items: [1, 2] }, { items: [3, 4] })\n// Returns: { items: [1, 2, 3, 4] }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "merge",
            "signature": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "description": "Deep merge two objects, with properties from the second object overwriting the first. Recursively merges nested objects, but arrays and other non-object values are replaced.",
            "examples": [
              {
                "code": "merge({ a: 1, b: 2 }, { b: 3, c: 4 })\n// Returns: { a: 1, b: 3, c: 4 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Deep merging of nested objects\nmerge(\n  { user: { name: 'Alice', age: 30 } },\n  { user: { age: 31, city: 'NYC' } }\n)\n// Returns: { user: { name: 'Alice', age: 31, city: 'NYC' } }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Arrays are replaced, not merged\nmerge({ tags: ['a', 'b'] }, { tags: ['c', 'd'] })\n// Returns: { tags: ['c', 'd'] }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 81
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeWithArrayPush",
            "signature": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "description": "Deep merge two objects with special handling for arrays. When both objects have an array at the same path, concatenates them instead of replacing.",
            "examples": [
              {
                "code": "mergeWithArrayPush(\n  { tags: ['react', 'typescript'] },\n  { tags: ['nodejs', 'express'] }\n)\n// Returns: { tags: ['react', 'typescript', 'nodejs', 'express'] }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Works with nested arrays\nmergeWithArrayPush(\n  { user: { skills: ['js'] } },\n  { user: { skills: ['ts'] } }\n)\n// Returns: { user: { skills: ['js', 'ts'] } }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 108
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeWithArrayPushDedupe",
            "signature": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "description": "Deep merge two objects with array concatenation and deduplication. When both objects have an array at the same path, concatenates and removes duplicates.",
            "examples": [
              {
                "code": "mergeWithArrayPushDedupe(\n  { tags: ['react', 'vue', 'react'] },\n  { tags: ['react', 'angular'] }\n)\n// Returns: { tags: ['react', 'vue', 'angular'] }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Preserves order with first occurrence kept\nmergeWithArrayPushDedupe(\n  { ids: [1, 2, 3] },\n  { ids: [3, 4, 2, 5] }\n)\n// Returns: { ids: [1, 2, 3, 4, 5] }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 139
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeDefaults",
            "signature": "<obj1 extends Any, obj1Defaults extends Partial<obj1>>(obj1: obj1, obj1Defaults: obj1Defaults) => { [_ in keyof (obj1 & obj1Defaults)]: (obj1 & obj1Defaults)[_]; }",
            "description": "Merge default values into an object, only filling in missing properties. Existing properties in the base object are preserved, even if undefined.",
            "examples": [
              {
                "code": "mergeDefaults(\n  { name: 'Alice', age: undefined },\n  { name: 'Unknown', age: 0, city: 'NYC' }\n)\n// Returns: { name: 'Alice', age: undefined, city: 'NYC' }\n// Note: existing properties (even undefined) are not overwritten",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for configuration objects\nconst config = { port: 3000 }\nconst defaults = { port: 8080, host: 'localhost', debug: false }\nmergeDefaults(config, defaults)\n// Returns: { port: 3000, host: 'localhost', debug: false }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 175
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "shallowMergeDefaults",
            "signature": "<$Defaults extends object, $Input extends object>(defaults: $Defaults, input: $Input) => $Defaults & $Input",
            "description": "Shallow merge two objects with later values overriding earlier ones. Useful for providing defaults that can be overridden.",
            "examples": [
              {
                "code": "const defaults = { a: 1, b: 2, c: 3 }\nconst input = { b: 20 }\nshallowMergeDefaults(defaults, input)  // { a: 1, b: 20, c: 3 }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 199
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "spreadShallow",
            "signature": "<$Objects extends readonly (object | undefined)[]>(...objects: $Objects) => {}",
            "description": "Shallow merge objects while omitting undefined values. Simplifies the common pattern of conditionally spreading objects to avoid including undefined values that would override existing values.",
            "examples": [
              {
                "code": "// Instead of:\nconst config = {\n  ...defaultConfig,\n  ...(userConfig ? userConfig : {}),\n  ...(debug ? { debug: true } : {}),\n}\n\n// Use:\nconst config = spreadShallow(\n  defaultConfig,\n  userConfig,\n  { debug: debug ? true : undefined }\n)\n// undefined values won't override earlier values",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 234
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "MergeShallow",
            "signature": "type MergeShallow<\n  $Object1 extends Any,\n  $Object2 extends Any,\n  __ =\n    {} extends $Object1\n      ? $Object2\n      : & $Object2\n        // Keys from $Object1 that are NOT in $Object2\n        & {\n            [__k__ in keyof $Object1 as __k__ extends keyof $Object2 ? never : __k__]: $Object1[__k__]\n          }\n> = __",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 261
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MergeAllShallow",
            "signature": "type MergeAllShallow<$Objects extends readonly object[]> =\n  $Objects extends readonly [infer $First extends object, ...infer $Rest extends object[]]\n    ? $Rest extends readonly []\n      ? $First\n      : MergeShallow<$First, MergeAllShallow<$Rest>>\n    : {}",
            "description": "Recursively merge an array of objects using shallow merge semantics. Each object in the array overrides properties from previous objects.",
            "examples": [
              {
                "code": "type T = MergeAllShallow<[{ a: string }, { b: number }, { c: boolean }]>\n// Result: { a: string; b: number; c: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 287
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MergeAll",
            "signature": "type MergeAll<$Objects extends object[]> = $Objects extends\n  [infer __first__ extends object, ...infer __rest__ extends object[]] ? __first__ & MergeAll<__rest__>\n  : {}",
            "description": "Merge an array of object types into a single type using deep merge semantics. Uses TypeScript's intersection type (&) for merging.",
            "examples": [
              {
                "code": "type T = MergeAll<[{ a: string }, { b: number }]>\n// Result: { a: string; b: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 306
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReplaceProperty",
            "signature": "type ReplaceProperty<$Obj extends object, $Key extends keyof $Obj, $NewType> =\n  & Omit<$Obj, $Key>\n  & {\n    [_ in $Key]: $NewType\n  }",
            "description": "Replace the type of a specific property in an object.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; age: number }\ntype UpdatedUser = ReplaceProperty<User, 'id', string>\n// Result: { id: string; name: string; age: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 322
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "Replace",
            "signature": "type Replace<$Object1, $Object2> = Omit<$Object1, keyof $Object2> & $Object2",
            "description": "Replace properties in an object type with new types. Useful for overriding specific property types.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; createdAt: Date }\ntype SerializedUser = Replace<User, { createdAt: string }>\n// Result: { id: number; name: string; createdAt: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 341
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "assert",
            "signature": "function assert(value: unknown): void",
            "description": "Assert that a value is an object. Throws a TypeError if the value is not an object (including null).",
            "examples": [
              {
                "code": "function process(value: unknown) {\n  Obj.assert(value)\n  // value is now typed as object\n  console.log(Object.keys(value))\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Shape & Validation",
            "tags": {
              "throws": "TypeError If the value is not an object"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 34
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isShape",
            "signature": "<type>(spec: Record<PropertyKey, \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\">) => (value: unknown) => value is type",
            "description": "Create a type predicate function that checks if a value matches a shape specification. Uses JavaScript's typeof operator to validate property types.",
            "examples": [
              {
                "code": "const isUser = isShape<{ name: string; age: number }>({\n  name: 'string',\n  age: 'number'\n})\n\nisUser({ name: 'Alice', age: 30 }) // true\nisUser({ name: 'Bob' }) // false - missing age\nisUser({ name: 'Charlie', age: '30' }) // false - age is string",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Can check for functions and other typeof types\nconst isCallback = isShape<{ fn: Function }>({\n  fn: 'function'\n})",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Shape & Validation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 73
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "setPrivateState",
            "signature": "<obj extends Any>(obj: obj, value: object) => obj",
            "description": "Attach private state to an object using a non-enumerable Symbol property. The state is immutable once set and cannot be discovered through enumeration.",
            "examples": [
              {
                "code": "const user = { name: 'Alice' }\nconst privateData = { password: 'secret123' }\n\nsetPrivateState(user, privateData)\n// user still appears as { name: 'Alice' } when logged\n// but has hidden private state accessible via getPrivateState",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for attaching metadata without polluting the object\nconst config = { timeout: 5000 }\nsetPrivateState(config, {\n  source: 'environment',\n  timestamp: Date.now()\n})",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "State Management",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 116
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getPrivateState",
            "signature": "<state extends Any>(obj: object) => state",
            "description": "Retrieve private state previously attached to an object with setPrivateState.",
            "examples": [
              {
                "code": "const user = { name: 'Alice' }\nsetPrivateState(user, { role: 'admin' })\n\nconst privateData = getPrivateState<{ role: string }>(user)\nconsole.log(privateData.role) // 'admin'",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe private state retrieval\ninterface Metadata {\n  createdAt: number\n  createdBy: string\n}\n\nconst doc = { title: 'Report' }\nsetPrivateState(doc, { createdAt: Date.now(), createdBy: 'system' })\n\nconst meta = getPrivateState<Metadata>(doc)\n// meta is typed as Metadata",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "State Management",
            "tags": {
              "throws": "Error if no private state is found on the object"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 159
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "hasNonUndefinedKeys",
            "signature": "(object: object) => boolean",
            "description": "Check if an object has any non-undefined values.",
            "examples": [
              {
                "code": "hasNonUndefinedKeys({ a: undefined, b: undefined })  // false\nhasNonUndefinedKeys({ a: undefined, b: 1 })  // true\nhasNonUndefinedKeys({})  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 179
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PartialDeep",
            "signature": "type PartialDeep<$Type> =\n  $Type extends Array<infer __inner__>                  ? Array<PartialDeep<__inner__>> :\n  $Type extends ReadonlyArray<infer __inner__>          ? ReadonlyArray<PartialDeep<__inner__>> :\n  $Type extends Promise<infer __inner__>                ? Promise<PartialDeep<__inner__>> :\n  $Type extends Function                                ? $Type :\n  $Type extends object                                  ? {\n                                                            [key in keyof $Type]?: PartialDeep<$Type[key]>\n                                                          } :\n                                                        // else\n                                                          $Type",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 186
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Writeable",
            "signature": "type Writeable<$Obj extends object> = Writable<$Obj>",
            "description": "Make all properties of an object writable (remove readonly modifiers).",
            "examples": [
              {
                "code": "type ReadonlyUser = { readonly id: number; readonly name: string }\ntype WritableUser = Writeable<ReadonlyUser>\n// Result: { id: number; name: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 224
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ToParameters",
            "signature": "type ToParameters<$Params extends object | undefined> =\n  undefined extends $Params ? [params?: $Params] :\n  $Params extends undefined ? [params?: $Params] :\n                              [params: $Params]",
            "description": "Convert an object to a parameters tuple.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 232
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ToParametersExact",
            "signature": "type ToParametersExact<\n  $Input extends object,\n  $Params extends object | undefined,\n> = IsEmpty<$Input> extends true ? []\n  : ToParameters<$Params>",
            "description": "Convert an object to parameters tuple with exact matching.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 242
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyKeyToString",
            "signature": "type PropertyKeyToString<$Key extends PropertyKey> = $Key extends string ? $Key\n  : $Key extends number ? `${$Key}`\n  : never",
            "description": "Convert PropertyKey to string if possible.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 253
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPathExpression",
            "signature": "type PropertyPathExpression = string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPath",
            "signature": "type PropertyPath = readonly string[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 6
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPathInput",
            "signature": "type PropertyPathInput = PropertyPathExpression | PropertyPath",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 8
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "normalizePropertyPathInput",
            "signature": "<pathInput extends PropertyPathInput>(pathInput: pathInput) => normalizePropertyPathInput<pathInput>",
            "description": "Normalize a property path input to a consistent array format. Accepts either a dot-notation string or an array of property names.",
            "examples": [
              {
                "code": "normalizePropertyPathInput('user.address.city')\n// Returns: ['user', 'address', 'city']",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "normalizePropertyPathInput(['user', 'address', 'city'])\n// Returns: ['user', 'address', 'city'] (unchanged)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Path Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PropertyPathSeparator",
            "signature": "\".\"",
            "description": "The separator character used in property path expressions. Used to split dot-notation paths like 'user.address.city'.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 52
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parsePropertyPathExpression",
            "signature": "<expression extends string>(expression: expression) => parsePropertyPathExpression<expression>",
            "description": "Parse a dot-notation property path expression into an array of property names.",
            "examples": [
              {
                "code": "parsePropertyPathExpression('user.name')\n// Returns: ['user', 'name']",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "parsePropertyPathExpression('config.server.port')\n// Returns: ['config', 'server', 'port']",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "parsePropertyPathExpression('singleProperty')\n// Returns: ['singleProperty']",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Path Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 81
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "InferShapeFromPropertyPath",
            "signature": "type InferShapeFromPropertyPath<$PropertyPath extends PropertyPath> =\n\t$PropertyPath extends readonly []\n\t\t? {}\n\t\t: _InferShapeFromPropertyPath<$PropertyPath>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 92
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "_InferShapeFromPropertyPath",
            "signature": "type _InferShapeFromPropertyPath<$PropertyPath extends PropertyPath> =\n  $PropertyPath extends readonly [infer __key__ extends string, ...infer __tail__ extends readonly string[]]\n    ? { [_ in __key__]?: InferShapeFromPropertyPath<__tail__> }\n    : unknown",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 98
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Any",
            "signature": "type Any = object",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsEmpty",
            "signature": "type IsEmpty<$Obj extends object> = keyof $Obj extends never ? true : false",
            "description": "Type-level check to determine if an object type has no keys.",
            "examples": [
              {
                "code": "type Empty = IsEmpty<{}> // true\ntype NotEmpty = IsEmpty<{ a: 1 }> // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Empty",
            "signature": "type Empty = Record<string, never>",
            "description": "Type for an empty object.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 34
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "empty",
            "signature": "() => Empty",
            "description": "Create an empty object with proper type. Returns a frozen empty object typed as Empty.",
            "examples": [
              {
                "code": "const opts = options ?? Obj.empty()",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type is properly inferred as Empty\nconst emptyObj = Obj.empty()\ntype T = typeof emptyObj  // Record<string, never>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 56
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "NoExcess",
            "signature": "type NoExcess<$Expected, $Actual> = $Actual & Record<Exclude<keyof $Actual, keyof $Expected>, never>",
            "description": "Enforces that a type has no excess properties beyond those defined in the expected type.  This utility intersects the actual type with a record that marks all excess keys as never, causing TypeScript to reject values with properties not present in the expected type. Particularly useful in generic contexts where excess property checking is bypassed.",
            "examples": [
              {
                "code": "type User = { name: string; age: number }\n\n// Standard generic - allows excess properties\nfunction test1<T extends User>(input: T): void {}\ntest1({ name: 'Alice', age: 30, extra: true })  //  No error (excess allowed)\n\n// With NoExcess - rejects excess\nfunction test2<T extends User>(input: Obj.NoExcess<User, T>): void {}\ntest2({ name: 'Alice', age: 30, extra: true })  //  Error: 'extra' is never\ntest2({ name: 'Alice', age: 30 })  //  OK",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using with optional properties\ntype Config = { id: string; debug?: boolean }\n\nfunction configure<T extends Config>(config: Obj.NoExcess<Config, T>): void {}\n\nconfigure({ id: 'test' })  //  OK - optional omitted\nconfigure({ id: 'test', debug: true })  //  OK - optional included\nconfigure({ id: 'test', invalid: 'x' })  //  Error: 'invalid' is never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities   $Expected - The type defining allowed properties  $Actual - The actual type to check for excess properties",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 109
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "NoExcessNonEmpty",
            "signature": "type NoExcessNonEmpty<$Value extends object, $Constraint> = IsEmpty<$Value> extends true ? never\n  : NoExcess<$Constraint, $Value>",
            "description": "Like NoExcess but also requires the object to be non-empty.  Enforces that: 1. Object has at least one property (not empty) 2. Object has no excess properties beyond the constraint",
            "examples": [
              {
                "code": "type User = { name: string }\n\ntype T1 = NoExcessNonEmpty<{ name: 'Alice' }, User>        //  Pass\ntype T2 = NoExcessNonEmpty<{}, User>                       //  Fail - empty\ntype T3 = NoExcessNonEmpty<{ name: 'Bob', age: 30 }, User> //  Fail - excess",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 129
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isEmpty",
            "signature": "(obj: object) => boolean",
            "description": "Check if an object has no enumerable properties.",
            "examples": [
              {
                "code": "isEmpty({}) // true\nisEmpty({ a: 1 }) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Non-enumerable properties are ignored\nconst obj = {}\nObject.defineProperty(obj, 'hidden', { value: 1, enumerable: false })\nisEmpty(obj) // true - non-enumerable properties are ignored",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 164
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isEmpty$",
            "signature": "<$T extends object>(obj: $T) => obj is $T & Empty",
            "description": "Type predicate that checks if an object has no enumerable properties. Narrows the type to an empty object type.",
            "examples": [
              {
                "code": "const obj: { a?: number } = {}\nif (isEmpty$(obj)) {\n  // obj is now typed as Empty\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful in conditional type flows\nfunction processObject<T extends object>(obj: T) {\n  if (isEmpty$(obj)) {\n    // obj is Empty here\n    return 'empty'\n  }\n  // obj retains its original type here\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 197
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "HasOptionalKeys",
            "signature": "type HasOptionalKeys<$Obj extends object> = OptionalKeys<$Obj> extends never ? false : true",
            "description": "Check if an interface has any optional properties.",
            "examples": [
              {
                "code": "type T1 = HasOptionalKeys<{ a?: string }>  // true\ntype T2 = HasOptionalKeys<{ a: string }>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OptionalKeys",
            "signature": "type OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]",
            "description": "Extract keys that are optional in the interface.",
            "examples": [
              {
                "code": "type Obj = { a: string; b?: number; c?: boolean }\ntype Optional = OptionalKeys<Obj>  // 'b' | 'c'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RequiredKeys",
            "signature": "type RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>",
            "description": "Extract keys that are required in the interface.",
            "examples": [
              {
                "code": "type Obj = { a: string; b?: number; c?: boolean }\ntype Required = RequiredKeys<Obj>  // 'a'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 42
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasRequiredKeys",
            "signature": "type HasRequiredKeys<$Obj extends object> = RequiredKeys<$Obj> extends never ? false : true",
            "description": "Check if an interface has any required properties.",
            "examples": [
              {
                "code": "type T1 = HasRequiredKeys<{ a: string }>  // true\ntype T2 = HasRequiredKeys<{ a?: string }>  // false\ntype T3 = HasRequiredKeys<{ a: string; b?: number }>  // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 56
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasOptionalKey",
            "signature": "type HasOptionalKey<$Object extends object, $Key extends keyof $Object> = undefined extends $Object[$Key] ? true\n  : false",
            "description": "Check if a key is optional in an object.",
            "examples": [
              {
                "code": "type T1 = HasOptionalKey<{ a?: string }, 'a'>  // true\ntype T2 = HasOptionalKey<{ a: string }, 'a'>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 69
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsKeyOptional",
            "signature": "type IsKeyOptional<$T extends Undefined.Maybe<object>, $K extends string> = $K extends keyof $T\n  ? ({} extends Pick<$T, $K> ? true : false)\n  : false",
            "description": "Check if a key is optional in an object.",
            "examples": [
              {
                "code": "type T1 = IsKeyOptional<{ a?: string }, 'a'>  // true\ntype T2 = IsKeyOptional<{ a: string }, 'a'>  // false\ntype T3 = IsKeyOptional<{ a: string }, 'b'>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 84
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasKey",
            "signature": "type HasKey<$T extends object, $K extends string> = $K extends keyof $T ? true : false",
            "description": "Check if a key exists in an object.",
            "examples": [
              {
                "code": "type T1 = HasKey<{ a: string }, 'a'>  // true\ntype T2 = HasKey<{ a: string }, 'b'>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 99
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertySignature",
            "signature": "type PropertySignature = {\n  name: string\n  type: any\n  optional: boolean\n  optionalUndefined: boolean\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "property-signature",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mapValues",
            "signature": "<rec extends Record<PropertyKey, any>, newValue>(obj: rec, fn: (value: rec[keyof rec], key: keyof rec) => newValue) => Record<keyof rec, newValue>",
            "description": "Create a new object with the same keys but with values transformed by a function.",
            "examples": [
              {
                "code": "const prices = { apple: 1.5, banana: 0.75, orange: 2 }\nconst doublePrices = mapValues(prices, (price) => price * 2)\n// Result: { apple: 3, banana: 1.5, orange: 4 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using the key parameter\nconst data = { a: 1, b: 2, c: 3 }\nconst withKeys = mapValues(data, (value, key) => `${key}: ${value}`)\n// Result: { a: 'a: 1', b: 'b: 2', c: 'c: 3' }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "update",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "value",
            "type": "function"
          }
        ],
        "category": "Core Data Structures"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./prom",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "prom"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Promise utilities for asynchronous operations.  Provides utilities for working with Promises including deferred promise creation, promise combinators, and async control flow patterns.",
        "exports": [
          {
            "name": "Deferred",
            "signature": "interface Deferred<$Value> {\n  /**\n   * The promise that will be resolved or rejected.\n   */\n  promise: Promise<$Value>\n  /**\n   * Resolve the promise with a value.\n   */\n  resolve: (value: $Value) => void\n  /**\n   * Reject the promise with an error.\n   */\n  reject: (error: unknown) => void\n  /**\n   * Whether the promise has been resolved.\n   */\n  readonly isResolved: boolean\n  /**\n   * Whether the promise has been rejected.\n   */\n  readonly isRejected: boolean\n  /**\n   * Whether the promise has been settled (resolved or rejected).\n   */\n  readonly isSettled: boolean\n}",
            "description": "A deferred promise with exposed resolve and reject functions.",
            "examples": [
              {
                "code": "const deferred = createDeferred<number>()\n\n// Later resolve it\ndeferred.resolve(42)\n\n// Or reject it\ndeferred.reject(new Error('failed'))\n\n// Use the promise\nawait deferred.promise  // 42",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Check resolution state\nconst deferred = createDeferred<number>()\nconsole.log(deferred.isResolved)  // false\ndeferred.resolve(42)\nconsole.log(deferred.isResolved)  // true\nconsole.log(deferred.isSettled)   // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Deferred",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "deferred",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 30
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "createDeferred",
            "signature": "<$T>(options?: { strict?: boolean; } | undefined) => Deferred<$T>",
            "description": "Create a deferred promise with exposed resolve and reject functions.",
            "examples": [
              {
                "code": "const deferred = createDeferred<number>()\n\nsetTimeout(() => {\n  deferred.resolve(42)\n}, 1000)\n\nconst result = await deferred.promise  // 42",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Strict mode prevents multiple resolutions\nconst deferred = createDeferred<number>({ strict: true })\n\ndeferred.resolve(1)\ndeferred.resolve(2)  // Throws error",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Deferred",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "deferred",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 86
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "maybeAsync",
            "signature": "function maybeAsync<T, R = T, E = unknown>(fn: () => T, handlers: MaybeAsyncHandlers<T extends Promise<infer U> ? U : T, R, E> = {}): T extends Promise<infer U> ? Promise<R | E | U> : T | R | E",
            "description": "Handle a function that might return a promise or a regular value, with unified handlers for both sync and async cases.",
            "examples": [
              {
                "code": "// Basic usage\nconst result = maybeAsync(\n  () => fetchData(),\n  {\n    then: (data) => processData(data),\n    catch: (error) => ({ success: false, error })\n  }\n)\n\n// Just error handling\nconst safeResult = maybeAsync(\n  () => riskyOperation(),\n  {\n    catch: (error, isAsync) => {\n      console.error(`Failed ${isAsync ? 'async' : 'sync'}:`, error)\n      return null\n    }\n  }\n)\n\n// Just success handling\nconst transformed = maybeAsync(\n  () => getValue(),\n  {\n    then: (value) => value.toUpperCase()\n  }\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 151
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Any",
            "signature": "type Any = Promise<unknown>",
            "description": "Type representing a Promise of unknown type. Useful for generic promise handling where the resolved type is not important.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAny",
            "signature": "type AnyAny = Promise<any>",
            "description": "Type representing a Promise of any type. Less type-safe than Any, use with caution.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Maybe",
            "signature": "type Maybe<$Type> = $Type | Promise<$Type>",
            "description": "Type representing a value that may or may not be wrapped in a Promise.",
            "examples": [
              {
                "code": "// function that accepts sync or async values\nfunction process<T>(value: Maybe<T>): Promise<T> {\n  return Promise.resolve(value)\n}\n\nprocess(42) // accepts number\nprocess(Promise.resolve(42)) // accepts Promise<number>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "isShape",
            "signature": "(value: unknown) => value is AnyAny",
            "description": "Check if a value has the shape of a Promise. Tests for the presence of then, catch, and finally methods.",
            "examples": [
              {
                "code": "// with a promise\nisShape(Promise.resolve(42)) // true\n\n// with a thenable object\nisShape({ then: () => {}, catch: () => {}, finally: () => {} }) // true\n\n// with non-promise values\nisShape(42) // false\nisShape({}) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 59
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AwaitedUnion",
            "signature": "type AwaitedUnion<$MaybePromise, $Additional> =\n  $MaybePromise extends Promise<infer __promised__>\n    ? Promise<Awaited<__promised__ | $Additional>>\n    : $MaybePromise | $Additional",
            "description": "Type that adds an additional type to a potentially promised union. If the input is a Promise, the additional type is added to the promised value. If the input is not a Promise, creates a union with the additional type.",
            "examples": [
              {
                "code": "// with promise input\ntype Result1 = AwaitedUnion<Promise<string>, number> // Promise<string | number>\n\n// with non-promise input\ntype Result2 = AwaitedUnion<string, number> // string | number",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 86
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MaybeAsyncHandlers",
            "signature": "interface MaybeAsyncHandlers<T, R = T, E = unknown> {\n  /**\n   * Handler for successful values (sync or async).\n   */\n  then?: (value: T) => R\n\n  /**\n   * Handler for errors (sync or async).\n   * @param error - The caught error\n   * @param isAsync - Whether the error occurred asynchronously\n   */\n  catch?: (error: unknown, isAsync: boolean) => E\n}",
            "description": "Options for handling values that might be promises.",
            "examples": [],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 96
            },
            "_tag": "type",
            "type": "interface"
          }
        ],
        "category": "Error Handling & Values"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./rec",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "rec"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Record utilities for working with plain JavaScript objects as dictionaries.  Provides type-safe operations for records (objects with PropertyKey indexes) including type guards, merging, creation, and index signature manipulation. Strictly validates plain objects, rejecting arrays and class instances.",
        "exports": [
          {
            "name": "Any",
            "signature": "type Any = AnyKeyTo<unknown>",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyReadonly",
            "signature": "type AnyReadonly = AnyReadonlyKeyTo<unknown>",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 12
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyKeyTo",
            "signature": "type AnyKeyTo<$Value> = {\n  [key: PropertyKey]: $Value\n}",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyReadonlyKeyTo",
            "signature": "type AnyReadonlyKeyTo<$Value> = {\n  readonly [key: PropertyKey]: $Value\n}",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 24
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Value",
            "signature": "type Value = {\n  [key: PropertyKey]: Lang.Value\n}",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "is",
            "signature": "(value: unknown) => value is Any",
            "description": "Check if a value is a record (plain object only, not class instances or arrays). This is a strict check that only accepts plain objects with Object.prototype.",
            "examples": [
              {
                "code": "is({ a: 1, b: 2 }) // true\nis({}) // true\nis([1, 2, 3]) // false - arrays are not records\nis(null) // false\nis(new Date()) // false - class instances are not plain records\nis(Object.create(null)) // false - not plain Object.prototype",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type guard usage\nfunction processData(data: unknown) {\n  if (is(data)) {\n    // data is typed as Rec.Any\n    Object.keys(data).forEach(key => {\n      console.log(data[key])\n    })\n  }\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 67
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "merge",
            "signature": "<rec1 extends Any, rec2 extends Any>(rec1: rec1, rec2: rec2) => rec1 & rec2",
            "description": "Deep merge two records, with properties from the second record overwriting the first. This is an alias for Obj.merge that works specifically with record types.",
            "examples": [
              {
                "code": "merge({ a: 1, b: 2 }, { b: 3, c: 4 })\n// Returns: { a: 1, b: 3, c: 4 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Deep merging of nested records\nmerge(\n  { user: { name: 'Alice', settings: { theme: 'dark' } } },\n  { user: { settings: { fontSize: 16 } } }\n)\n// Returns: { user: { name: 'Alice', settings: { theme: 'dark', fontSize: 16 } } }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe merging\ntype Config = { api: { url: string }; timeout?: number }\ntype Overrides = { api: { key: string }; timeout: number }\n\nconst config: Config = { api: { url: 'https://api.com' } }\nconst overrides: Overrides = { api: { key: 'secret' }, timeout: 5000 }\nconst merged = merge(config, overrides)\n// merged is typed as Config & Overrides",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Operations",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 116
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Optional",
            "signature": "type Optional<$Key extends PropertyKey, $Value> = {\n  [K in $Key]?: $Value\n}",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 123
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RemoveIndex",
            "signature": "type RemoveIndex<$T> = {\n  [k in keyof $T as string extends k ? never : number extends k ? never : k]: $T[k]\n}",
            "description": "Remove index signatures from an object type. Useful for converting Record types to object types with only known keys.",
            "examples": [
              {
                "code": "type WithIndex = { a: string; b: number; [key: string]: any }\ntype WithoutIndex = RemoveIndex<WithIndex>  // { a: string; b: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 139
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsHasIndex",
            "signature": "type IsHasIndex<$T, $Key extends PropertyKey = string> = $Key extends keyof $T ? true : false",
            "description": "Check if a type has an index signature.",
            "examples": [
              {
                "code": "type T1 = IsHasIndex<{ [key: string]: any }>  // true\ntype T2 = IsHasIndex<{ a: string }>  // false\ntype T3 = IsHasIndex<{ [key: number]: any }, number>  // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 155
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "create",
            "signature": "<value>() => Record<PropertyKey, value>",
            "description": "Create an empty record with a specific value type. Useful for initializing typed record collections.",
            "examples": [
              {
                "code": "const scores = create<number>()\nscores['alice'] = 95\nscores['bob'] = 87\n// scores is typed as Record<PropertyKey, number>",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Creating typed lookups\ninterface User {\n  id: string\n  name: string\n}\n\nconst userLookup = create<User>()\nuserLookup['u123'] = { id: 'u123', name: 'Alice' }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful as accumulator in reduce operations\nconst grouped = items.reduce(\n  (acc, item) => {\n    acc[item.category] = item\n    return acc\n  },\n  create<Item>()\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Factories",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 197
            },
            "_tag": "value",
            "type": "function"
          }
        ],
        "category": "Collections"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./str",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "str"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "String utilities for text manipulation and analysis.  Provides comprehensive string operations including case conversion, splitting, matching, replacement, templating, and character utilities. Features type-safe APIs with strong inference for string literals and patterns.",
        "exports": [
          {
            "_tag": "value",
            "name": "Case",
            "type": "namespace",
            "signature": "export * as Case",
            "description": "Convert string to camelCase.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "case"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "case"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "case",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Convert string to camelCase.",
              "category": "Case Conversion",
              "exports": [
                {
                  "name": "camel",
                  "signature": "function camelCase(str: string): string",
                  "description": "Converts a string to camel case.  Camel case is the naming convention in which the first word is written in lowercase and each subsequent word begins with a capital letter, concatenated without any separator characters.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "camelCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 17
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "kebab",
                  "signature": "function kebabCase(str: string): string",
                  "description": "Converts a string to kebab case.  Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kebabCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "pascal",
                  "signature": "function pascalCase(str: string): string",
                  "description": "Converts a string to Pascal case.  Pascal case is the naming convention in which each word is capitalized and concatenated without any separator characters.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "pascalCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "snake",
                  "signature": "function snakeCase(str: string): string",
                  "description": "Converts a string to snake case.  Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "snakeCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "title",
                  "signature": "(str: string) => string",
                  "description": "Convert string to Title Case. Replaces hyphens and underscores with spaces and capitalizes the first letter of each word.",
                  "examples": [
                    {
                      "code": "title('hello-world') // 'Hello World'\ntitle('foo_bar') // 'Foo Bar'\ntitle('the quick brown fox') // 'The Quick Brown Fox'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 58
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "capAll",
                  "signature": "<$S extends string>(str: $S) => Uppercase<$S>",
                  "description": "Convert string to UPPERCASE with type-level transformation. Preserves the uppercase type at the type level.",
                  "examples": [
                    {
                      "code": "uppercase('hello')  // Type: \"HELLO\" (not string)\nuppercase('world')  // Type: \"WORLD\"\n\n// Works with plain strings too\nuppercase('hello world') // 'HELLO WORLD'\nuppercase('FooBar') // 'FOOBAR'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 80
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "uncapFirst",
                  "signature": "<$S extends string>(s: $S) => Uncapitalize<$S>",
                  "description": "Convert the first letter of a string to lowercase with type-level transformation.",
                  "examples": [
                    {
                      "code": "lowerCaseFirst('Hello')  // Type: \"hello\"\nlowerCaseFirst('World')  // Type: \"world\"\nlowerCaseFirst('HELLO')  // Type: \"hELLO\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 96
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "capFirst",
                  "signature": "<$S extends string>(string: $S) => Capitalize<$S>",
                  "description": "Capitalize the first letter of a string with type-level transformation.",
                  "examples": [
                    {
                      "code": "capitalizeFirst('hello')  // Type: \"Hello\"\ncapitalizeFirst('world')  // Type: \"World\"\ncapitalizeFirst('foo bar')  // Type: \"Foo bar\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 112
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Char",
            "type": "namespace",
            "signature": "export * as Char",
            "description": "Uppercase letter.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "char"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "char"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "char",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Uppercase letter.",
              "category": "Character Types",
              "exports": [
                {
                  "name": "LetterUpper",
                  "signature": "type LetterUpper =\n  | 'A'\n  | 'B'\n  | 'C'\n  | 'D'\n  | 'E'\n  | 'F'\n  | 'G'\n  | 'H'\n  | 'I'\n  | 'J'\n  | 'K'\n  | 'L'\n  | 'M'\n  | 'N'\n  | 'O'\n  | 'P'\n  | 'Q'\n  | 'R'\n  | 'S'\n  | 'T'\n  | 'U'\n  | 'V'\n  | 'W'\n  | 'X'\n  | 'Y'\n  | 'Z'",
                  "description": "Uppercase letter.",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 13
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "LetterLower",
                  "signature": "type LetterLower =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z'",
                  "description": "Lowercase letter.",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 45
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "Letter",
                  "signature": "type Letter = LetterLower | LetterUpper",
                  "description": "Any letter (uppercase or lowercase).",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 77
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "Digit",
                  "signature": "type Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'",
                  "description": "Digit character.",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 83
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "spaceNoBreak",
                  "signature": "\"\"",
                  "description": "Non-breaking space character (U+00A0). A space character that prevents line breaks at its position.",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 99
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "spaceRegular",
                  "signature": "\" \"",
                  "description": "Regular space character (U+0020). The standard space character.",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "newline",
                  "signature": "\"\\n\"",
                  "description": "Line feed (newline) character. Used to create line breaks in text.",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 114
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "bullet",
                  "signature": "\"\"",
                  "description": "Bullet character (U+2022). Standard bullet point symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 122
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "middleDot",
                  "signature": "\"\"",
                  "description": "Middle dot character (U+00B7). Centered dot symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 130
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "blackCircle",
                  "signature": "\"\"",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 141
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "whiteBullet",
                  "signature": "\"\"",
                  "description": "White bullet character (U+25E6). Hollow circle symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 149
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "inverseBullet",
                  "signature": "\"\"",
                  "description": "Inverse bullet character (U+25D8). Inverse white circle symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 157
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "squareWithLeftHalfBlack",
                  "signature": "\"\"",
                  "description": "Square with left half black character (U+25E7). Half-filled square symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 165
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "rightwardsArrow",
                  "signature": "\"\"",
                  "description": "Rightwards arrow character (U+2192). Right-pointing arrow symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 173
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "name": "Arb",
            "signature": "Arb<string>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arb",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Eq",
            "signature": "Eq<string>",
            "description": "Eq trait implementation for strings.  Provides string equality comparison using strict equality (===). String comparison is case-sensitive and considers all Unicode characters.",
            "examples": [
              {
                "code": "import { Str } from '@wollybeard/kit'\n\nStr.Eq.is('hello', 'hello')     // true\nStr.Eq.is('hello', 'Hello')     // false (case-sensitive)\nStr.Eq.is('', '')               // true (empty strings)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<string>",
            "description": "Type trait implementation for strings.  Provides type guard for checking if a value is a string.",
            "examples": [
              {
                "code": "import { Str } from '@wollybeard/kit'\n\nStr.Type.is('hello')    // true\nStr.Type.is(123)        // false\nStr.Type.is(null)       // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 19
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Empty",
            "signature": "type Empty = ''",
            "description": "Type for an empty string.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 20
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isEmpty",
            "signature": "(value: string) => value is \"\"",
            "description": "Type guard to check if a string is empty.",
            "examples": [
              {
                "code": "isEmpty('') // true\nisEmpty('hello') // false\nisEmpty(' ') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.isEmpty from Effect instead",
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "defaultRender",
            "signature": "(value: string[]) => string",
            "description": "Default render function for string builders. Joins lines with newline characters.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 12
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Builder",
            "signature": "interface Builder {\n  /**\n   * Add lines to the builder.\n   * @param linesInput - Lines to add (null values are filtered out)\n   * @returns The builder instance for chaining\n   */\n  (...linesInput: LinesInput): Builder\n  /**\n   * Add content using template literal syntax.\n   * @param strings - Template string array\n   * @param values - Interpolated values\n   * @returns The builder instance for chaining\n   */\n  (strings: TemplateStringsArray, ...values: string[]): Builder\n  /**\n   * The internal state containing accumulated lines.\n   */\n  state: State\n  /**\n   * Render the accumulated lines into a single string.\n   * @returns The rendered string\n   */\n  render: () => string\n  /**\n   * Alias for render() to support string coercion.\n   * @returns The rendered string\n   */\n  toString(): string\n}",
            "description": "String builder interface for constructing multi-line strings. Supports both function call syntax and template literal syntax.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 19
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "LinesInput",
            "signature": "type LinesInput = (Line | null)[]",
            "description": "Input type for lines - allows null values which are filtered out.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 53
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Lines",
            "signature": "type Lines = Line[]",
            "description": "Array of line strings.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 59
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Line",
            "signature": "type Line = string",
            "description": "A single line of text.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "State",
            "signature": "interface State {\n  /**\n   * Accumulated lines.\n   */\n  lines: Lines\n}",
            "description": "Internal state of the string builder.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 71
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "RegExpMatchResult",
            "signature": "type RegExpMatchResult<$Matches extends Matches> =\n  & Omit<RegExpMatchArray, 'groups'>\n  & {\n      groups:\n        $Matches['groups'] extends readonly [MatchItem,... readonly MatchItem[]]\n          ? ArrMut.ReduceWithIntersection<ToGroupsProperties<$Matches['groups']>>\n          : undefined\n    }\n  & (\n      $Matches extends { indicies: readonly [MatchItem,... readonly MatchItem[]] }\n        ? [originalValue: string, ...$Matches['indicies']]\n        : [originalValue: string]\n    )",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "pattern",
            "signature": "<matches extends Matches>(pattern: RegExp) => Pattern<matches>",
            "description": "Create a typed pattern from a regular expression. Enables type-safe capture groups when used with match.",
            "examples": [
              {
                "code": "const p = pattern<{ groups: ['name', 'age'] }>(/(?<name>\\w+) is (?<age>\\d+)/)\nconst result = match('John is 25', p)\nif (Option.isSome(result)) {\n  console.log(result.value.groups.name) // 'John' (typed)\n  console.log(result.value.groups.age) // '25' (typed)\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Pattern Matching",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 53
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Matches",
            "signature": "type Matches = {\n  groups?: (string | undefined)[]\n  indicies?: (string | undefined)[]\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 58
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "match",
            "signature": "<matches extends Matches>(string: string, pattern: RegExp | Pattern<matches>) => Option<RegExpMatchResult<matches>>",
            "description": "Match a string against a pattern with type-safe results.",
            "examples": [
              {
                "code": "const result = match('hello world', /hello (\\w+)/)\nif (Option.isSome(result)) {\n  console.log(result.value[0]) // 'hello world'\n  console.log(result.value[1]) // 'world'\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Pattern Matching",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 80
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PatternInput",
            "signature": "type PatternInput = string | RegExp",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 90
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "isMatch",
            "signature": "(value: string, pattern: PatternInput) => boolean",
            "description": "Check if a string matches a pattern.",
            "examples": [
              {
                "code": "isMatch('hello', 'hello') // true\nisMatch('hello', /^h.*o$/) // true\nisMatch('world', 'hello') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 105
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isMatchOn",
            "signature": "(value: string) => (pattern: PatternInput) => boolean",
            "description": "Curried version of isMatch with value first.",
            "examples": [
              {
                "code": "const isHello = isMatchOn('hello')\nisHello('hello') // true\nisHello(/^h.*o$/) // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 124
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isMatchWith",
            "signature": "(pattern: PatternInput) => (value: string) => boolean",
            "description": "Curried version of isMatch with pattern first.",
            "examples": [
              {
                "code": "const matchesHello = isMatchWith('hello')\nmatchesHello('hello') // true\nmatchesHello('world') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 138
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isntMatch",
            "signature": "(pattern: PatternInput) => (value: string) => boolean",
            "description": "Check if a string does not match a pattern.",
            "examples": [
              {
                "code": "const notHello = isntMatch('hello')\nnotHello('world') // true\nnotHello('hello') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 152
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isntMatchOn",
            "signature": "(pattern: PatternInput) => (value: string) => boolean",
            "description": "Curried version of isntMatch with value first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 162
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isntMatchWith",
            "signature": "(value: string) => (pattern: PatternInput) => boolean",
            "description": "Curried version of isntMatch with pattern first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 170
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "PatternsInput",
            "signature": "type PatternsInput = ArrMut.Maybe<string | RegExp>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 174
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isMatchAny",
            "signature": "(value: string, patterns: PatternsInput) => boolean",
            "description": "Check if a string matches any of the provided patterns.",
            "examples": [
              {
                "code": "isMatchAny('hello', ['hello', 'world']) // true\nisMatchAny('hello', [/^h/, /o$/]) // true\nisMatchAny('foo', ['hello', 'world']) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 189
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isMatchAnyOn",
            "signature": "(value: string) => (patterns: PatternsInput) => boolean",
            "description": "Curried version of isMatchAny with value first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 200
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isMatchAnyWith",
            "signature": "(patterns: PatternsInput) => (value: string) => boolean",
            "description": "Curried version of isMatchAny with patterns first.",
            "examples": [
              {
                "code": "const matchesGreeting = isMatchAnyWith(['hello', 'hi', /^hey/])\nmatchesGreeting('hello') // true\nmatchesGreeting('hey there') // true\nmatchesGreeting('goodbye') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 215
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isNotMatchAny",
            "signature": "(patternOrPatterns: PatternsInput) => (value: string) => boolean",
            "description": "Check if a string does not match any of the provided patterns.",
            "examples": [
              {
                "code": "const notGreeting = isNotMatchAny(['hello', 'hi'])\nnotGreeting('goodbye') // true\nnotGreeting('hello') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 229
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isNotMatchAnyOn",
            "signature": "(patternOrPatterns: PatternsInput) => (value: string) => boolean",
            "description": "Curried version of isNotMatchAny with value first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 239
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isNotMatchAnyWith",
            "signature": "(value: string) => (patternOrPatterns: PatternsInput) => boolean",
            "description": "Curried version of isNotMatchAny with patterns first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 247
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "titlizeSlug",
            "signature": "(str: string) => string",
            "description": "Convert a URL slug to title case. Replaces URL path separators with spaces and converts to title case.",
            "examples": [
              {
                "code": "titlizeSlug('foo/bar/baz') // 'Foo Bar Baz'\ntitlizeSlug('the/quick/brown/fox') // 'The Quick Brown Fox'\ntitlizeSlug('hello-world') // 'Hello-World' (hyphens are preserved)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "misc",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensureEnd",
            "signature": "(string: string, ending: string) => string",
            "description": "Ensure a string ends with a specific ending, adding it if not present.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "misc",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 28
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "trim",
            "signature": "(value: string) => string",
            "description": "Remove whitespace from both ends of a string.",
            "examples": [
              {
                "code": "trim('  hello  ') // 'hello'\ntrim('\\n\\thello\\n\\t') // 'hello'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.trim from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeading",
            "signature": "(replacement: string, matcher: string, value: string) => string",
            "description": "Replace the leading occurrence of a matcher string with a replacement.",
            "examples": [
              {
                "code": "replaceLeading('$', '//', '// comment') // '$ comment'\nreplaceLeading('', 'www.', 'www.example.com') // 'example.com'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 52
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeadingWith",
            "signature": "(replacement: string) => (matcher: string) => (value: string) => string",
            "description": "Curried version of replaceLeading with replacement first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 63
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeadingOn",
            "signature": "(value: string) => (replacement: string) => (matcher: string) => string",
            "description": "Curried version of replaceLeading with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 73
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "stripLeading",
            "signature": "(matcher: string) => (value: string) => string",
            "description": "Remove the leading occurrence of a matcher string. Alias for replaceLeadingWith('').",
            "examples": [
              {
                "code": "const removePrefix = stripLeading('//')\nremovePrefix('// comment') // ' comment'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 89
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "replace",
            "signature": "(replacement: string, matcher: PatternsInput, value: string) => string",
            "description": "Replace all occurrences of patterns with a replacement string.",
            "examples": [
              {
                "code": "replace('_', ' ', 'hello world') // 'hello_world'\nreplace('X', /[aeiou]/g, 'hello') // 'hXllX'\nreplace('-', [' ', '_'], 'hello world_test') // 'hello-world-test'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.replace or String.replaceAll from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 114
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceWith",
            "signature": "(replacement: string) => (matcher: PatternsInput) => (value: string) => string",
            "description": "Curried version of replace with replacement first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 127
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceOn",
            "signature": "(value: string) => (replacement: string) => (matcher: PatternsInput) => string",
            "description": "Curried version of replace with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 137
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "append",
            "signature": "(value1: string, value2: string) => string",
            "description": "Append a string to another string.",
            "examples": [
              {
                "code": "append('hello', ' world') // 'hello world'\nappend('foo', 'bar') // 'foobar'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.concat from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 162
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "appendOn",
            "signature": "(value1: string) => (value2: string) => string",
            "description": "Curried version of append with value1 first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 172
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "appendWith",
            "signature": "(value2: string) => (value1: string) => string",
            "description": "Curried version of append with value2 first.",
            "examples": [
              {
                "code": "const addWorld = appendWith(' world')\naddWorld('hello') // 'hello world'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 185
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "prepend",
            "signature": "(value1: string, value2: string) => string",
            "description": "Prepend a string to another string.",
            "examples": [
              {
                "code": "prepend('hello ', 'world') // 'hello world'\nprepend('pre', 'fix') // 'prefix'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.concat from Effect instead (with arguments swapped)",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 202
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "prependOn",
            "signature": "(value1: string) => (value2: string) => string",
            "description": "Curried version of prepend with value1 first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 212
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "prependWith",
            "signature": "(value2: string) => (value1: string) => string",
            "description": "Curried version of prepend with value2 first.",
            "examples": [
              {
                "code": "const toWorld = prependWith('world')\ntoWorld('hello ') // 'hello world'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 225
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "repeat",
            "signature": "(value: string, count: number) => string",
            "description": "Repeat a string a specified number of times.",
            "examples": [
              {
                "code": "repeat('a', 3) // 'aaa'\nrepeat('hello', 2) // 'hellohello'\nrepeat('-', 10) // '----------'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.repeat from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 249
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "repeatOn",
            "signature": "(value: string) => (count: number) => string",
            "description": "Curried version of repeat with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 259
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "repeatWith",
            "signature": "(count: number) => (value: string) => string",
            "description": "Curried version of repeat with count first.",
            "examples": [
              {
                "code": "const triple = repeatWith(3)\ntriple('ha') // 'hahaha'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 272
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurrounding",
            "signature": "(str: string, target: string) => string",
            "description": "Remove all occurrences of a target character from the beginning and end of a string.",
            "examples": [
              {
                "code": "removeSurrounding('   hello   ', ' ') // 'hello'\nremoveSurrounding('***test***', '*') // 'test'\nremoveSurrounding('aaa', 'a') // ''",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 295
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "removeSurroundingOn",
            "signature": "(str: string) => (target: string) => string",
            "description": "Curried version of removeSurrounding with str first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 321
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingWith",
            "signature": "(target: string) => (str: string) => string",
            "description": "Curried version of removeSurrounding with target first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 329
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "truncate",
            "signature": "(str: string, maxLength?: number) => string",
            "description": "Truncate a string to a maximum length, adding ellipsis if truncated.",
            "examples": [
              {
                "code": "truncate('hello world', 8) // 'hello...'\ntruncate('short', 10) // 'short'\ntruncate('very long text that needs truncating') // 'very long text that needs truncating...' (if > 80 chars)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 352
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "truncateOn",
            "signature": "(str: string) => (maxLength?: number | undefined) => string",
            "description": "Curried version of truncate with str first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 366
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "truncateWith",
            "signature": "(maxLength?: number | undefined) => (str: string) => string",
            "description": "Curried version of truncate with maxLength first.",
            "examples": [
              {
                "code": "const truncate10 = truncateWith(10)\ntruncate10('hello world') // 'hello w...'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 379
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "strip",
            "signature": "(matcher: PatternsInput) => (value: string) => string",
            "description": "Remove all occurrences of patterns from a string. Alias for replaceWith('').",
            "examples": [
              {
                "code": "const removeVowels = strip(/[aeiou]/g)\nremoveVowels('hello world') // 'hll wrld'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 401
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingSpaceRegular",
            "signature": "(str: string) => string",
            "description": "Remove regular spaces from the beginning and end of a string. Pre-configured removeSurroundingWith for regular spaces.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 410
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingSpaceNoBreak",
            "signature": "(str: string) => string",
            "description": "Remove non-breaking spaces from the beginning and end of a string. Pre-configured removeSurroundingWith for non-breaking spaces.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 419
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "split",
            "signature": "(value: string, separator: string) => string[]",
            "description": "Split a string into an array of substrings using a separator.",
            "examples": [
              {
                "code": "split('a,b,c', ',') // ['a', 'b', 'c']\nsplit('hello world', ' ') // ['hello', 'world']\nsplit('', ',') // []",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.split from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "splitOn",
            "signature": "(value: string) => (separator: string) => string[]",
            "description": "Curried version of split with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 29
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "splitWith",
            "signature": "(separator: string) => (value: string) => string[]",
            "description": "Curried version of split with separator first.",
            "examples": [
              {
                "code": "const splitByComma = splitWith(',')\nsplitByComma('a,b,c') // ['a', 'b', 'c']",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 42
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "join",
            "signature": "(value: string[], separator: string) => string",
            "description": "Join an array of strings into a single string with a separator.",
            "examples": [
              {
                "code": "join(['a', 'b', 'c'], ',') // 'a,b,c'\njoin(['hello', 'world'], ' ') // 'hello world'\njoin([], ',') // ''",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use Array.join from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 58
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "joinOn",
            "signature": "(value: string[]) => (separator: string) => string",
            "description": "Curried version of join with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 68
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "joinWith",
            "signature": "(separator: string) => (value: string[]) => string",
            "description": "Curried version of join with separator first.",
            "examples": [
              {
                "code": "const joinWithComma = joinWith(',')\njoinWithComma(['a', 'b', 'c']) // 'a,b,c'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 81
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "merge",
            "signature": "(string1: string, string2: string) => string",
            "description": "Merge two strings together (concatenate).",
            "examples": [
              {
                "code": "merge('hello', ' world') // 'hello world'\nmerge('foo', 'bar') // 'foobar'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.concat from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 96
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mergeOn",
            "signature": "(string1: string) => (string2: string) => string",
            "description": "Curried version of merge with string1 first.",
            "examples": [
              {
                "code": "const mergeWithHello = mergeOn('hello')\nmergeWithHello(' world') // 'hello world'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 111
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "table",
            "signature": "(input: { data: Record<string, string>; separator?: string | false | undefined; separatorAlignment?: boolean; }) => string",
            "description": "Format a key-value object as an aligned table string.",
            "examples": [
              {
                "code": "table({\n  data: { name: 'John', age: '25', city: 'NYC' }\n})\n// Returns:\n// name  John\n// age   25\n// city  NYC\n\ntable({\n  data: { foo: 'bar', hello: 'world' },\n  separator: ' = ',\n  separatorAlignment: false\n})\n// Returns:\n// foo =   bar\n// hello = world",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "table",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 32
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "interpolate",
            "signature": "(template: string) => (args: TemplateArgs) => string",
            "description": "Interpolate variables into a template string using $variable syntax.",
            "examples": [
              {
                "code": "const greeting = interpolate('Hello ${name}, you are ${age} years old')\ngreeting({ name: 'John', age: 25 }) // 'Hello John, you are 25 years old'\n\nconst template = interpolate('${greeting} ${name}!')\ntemplate({ greeting: 'Hi', name: 'Alice' }) // 'Hi Alice!'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Template",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "template",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "templateVariablePattern",
            "signature": "RegExp",
            "description": "Regular expression pattern to match template variables in $variable format. Captures the variable name inside the braces.",
            "examples": [],
            "category": "Template",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "template",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 30
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "TemplateArgs",
            "signature": "type TemplateArgs = Record<string, Json.Value>",
            "description": "Arguments object for template interpolation. Maps variable names to their JSON-serializable values.",
            "examples": [],
            "category": "Template",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "template",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 37
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isTemplateStringsArray",
            "signature": "(args: unknown) => args is TemplateStringsArray",
            "description": "Type guard to check if a value is a TemplateStringsArray. Used to detect when a function is called as a tagged template literal.",
            "examples": [
              {
                "code": "function tag(...args: unknown[]) {\n  if (isTemplateStringsArray(args)) {\n    // Called as tag`template`\n  } else {\n    // Called as tag()\n  }\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Template",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "template",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 56
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "defaultIndentSize",
            "signature": "2",
            "description": "Default indentation size in characters.",
            "examples": [],
            "category": "Text Formatting  2",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "defaultIndentCharacter",
            "signature": "\"\"",
            "description": "Default character used for indentation (non-breaking space).",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "defaultLineSeparator",
            "signature": "\"\\n\"",
            "description": "Default line separator character (newline).",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 23
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "lines",
            "signature": "(value: string) => string[]",
            "description": "Split text into an array of lines. Pre-configured splitWith using newline separator.",
            "examples": [
              {
                "code": "lines('hello\\nworld\\n!') // ['hello', 'world', '!']\nlines('single line') // ['single line']",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 39
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "unlines",
            "signature": "(value: string[]) => string",
            "description": "Join an array of lines into text. Pre-configured joinWith using newline separator.",
            "examples": [
              {
                "code": "unlines(['hello', 'world', '!']) // 'hello\\nworld\\n!'\nunlines(['single line']) // 'single line'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 53
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "indent",
            "signature": "(text: string, size?: number | undefined) => string",
            "description": "Indent each line of text by a specified number of spaces.",
            "examples": [
              {
                "code": "indent('hello\\nworld') // '  hello\\n  world'\nindent('line1\\nline2', 4) // '    line1\\n    line2'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 69
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "indentOn",
            "signature": "(text: string) => (size?: number | undefined) => string",
            "description": "Curried version of indent with text first.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 80
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "indentWith",
            "signature": "(size?: number | undefined) => (text: string) => string",
            "description": "Curried version of indent with size first.",
            "examples": [
              {
                "code": "const indent4 = indentWith(4)\nindent4('hello\\nworld') // '    hello\\n    world'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 93
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "stripIndent",
            "signature": "(text: string) => string",
            "description": "Remove common leading whitespace from all lines. Finds the minimum indentation across all non-empty lines and removes that amount from every line. This is useful for dedenting code blocks or template strings while preserving relative indentation.",
            "examples": [
              {
                "code": "stripIndent('    line1\\n      line2\\n    line3')\n// 'line1\\n  line2\\nline3'\n\nstripIndent('  code\\n    nested\\n  code')\n// 'code\\n  nested\\ncode'\n\n// Empty lines are ignored when calculating minimum indent\nstripIndent('    line1\\n\\n    line2')\n// 'line1\\n\\nline2'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 115
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "EndsWith",
            "signature": "type EndsWith<S extends string, T extends string> = S extends `${string}${T}` ? true : false",
            "description": "Check if a string ends with a specific suffix.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StartsWith",
            "signature": "type StartsWith<S extends string, T extends string> = S extends `${T}${string}` ? true : false",
            "description": "Check if a string starts with a specific prefix.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 19
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "LastSegment",
            "signature": "type LastSegment<S extends string> = S extends `${string}/${infer Rest}` ? LastSegment<Rest>\n  : S",
            "description": "Extract the last segment from a path-like string (after the last '/').",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RemoveTrailingSlash",
            "signature": "type RemoveTrailingSlash<S extends string> = S extends `${infer Rest}/` ? Rest extends '' ? '/' : Rest\n  : S",
            "description": "Remove trailing slash from a string.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 32
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Split",
            "signature": "type Split<S extends string, D extends string, Acc extends string[] = []> = S extends '' ? Acc\n  : S extends `${infer Segment}${D}${infer Rest}` ? Segment extends '' ? Split<Rest, D, Acc>\n    : Segment extends '.' ? Split<Rest, D, Acc>\n    : Split<Rest, D, [...Acc, Segment]>\n  : S extends '.' ? Acc\n  : [...Acc, S]",
            "description": "Split a string by a delimiter, filtering out empty segments and '.' segments. This is useful for path-like strings.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 40
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Contains",
            "signature": "type Contains<S extends string, C extends string> = S extends `${string}${C}${string}` ? true : false",
            "description": "Check if string contains a character.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 51
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "LiteralOnly",
            "signature": "type LiteralOnly<\n  T extends string,\n  $ErrorMessage extends string = 'Expected a literal string',\n> = string extends T ? Ts.StaticError<\n    $ErrorMessage,\n    { ReceivedType: T },\n    'Use a string literal instead of string type'\n  >\n  : T",
            "description": "Constraint that only accepts literal strings. Returns StaticError for non-literal string type with customizable error message.",
            "examples": [],
            "category": "Type-Level Utilities  T - The string type to check  $ErrorMessage - Custom error message to display when T is not a literal",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 60
            },
            "_tag": "type",
            "type": "type-alias"
          }
        ],
        "category": "Core Data Structures"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./test",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "test"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Enhanced test utilities for table-driven testing with Vitest.  Provides builder API and type-safe utilities for parameterized tests with built-in support for todo, skip, and only cases.",
        "category": "Development",
        "exports": [
          {
            "_tag": "value",
            "name": "Matchers",
            "type": "namespace",
            "signature": "export * as Matchers",
            "description": "Custom Vitest matchers for Effect Schema and equivalence testing.",
            "examples": [],
            "category": "Assertions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "test"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 6
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "test",
                    "matchers"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": []
            }
          },
          {
            "name": "property",
            "signature": "<Ts extends [unknown, ...unknown[]]>(...args: [description: string, ...arbitraries: { [K in keyof Ts]: Arbitrary<Ts[K]>; }, predicate: (...args: Ts) => boolean | void]) => void",
            "description": "Create a property-based test using fast-check within vitest.   Ts - Tuple type of the arbitrary values.",
            "examples": [
              {
                "code": "// test that array reverse twice returns original\nproperty(\n  'reversing array twice returns original',\n  fc.array(fc.integer()),\n  (arr) => {\n    const reversed = arr.slice().reverse()\n    const reversedTwice = reversed.slice().reverse()\n    expect(reversedTwice).toEqual(arr)\n  }\n)\n\n// test with multiple arbitraries\nproperty(\n  'addition is commutative',\n  fc.integer(),\n  fc.integer(),\n  (a, b) => {\n    expect(a + b).toBe(b + a)\n  }\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Property Testing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "test"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "property",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 40
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "on",
            "signature": "function on<$fn extends Fn.AnyAny>($fn: $fn): TestBuilder<UpdateState<BuilderTypeStateEmpty, { fn: $fn; }>>",
            "description": "Creates a test table builder for testing a specific function.  This is a shorthand for describe().on(fn) when you don't need a describe block. Types are automatically inferred from the function signature, making it ideal for quick function testing with minimal boilerplate.  ## Case Formats  Test cases can be specified in multiple formats:  **Tuple Format** (most common): - [[arg1, arg2], expected] - Test with expected output - ['name', [arg1, arg2], expected] - Named test case - [[arg1, arg2]] - Snapshot test (no expected value)  **Object Format** (more verbose but clearer): - { input: [arg1, arg2], output: expected } - { input: [arg1, arg2], output: expected, skip: true, comment: 'name' } - { todo: 'Not implemented yet', comment: 'name' }",
            "examples": [
              {
                "code": "// Basic function testing\nTest.on(add)\n  .cases(\n    [[2, 3], 5],                    // add(2, 3) === 5\n    [[0, 0], 0],                    // add(0, 0) === 0\n    [[-1, 1], 0]                    // add(-1, 1) === 0\n  )\n  .test()\n\n// Using different case formats\nTest.on(multiply)\n  .cases(\n    [[2, 3], 6],                              // Tuple format\n    ['zero case', [5, 0], 0],                 // Named tuple\n    { input: [-2, 3], output: -6 },           // Object format\n    { input: [100, 100], output: 10000, comment: 'large numbers' }\n  )\n  .test()\n\n// Custom assertions\nTest.on(divide)\n  .cases([[10, 2], 5], [[10, 0], Infinity])\n  .test(({ result, output }) => {\n    if (output === Infinity) {\n      expect(result).toBe(Infinity)\n    } else {\n      expect(result).toBeCloseTo(output, 2)\n    }\n  })\n\n// Output transformation - build full expectations from partials\nTest.on(createUser)\n  .onOutput((partial, context) => ({ ...defaultUser, name: context.input[0], ...partial }))\n  .cases(\n    [['Alice'], { role: 'admin' }],           // Only specify differences\n    [['Bob'], { role: 'user', age: 30 }]\n  )\n  .test()",
                "title": "## Snapshot Mode with Error Handling",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": " GIVEN ARGUMENTS\n-1\n THEN THROWS\nError: Value must be positive\n",
                "title": "Snapshot format shows arguments and results clearly:",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Test Builders",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "test",
                    "table"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "constructors",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 119
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "describe",
            "signature": "function describe(description?: string): TestBuilderEmpty",
            "description": "Creates a test table builder for property-based and example-based testing.  **CRITICAL**: Each call to Test.describe() creates a SEPARATE, INDEPENDENT test block. The builder is NOT reusable - you CANNOT chain multiple .cases() or .describeInputs() calls to add test cases to the same describe block. Each builder must end with .test().  Test tables allow you to define multiple test cases with inputs and expected outputs, reducing boilerplate and making tests more maintainable. The builder supports two modes:  ## Modes  **Function Mode** - Test a specific function with .on(fn): - Types are automatically inferred from the function signature - Test cases specify function arguments and expected return values - Default assertion compares actual vs expected using Effect's equality  **Generic Mode** - Define custom types with .i<T> and .o<T>: - Explicitly specify input and output types - Provide custom test logic to validate cases - Useful for testing complex behaviors beyond simple function calls  ## Features  **Nested Describes** - Use  >  separator to create nested describe blocks: - Test.describe('Parent > Child') creates describe('Parent', () => describe('Child', ...)) - Multiple SEPARATE Test.describe() calls with the same prefix share the outer describe block - Supports any depth: 'API > Users > Create' creates three levels  **Matrix Testing** - Use .matrix() to run cases across parameter combinations: - Generates cartesian product of all matrix value arrays - Each test case runs once for each combination - Matrix values available as matrix in test context - Combines with nested describes for organized test suites",
            "examples": [
              {
                "code": "//  WRONG - Trying to chain test cases (DOES NOT WORK)\nTest.describe('decodeSync > basic')\n  .on(decodeSync)\n  .cases([['1.2.3']])\n  .describeInputs('union', [['1.2.3-beta']])  //  This creates a NESTED describe, not sibling!\n  .test()\n\n//  CORRECT - Separate Test.describe() calls for separate test groups\nTest.describe('decodeSync > basic')\n  .on(decodeSync)\n  .cases([['1.2.3']], [['invalid']])\n  .test()\n\nTest.describe('decodeSync > union')  // Shares 'decodeSync' parent describe\n  .on(decodeSync)\n  .cases([['1.2.3-beta']], [['1.2.3+build']])\n  .test()\n\n// Function mode - testing a math function\nTest.describe('addition')\n  .on(add)\n  .cases(\n    [[2, 3], 5],                          // add(2, 3) should return 5\n    ['negative', [-1, -2], -3],           // Named test case\n    [[0, 0], 0]                           // Edge case\n  )\n  .test()  // Uses default assertion (Effect's Equal.equals)\n\n// Generic mode - custom validation logic\nTest.describe('email validation')\n  .inputType<string>()\n  .outputType<boolean>()\n  .cases(\n    ['user@example.com', true],\n    ['invalid.com', false],\n    ['', false]\n  )\n  .test(({ input, output }) => {\n    const result = isValidEmail(input)\n    expect(result).toBe(output)\n  })\n\n// Nested describe blocks with ' > ' separator\nTest.describe('Transform > String')  // Creates nested: Transform -> String\n  .inputType<string>()\n  .outputType<string>()\n  .cases(['hello', 'HELLO'])\n  .test(({ input, output }) => {\n    expect(input.toUpperCase()).toBe(output)\n  })\n\nTest.describe('Transform > Number')  // SEPARATE call - Shares 'Transform' parent describe\n  .inputType<number>()\n  .outputType<number>()\n  .cases([42, 42])\n  .test(({ input, output }) => {\n    expect(input).toBe(output)\n  })\n\n// Matrix testing - runs each case for all parameter combinations\nTest.describe('string transform')\n  .inputType<string>()\n  .outputType<string>()\n  .matrix({\n    uppercase: [true, false],\n    prefix: ['', 'pre_'],\n  })\n  .cases(\n    ['hello', 'hello'],\n    ['world', 'world']\n  )\n  .test(({ input, output, matrix }) => {\n    // Runs 4 times (2 cases  2 uppercase  2 prefix = 8 tests)\n    let result = input\n    if (matrix.prefix) result = matrix.prefix + result\n    if (matrix.uppercase) result = result.toUpperCase()\n\n    let expected = output\n    if (matrix.prefix) expected = matrix.prefix + expected\n    if (matrix.uppercase) expected = expected.toUpperCase()\n\n    expect(result).toBe(expected)\n  })",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Test Builders",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "test",
                    "table"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "constructors",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 259
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./ts",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "ts"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "TypeScript type utilities and type-level programming helpers.  Provides comprehensive type-level utilities including type printing, static errors, type guards, simplification utilities, exact type matching, and type testing tools. Features conditional types, type transformations, and type-level assertions for advanced TypeScript patterns.",
        "exports": [
          {
            "_tag": "value",
            "name": "Kind",
            "type": "namespace",
            "signature": "export * as Kind",
            "description": "Higher-kinded type utilities for TypeScript.  Provides type-level functions and utilities for simulating higher-kinded types in TypeScript, enabling more advanced type-level programming patterns.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "kind",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Higher-kinded type utilities for TypeScript.  Provides type-level functions and utilities for simulating higher-kinded types in TypeScript, enabling more advanced type-level programming patterns.",
              "exports": [
                {
                  "name": "Apply",
                  "signature": "type Apply<$Kind, $Args> =\n  // @ts-expect-error - Intentional type manipulation for kind simulation\n  ($Kind & { parameters: $Args })['return']",
                  "description": "Higher-kinded type utilities for TypeScript.  Provides type-level functions and utilities for simulating higher-kinded types in TypeScript, enabling more advanced type-level programming patterns.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 32
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Kind",
                  "signature": "interface Kind<$Params = unknown, $Return = unknown> {\n  readonly parameters: $Params\n  readonly return: $Return\n}",
                  "description": "Define a kind (higher-kinded type) function interface.  Provides a standard structure for defining type-level functions that can be applied using the Apply utility.   $Params - The parameter types this kind accepts  $Return - The return type this kind produces",
                  "examples": [
                    {
                      "code": "interface BoxOf extends Kind<[unknown], Box<any>> {\n  return: Box<this['parameters'][0]>\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 52
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "Parameters",
                  "signature": "type Parameters<$Kind> = $Kind extends Kind<infer P, any> ? P : never",
                  "description": "Extract the parameter types from a kind.   $Kind - The kind to extract parameters from",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 62
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Return",
                  "signature": "type Return<$Kind> = $Kind extends Kind<any, infer R> ? R : never",
                  "description": "Extract the return type from a kind.   $Kind - The kind to extract return type from",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 69
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Identity",
                  "signature": "interface Identity extends Kind {\n  // @ts-expect-error\n  return: this['parameters'][0]\n}",
                  "description": "Create a type-level identity function.  Returns the input type unchanged. Useful as a default or placeholder in kind compositions.",
                  "examples": [
                    {
                      "code": "type Same = Kind.Apply<Kind.Identity, [string]> // string",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 82
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "Const",
                  "signature": "interface Const<$Const> extends Kind {\n  return: $Const\n}",
                  "description": "Create a type-level constant function.  Always returns the same type regardless of input.   $Const - The constant type to always return",
                  "examples": [
                    {
                      "code": "type AlwaysString = Kind.Apply<Kind.Const<string>, [number]> // string",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 99
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "PrivateKindReturn",
                  "signature": "typeof PrivateKindReturn",
                  "description": "Private symbol for storing kind return type.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 114
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "PrivateKindParameters",
                  "signature": "typeof PrivateKindParameters",
                  "description": "Private symbol for storing kind parameters.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 120
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "Private",
                  "signature": "interface Private {\n  [PrivateKindReturn]: unknown\n  [PrivateKindParameters]: unknown\n}",
                  "description": "Private kind interface using symbols instead of string keys.  This provides a more secure way to define higher-kinded types as the symbols cannot be accessed outside the module.",
                  "examples": [
                    {
                      "code": "interface BoxKind extends PrivateKind {\n  // @ts-expect-error\n  [PRIVATE_KIND_RETURN]: Box<this[PRIVATE_KIND_PARAMETERS][0]>\n  [PRIVATE_KIND_PARAMETERS]: unknown\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 138
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "PrivateApply",
                  "signature": "type PrivateApply<$Kind extends Private, $Args> = ($Kind & { [PrivateKindParameters]: $Args })[PrivateKindReturn]",
                  "description": "Apply arguments to a private kind.   $Kind - The private kind to apply  $Args - The arguments to apply",
                  "examples": [
                    {
                      "code": "type BoxOfString = PrivateKindApply<BoxKind, [string]> // Box<string>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 154
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "MaybePrivateApplyOr",
                  "signature": "type MaybePrivateApplyOr<$MaybeKind, $Args, $Or> =\n  $MaybeKind extends Private\n    ? PrivateApply<$MaybeKind, $Args>\n    : $Or",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 157
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsPrivateKind",
                  "signature": "type IsPrivateKind<T> = T extends Private ? true : false",
                  "description": "Check if a type is a private kind.   T - The type to check",
                  "examples": [
                    {
                      "code": "type Test1 = IsPrivateKind<BoxKind> // true\ntype Test2 = IsPrivateKind<string> // false",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 173
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Test",
            "type": "namespace",
            "signature": "export * as Test",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "test",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "exact",
                  "signature": "type exact<$Expected, $Actual> = (<T>() => T extends $Actual ? 1 : 2) extends\n  (<T>() => T extends $Expected ? 1 : 2) ? true\n  // If structural equality fails, check if bidirectional assignability passes\n  : $Actual extends $Expected ? $Expected extends $Actual ? StaticErrorAssertion<\n        'Types are mutually assignable but not structurally equal',\n        $Expected,\n        $Actual,\n        'Use bid() for mutual assignability OR apply Simplify<T> to normalize types'\n      >\n    : StaticErrorAssertion<'Types are not structurally equal', $Expected, $Actual>\n  : StaticErrorAssertion<'Types are not structurally equal', $Expected, $Actual>",
                  "description": "Assert that two types are exactly equal (structurally).  Uses a conditional type inference trick to check exact structural equality, correctly handling any, never, and unknown edge cases.  This checks for structural equality - types must have the same structure, not just compute to the same result. For bidirectional extends, use bid.  When exact equality fails but bidirectional assignability passes, provides a helpful tip about using bid or applying Simplify from #ts.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.exact<string, string>,           //  Pass\n  Ts.Test.exact<string | number, string>,  //  Fail - Type error\n  Ts.Test.exact<{ a: 1 }, { a: 1 }>,       //  Pass\n  Ts.Test.exact<any, unknown>,             //  Fail - Type error\n  Ts.Test.exact<1 | 2, 2 | 1>              //  Fail with tip - types are mutually assignable but not structurally equal\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 65
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "bid",
                  "signature": "type bid<$Expected, $Actual> = $Actual extends $Expected ? $Expected extends $Actual\n    // Both directions pass - check if exact would also pass\n    ? (<T>() => T extends $Actual ? 1 : 2) extends (<T>() => T extends $Expected ? 1 : 2)\n      // Exact also passes - check if linting is enabled\n      ? GetTestSetting<'lintBidForExactPossibility'> extends true ? StaticErrorAssertion<\n          'Types are structurally equal',\n          $Expected,\n          $Actual,\n          'Use exact() instead - bid() is only needed when types are mutually assignable but not structurally equal'\n        >\n      : true // Linting disabled, allow it\n    : true // Only bid passes (not exact) - this is correct usage\n  : StaticErrorAssertion<\n    'Types are not bidirectionally assignable (Expected does not extend Actual)',\n    $Expected,\n    $Actual\n  >\n  : StaticErrorAssertion<\n    'Types are not bidirectionally assignable (Actual does not extend Expected)',\n    $Expected,\n    $Actual\n  >",
                  "description": "Assert that two types are bidirectionally assignable (mutually assignable).  This checks that types are mutually assignable (A extends B and B extends A), which means they compute to the same result even if their structure differs.  Use this when you care about semantic equality rather than structural equality. For strict structural equality, use exact.  **Linting:** When KitLibrarySettings.Ts.Test.Settings.lintBidForExactPossibility is true, this will show an error if exact would work, encouraging use of the stricter assertion. See module documentation for configuration example.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.bid<string, string>,      //  Pass (or error if linting enabled - should use exact)\n  Ts.Test.bid<1 | 2, 2 | 1>,        //  Pass (or error if linting enabled - should use exact)\n  Ts.Test.bid<string & {}, string>, //  Pass - both compute to string (exact would fail)\n  Ts.Test.bid<string, number>       //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 132
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "sub",
                  "signature": "type sub<$Expected, $Actual> = $Actual extends $Expected ? true\n  : StaticErrorAssertion<\n    'Actual type does not extend expected type',\n    $Expected,\n    $Actual\n  >",
                  "description": "Assert that a type extends (is a subtype of) another type.  Equivalent to TypeScript's extends keyword: checks if $Actual extends $Expected. This is useful for validating type relationships and narrowing.  For exact type equality (not just subtyping), use exact instead.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.sub<string, 'hello'>,           //  Pass - 'hello' extends string\n  Ts.Test.sub<'hello', string>,           //  Fail - string doesn't extend 'hello'\n  Ts.Test.sub<{ a: 1 }, { a: 1; b: 2 }>,  //  Pass - more specific extends less specific\n  Ts.Test.sub<object, { a: 1 }>           //  Pass - { a: 1 } extends object\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 205
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNoExcess",
                  "signature": "type subNoExcess<$Expected, $Actual> = $Actual extends $Expected\n  ? Exclude<keyof $Actual, keyof $Expected> extends never ? true\n  : StaticErrorAssertion<\n    'Type has excess properties not present in expected type',\n    $Expected,\n    $Actual\n  >\n  : StaticErrorAssertion<\n    'Actual type does not extend expected type',\n    $Expected,\n    $Actual\n  >",
                  "description": "Assert that a type extends the expected type AND has no excess properties.  Similar to sub but also rejects excess properties beyond those defined in the expected type. This catches common bugs like typos in configuration objects or accidentally passing extra properties.  This is particularly useful for: - Validating configuration objects - Checking function parameters that shouldn't have extra properties - Testing that types don't have unexpected fields",
                  "examples": [
                    {
                      "code": "type Config = { id: boolean; name?: string }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.subNoExcess<Config, { id: true }>,               //  Pass\n  Ts.Test.subNoExcess<Config, { id: true; name: 'test' }>, //  Pass - optional included\n  Ts.Test.subNoExcess<Config, { id: true; $skip: true }>,  //  Fail - excess property\n  Ts.Test.subNoExcess<Config, { id: 'wrong' }>             //  Fail - wrong type\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Compare with .sub (allows excess):\ntype Q = { id: boolean }\n\ntype T1 = Ts.Test.sub<Q, { id: true; extra: 1 }>         //  Pass (sub allows excess)\ntype T2 = Ts.Test.subNoExcess<Q, { id: true; extra: 1 }> //  Fail (subNoExcess rejects)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 288
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNot",
                  "signature": "type subNot<$NotExpected, $Actual> = $Actual extends $NotExpected ? StaticErrorAssertion<\n    'Actual type extends type it should not extend',\n    $NotExpected,\n    $Actual\n  >\n  : true",
                  "description": "Assert that a type does NOT extend another type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.subNot<number, string>,  //  Pass\n  Ts.Test.subNot<string, 'hello'>  //  Fail - 'hello' extends string\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 368
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalNever",
                  "signature": "type equalNever<$Actual> = [$Actual] extends [never] ? true\n  : StaticErrorAssertion<'Type is not never', never, $Actual>",
                  "description": "Assert that a type is exactly never.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalNever<never>,  //  Pass\n  Ts.Test.equalNever<string>  //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 420
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalAny",
                  "signature": "type equalAny<$Actual> = 0 extends 1 & $Actual ? true\n  : StaticErrorAssertion<'Type is not any', never, $Actual>",
                  "description": "Assert that a type is exactly any.  Uses the 0 extends 1 & T trick to detect any.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalAny<any>,      //  Pass\n  Ts.Test.equalAny<unknown>,  //  Fail - Type error\n  Ts.Test.equalAny<string>    //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 458
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalUnknown",
                  "signature": "type equalUnknown<$Actual> = unknown extends $Actual ? (0 extends 1 & $Actual ? StaticErrorAssertion<\n      'Type is any, not unknown',\n      unknown,\n      $Actual\n    >\n    : true)\n  : StaticErrorAssertion<'Type is not unknown', never, $Actual>",
                  "description": "Assert that a type is exactly unknown.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalUnknown<unknown>,  //  Pass\n  Ts.Test.equalUnknown<any>,      //  Fail - Type error\n  Ts.Test.equalUnknown<string>    //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 494
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalEmptyObject",
                  "signature": "type equalEmptyObject<$Actual extends object> = Obj.IsEmpty<$Actual> extends true ? true\n  : StaticErrorAssertion<'Type is not an empty object (has keys)', Obj.Empty, $Actual>",
                  "description": "Assert that a type is an empty object (no properties).  Uses Obj.IsEmpty from kit to check if the object has no keys. Note: {} in TypeScript means \"any non-nullish value\", not an empty object.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalEmptyObject<Record<string, never>>,  //  Pass\n  Ts.Test.equalEmptyObject<{}>,                      //  Fail - {} is not empty\n  Ts.Test.equalEmptyObject<{ a: 1 }>                 //  Fail - has properties\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 543
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "sup",
                  "signature": "type sup<$Supertype, $Actual> = $Actual extends $Supertype ? true\n  : StaticErrorAssertion<'Actual type does not extend expected supertype', $Supertype, $Actual>",
                  "description": "Assert that a type is a supertype of (i.e., extended by) another type.  Equivalent to TypeScript's extends keyword: checks if $Actual extends $Supertype. This is the reverse parameter order of sub - the expected type is the supertype. Less commonly used than sub - most cases should use sub with reversed parameters for clarity.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.sup<object, { a: 1 }>,  //  Pass - { a: 1 } extends object (object is supertype)\n  Ts.Test.sup<{ a: 1 }, object>,  //  Fail - object doesn't extend { a: 1 }\n  Ts.Test.sup<string, 'hello'>    //  Pass - 'hello' extends string (string is supertype)\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 593
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "parameters",
                  "signature": "type parameters<$Expected extends readonly any[], $Function extends (...args: any[]) => any> = sub<\n  $Expected,\n  Parameters<$Function>\n>",
                  "description": "Assert that a function's parameters match the expected type. Combines Parameters<typeof fn> with assertion in one step.",
                  "examples": [
                    {
                      "code": "function add(a: number, b: number): number { return a + b }\ntype _ = Ts.Test.Cases<\n  Ts.Test.parameters<[number, number], typeof add>,  //  Pass\n  Ts.Test.parameters<[string, string], typeof add>   //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 643
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "promise",
                  "signature": "type promise<$Type, $Actual> = $Actual extends Promise<$Type> ? true\n  : StaticErrorAssertion<\n    'Type is not a Promise with expected element type',\n    Promise<$Type>,\n    $Actual\n  >",
                  "description": "Assert that a type is a Promise with specific element type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.promise<number, Promise<number>>,  //  Pass\n  Ts.Test.promise<string, Promise<number>>,  //  Fail - Type error\n  Ts.Test.promise<number, number>            //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 686
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "promiseNot",
                  "signature": "type promiseNot<$Actual> = $Actual extends Promise<any> ? StaticErrorAssertion<\n    'Type is a Promise but should not be',\n    never,\n    $Actual\n  >\n  : true",
                  "description": "Assert that a type is NOT a Promise.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.promiseNot<number>,          //  Pass\n  Ts.Test.promiseNot<Promise<number>>  //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 726
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "array",
                  "signature": "type array<$ElementType, $Actual> = $Actual extends $ElementType[] ? true\n  : StaticErrorAssertion<\n    'Type is not an array with expected element type',\n    $ElementType[],\n    $Actual\n  >",
                  "description": "Assert that a type is an array with specific element type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.array<string, string[]>,  //  Pass\n  Ts.Test.array<number, string[]>,  //  Fail - Type error\n  Ts.Test.array<string, string>     //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 765
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "exactConst",
                  "signature": "<$Expected>() => <const $Actual>(_actual: (<T>() => T extends $Actual ? 1 : 2) extends <T>() => T extends $Expected ? 1 : 2 ? $Actual : StaticErrorAssertion<\"Actual value type is not exactly equal to expected type\", $Expected, $Actual, never>) => void",
                  "description": "Assert that a value exactly equals the expected type, using const to preserve literal types. This eliminates the need for as casts when testing with literal values.  Related: exact (non-const variant)",
                  "examples": [
                    {
                      "code": "// Without const - requires cast\nTs.Test.exact<{ a: 1 }>()({ a: 1 } as { a: 1 })\n\n// With const - no cast needed!\nTs.Test.exactConst<{ a: 1 }>()({ a: 1 })\n\n// Works with any literal type\nTs.Test.exactConst<'hello'>()('hello')\nTs.Test.exactConst<42>()(42)\nTs.Test.exactConst<true>()(true)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 825
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subConst",
                  "signature": "<$Expected>() => <const $Actual>(_actual: $Actual extends $Expected ? $Actual : StaticErrorAssertion<\"Actual value type does not extend expected type\", $Expected, $Actual, never>) => void",
                  "description": "Assert that a value extends the expected type, using const to preserve literal types. This eliminates the need for as casts when testing with literal values.  Related: sub (non-const variant)",
                  "examples": [
                    {
                      "code": "// Without const - type may widen\nsub<string>()('hello')  // 'hello' widens to string\n\n// With const - preserves literal\nsubConst<string>()('hello')  // keeps 'hello' literal type\n\n// Useful for object literals\nsubConst<{ a: number }>()({ a: 1 })  // preserves { readonly a: 1 }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 853
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "bidConst",
                  "signature": "<$Expected>() => <const $Actual>(_actual: $Actual extends $Expected ? $Expected extends $Actual ? $Actual : StaticErrorAssertion<\"Types are not bidirectionally assignable (Expected does not extend Actual)\", $Expected, $Actual, never> : StaticErrorAssertion<\"Types are not bidirectionally assignable (Actual does not extend Expected)\", $Expected, $Actual, never>) => void",
                  "description": "Assert that a value is mutually assignable with the expected type, using const to preserve literal types. This eliminates the need for as casts when testing with literal values.  Related: bid (non-const variant)",
                  "examples": [
                    {
                      "code": "// Without const - requires cast for exact match\nTs.Test.bid<1 | 2>()(1 as 1 | 2)\n\n// With const - no cast needed\nTs.Test.bidConst<1 | 2>()(1)  // preserves literal 1\n\n// Useful for union types\ntype Status = 'pending' | 'complete'\nTs.Test.bidConst<Status>()('pending')  // keeps 'pending' literal",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 882
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "Case",
                  "signature": "type Case<$Result extends true> = $Result",
                  "description": "Type-level test assertion that requires the result to be true. Used in type-level test suites to ensure a type evaluates to true.",
                  "examples": [
                    {
                      "code": "type MyTests = [\n  Ts.Test.Case<Equal<string, string>>,  // OK - evaluates to true\n  Ts.Test.Case<Equal<string, number>>,  // Error - doesn't extend true\n]",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 917
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Cases",
                  "signature": "type Cases<\n  _T1 extends true = true,\n  _T2 extends true = true,\n  _T3 extends true = true,\n  _T4 extends true = true,\n  _T5 extends true = true,\n  _T6 extends true = true,\n  _T7 extends true = true,\n  _T8 extends true = true,\n  _T9 extends true = true,\n  _T10 extends true = true,\n  _T11 extends true = true,\n  _T12 extends true = true,\n  _T13 extends true = true,\n  _T14 extends true = true,\n  _T15 extends true = true,\n  _T16 extends true = true,\n  _T17 extends true = true,\n  _T18 extends true = true,\n  _T19 extends true = true,\n  _T20 extends true = true,\n  _T21 extends true = true,\n  _T22 extends true = true,\n  _T23 extends true = true,\n  _T24 extends true = true,\n  _T25 extends true = true,\n  _T26 extends true = true,\n  _T27 extends true = true,\n  _T28 extends true = true,\n  _T29 extends true = true,\n  _T30 extends true = true,\n  _T31 extends true = true,\n  _T32 extends true = true,\n  _T33 extends true = true,\n  _T34 extends true = true,\n  _T35 extends true = true,\n  _T36 extends true = true,\n  _T37 extends true = true,\n  _T38 extends true = true,\n  _T39 extends true = true,\n  _T40 extends true = true,\n  _T41 extends true = true,\n  _T42 extends true = true,\n  _T43 extends true = true,\n  _T44 extends true = true,\n  _T45 extends true = true,\n  _T46 extends true = true,\n  _T47 extends true = true,\n  _T48 extends true = true,\n  _T49 extends true = true,\n  _T50 extends true = true,\n  _T51 extends true = true,\n  _T52 extends true = true,\n  _T53 extends true = true,\n  _T54 extends true = true,\n  _T55 extends true = true,\n  _T56 extends true = true,\n  _T57 extends true = true,\n  _T58 extends true = true,\n  _T59 extends true = true,\n  _T60 extends true = true,\n  _T61 extends true = true,\n  _T62 extends true = true,\n  _T63 extends true = true,\n  _T64 extends true = true,\n  _T65 extends true = true,\n  _T66 extends true = true,\n  _T67 extends true = true,\n  _T68 extends true = true,\n  _T69 extends true = true,\n  _T70 extends true = true,\n  _T71 extends true = true,\n  _T72 extends true = true,\n  _T73 extends true = true,\n  _T74 extends true = true,\n  _T75 extends true = true,\n  _T76 extends true = true,\n  _T77 extends true = true,\n  _T78 extends true = true,\n  _T79 extends true = true,\n  _T80 extends true = true,\n  _T81 extends true = true,\n  _T82 extends true = true,\n  _T83 extends true = true,\n  _T84 extends true = true,\n  _T85 extends true = true,\n  _T86 extends true = true,\n  _T87 extends true = true,\n  _T88 extends true = true,\n  _T89 extends true = true,\n  _T90 extends true = true,\n  _T91 extends true = true,\n  _T92 extends true = true,\n  _T93 extends true = true,\n  _T94 extends true = true,\n  _T95 extends true = true,\n  _T96 extends true = true,\n  _T97 extends true = true,\n  _T98 extends true = true,\n  _T99 extends true = true,\n  _T100 extends true = true,\n> = true",
                  "description": "Type-level batch assertion helper that accepts multiple assertions. Each type parameter must extend true, allowing batch type assertions.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Equal<string, string>,     //  Pass\n  Extends<string, 'hello'>,  //  Pass\n  Never<never>               //  Pass\n>\n\n// Type error if any assertion fails\ntype _ = Ts.Test.Cases<\n  Equal<string, string>,     //  Pass\n  Equal<string, number>,     //  Fail - Type error here\n  Extends<string, 'hello'>   //  Pass\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "test",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 939
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Union",
            "type": "namespace",
            "signature": "export * as Union",
            "description": "Valid values for discriminant properties in tagged unions.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "union",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Valid values for discriminant properties in tagged unions.",
              "exports": [
                {
                  "name": "DiscriminantPropertyValue",
                  "signature": "type DiscriminantPropertyValue = string | number | symbol",
                  "description": "Valid values for discriminant properties in tagged unions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 4
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "__FORCE_DISTRIBUTION__",
                  "signature": "type __FORCE_DISTRIBUTION__ = any",
                  "description": "Marker type to make forced union distribution explicit and self-documenting.  TypeScript distributes unions in conditional types when the checked type is a naked type parameter. Using this marker in your conditional type makes the intent explicit to readers.",
                  "examples": [
                    {
                      "code": "// Without marker - unclear if distribution is intentional\ntype Transform<T> = T extends string ? Uppercase<T> : T\n\n// With marker - explicitly documents that distribution is desired\ntype Transform<T> = T extends __FORCE_DISTRIBUTION__ ? T extends string ? Uppercase<T> : T : never\n\n// More typical usage pattern\ntype MapUnion<T> = T extends __FORCE_DISTRIBUTION__\n  ? TransformSingleMember<T>\n  : never",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Real-world example: mapping over union members\ntype AddPrefix<T> = T extends __FORCE_DISTRIBUTION__\n  ? T extends string ? `prefix_${T}` : T\n  : never\n\ntype Result = AddPrefix<'a' | 'b' | 'c'>\n// 'prefix_a' | 'prefix_b' | 'prefix_c'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 37
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Include",
                  "signature": "type Include<$T, $U> = $T extends $U ? $T : never",
                  "description": "Include only types that extend a constraint (opposite of Exclude). Filters a union type to only include members that extend the constraint.",
                  "examples": [
                    {
                      "code": "type T = Union.Include<string | number | boolean, string | number>  // string | number\ntype T2 = Union.Include<'a' | 'b' | 1 | 2, string>  // 'a' | 'b'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "ToTuple",
                  "signature": "type ToTuple<\n  $Union,\n  ___L = LastOf<$Union>,\n  ___N = [$Union] extends [never] ? true : false,\n> = true extends ___N ? []\n  : [...ToTuple<Exclude<$Union, ___L>>, ___L]",
                  "description": "Convert a union type to a tuple type.",
                  "examples": [
                    {
                      "code": "type T = Union.ToTuple<'a' | 'b' | 'c'>  // ['a', 'b', 'c']",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 59
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "ToIntersection",
                  "signature": "type ToIntersection<$U> = ($U extends any ? (k: $U) => void : never) extends ((k: infer __i__) => void) ? __i__\n  : never",
                  "description": "Convert a union type to an intersection type.",
                  "examples": [
                    {
                      "code": "type U = { a: string } | { b: number }\ntype I = Union.ToIntersection<U>  // { a: string } & { b: number }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 75
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "LastOf",
                  "signature": "type LastOf<$T> = ToIntersection<$T extends any ? () => $T : never> extends () => infer __r__ ? __r__\n  : never",
                  "description": "Get the last type in a union.",
                  "examples": [
                    {
                      "code": "type T = Union.LastOf<'a' | 'b' | 'c'>  // 'c'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 86
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Expanded",
                  "signature": "type Expanded<$Union> = $Union",
                  "description": "Force union distribution in conditional types.",
                  "examples": [
                    {
                      "code": "type T = Union.Expanded<'a' | 'b'>  // 'a' | 'b' (forced distribution)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 97
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IgnoreAnyOrUnknown",
                  "signature": "type IgnoreAnyOrUnknown<$T> = unknown extends $T ? never : $T",
                  "description": "Union that ignores any and unknown.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 102
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsAnyMemberExtends",
                  "signature": "type IsAnyMemberExtends<$Union, $Type> =\n  (\n    // [1] Force distribution\n    $Union extends any ?\n      ($Union /* member */ extends $Type ? true : false) :\n      never // [1]\n  ) extends false\n    ? false\n    : true",
                  "description": "Check if any member of a union extends a type.",
                  "examples": [
                    {
                      "code": "type T1 = Union.IsAnyMemberExtends<string | number, string>  // true\ntype T2 = Union.IsAnyMemberExtends<number | boolean, string>  // false",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 114
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsHas",
                  "signature": "type IsHas<$Type, $LookingFor> =\n  _IsHas<$Type, $LookingFor> extends false\n    ? false\n    : true",
                  "description": "Checks if a union type contains a specific type.  Returns true if any member of the union type extends the target type, false otherwise. This is useful for conditional type logic based on union membership.   $Type - The union type to search within  $LookingFor - The type to search for",
                  "examples": [
                    {
                      "code": "type HasString = Union.IsHas<string | number | boolean, string>  // true\ntype HasDate = Union.IsHas<string | number, Date>                // false\ntype HasLiteral = Union.IsHas<'a' | 'b' | 'c', 'b'>             // true\n\n// Useful in conditional types\ntype ProcessValue<T> = Union.IsHas<T, Promise<any>> extends true\n  ? 'async'\n  : 'sync'\n\ntype R1 = ProcessValue<string | Promise<string>>  // 'async'\ntype R2 = ProcessValue<string | number>           // 'sync'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Works with complex types\ntype Events = { type: 'click' } | { type: 'hover' } | { type: 'focus' }\ntype HasClick = Union.IsHas<Events, { type: 'click' }>  // true\n\n// Check for any promise in union\ntype MaybeAsync<T> = Union.IsHas<T, Promise<any>>\ntype R3 = MaybeAsync<string | Promise<number>>  // true\ntype R4 = MaybeAsync<string | number>           // false",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 162
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Merge",
                  "signature": "type Merge<$U> = {\n  [\n    k in (\n      $U extends any ? keyof $U : never\n    )\n  ]: $U extends any ? (k extends keyof $U ? $U[k] : never) : never\n}",
                  "description": "Merge all members of a union into a single type.",
                  "examples": [
                    {
                      "code": "type U = { a: string } | { b: number }\ntype M = Union.Merge<U>  // { a: string; b: number }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 182
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Variance",
            "type": "namespace",
            "signature": "export * as Variance",
            "description": "Phantom type helper that makes a type parameter covariant.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 36
            },
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "variance",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Phantom type helper that makes a type parameter covariant.",
              "exports": [
                {
                  "name": "Co",
                  "signature": "type Co<$T> = () => $T",
                  "description": "Phantom type helper that makes a type parameter covariant.",
                  "examples": [
                    {
                      "code": "interface Container<T> {\n  readonly __type?: Covariant<T>\n}\n\nlet narrow: Container<1> = {}\nlet wide: Container<number> = {}\n\nwide = narrow  //  Allowed (1 extends number)\nnarrow = wide  //  Error (number does not extend 1)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 28
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Contra",
                  "signature": "type Contra<$T> = (value: $T) => void",
                  "description": "Phantom type helper that makes a type parameter contravariant.",
                  "examples": [
                    {
                      "code": "interface Handler<T> {\n  readonly __type?: Contravariant<T>\n}\n\nlet narrow: Handler<1> = {}\nlet wide: Handler<number> = {}\n\nnarrow = wide  //  Allowed (reversed direction!)\nwide = narrow  //  Error",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 55
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "In",
                  "signature": "type In<$T> = (value: $T) => $T",
                  "description": "Phantom type helper that makes a type parameter invariant.",
                  "examples": [
                    {
                      "code": "interface Exact<T> {\n  readonly __type?: Invariant<T>\n}\n\nlet one: Exact<1> = {}\nlet num: Exact<number> = {}\n\nnum = one  //  Error (no direction works)\none = num  //  Error (no direction works)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 77
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Bi",
                  "signature": "type Bi<$T> = { bivariantHack(value: $T): void }['bivariantHack']",
                  "description": "Phantom type helper that makes a type parameter bivariant (unsafe).",
                  "examples": [
                    {
                      "code": "interface Unsafe<T> {\n  readonly __type?: Bivariant<T>\n}\n\nlet one: Unsafe<1> = {}\nlet num: Unsafe<number> = {}\n\nnum = one  //  Allowed (both directions work)\none = num  //  Allowed (unsafe!)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 99
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "name": "Print",
            "signature": "type Print<$Type, $Fallback extends string | undefined = undefined> =\n  // Language base category types\n    IsAny<$Type> extends true     ? 'any'\n  : IsUnknown<$Type> extends true ? 'unknown'\n  : IsNever<$Type> extends true   ? 'never'\n\n  // Special union type boolean which we display as boolean insead of true | false\n  : [$Type] extends [boolean]      ? ([boolean] extends [$Type] ? 'boolean' : `${$Type}`)\n\n  // General unions types\n  : UnionToTuple<$Type> extends ArrMut.Any2OrMoreRO ? _PrintUnion<UnionToTuple<$Type>>\n\n  // Primitive and literal types\n  : $Type extends true             ? 'true'\n  : $Type extends false            ? 'false'\n  : $Type extends void             ? ($Type extends undefined ? 'undefined' : 'void')\n  : $Type extends string           ? (string extends $Type    ? 'string'  : `'${$Type}'`)\n  : $Type extends number           ? (number extends $Type    ? 'number'  : `${$Type}`)\n  : $Type extends bigint           ? (bigint extends $Type    ? 'bigint'  : `${$Type}n`)\n  : $Type extends null             ? 'null'\n  : $Type extends undefined        ? 'undefined'\n\n  // User-provided fallback takes precedence if type is not a primitive\n  : $Fallback extends string       ? $Fallback\n\n  // Common object types and specific generic patterns\n  : $Type extends Promise<infer T> ? `Promise<${Print<T>}>`\n  : $Type extends (infer T)[]      ? `Array<${Print<T>}>`\n  : $Type extends readonly (infer T)[]      ? `ReadonlyArray<${Print<T>}>`\n  : $Type extends Date             ? 'Date'\n  : $Type extends RegExp           ? 'RegExp'\n  //\n  : $Type extends Function         ? 'Function'\n  : $Type extends symbol           ? 'symbol'\n\n  // General object fallback\n  : $Type extends object           ? 'object'\n\n  // Ultimate fallback\n  : '?'",
            "description": "Print a type as a readable string representation.",
            "examples": [],
            "category": "Type Printing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "print",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "_PrintUnion",
            "signature": "type _PrintUnion<$Type extends ArrMut.AnyRO> =\n    $Type extends readonly [infer __first__, ...infer __rest__ extends ArrMut.Any1OrMoreRO]\n      ? `${Print<__first__>} | ${_PrintUnion<__rest__>}`\n      : $Type extends readonly [infer __first__]\n        ? `${Print<__first__>}`\n        : $Type extends ArrMut.EmptyRO\n          ? ''\n          : never",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "print",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 53
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "as",
            "signature": "<$value>(value?: unknown) => $value",
            "description": "Cast any value to a specific type for testing purposes. Useful for type-level testing where you need to create a value with a specific type.   $value - The type to cast to",
            "examples": [
              {
                "code": "// Creating typed test values\nconst user = as<{ id: string; name: string }>({ id: '1', name: 'Alice' })\n\n// Testing type inference\ndeclare let _: any\nconst result = someFunction()\nassertExtends<string>()(_ as typeof result)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 24
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Interpolatable",
            "signature": "type Interpolatable =\n  | string\n  | number\n  | bigint\n  | boolean\n  | null\n  | undefined\n  | symbol\n  | object\n  | unknown\n  | any\n  | never",
            "description": "Types that TypeScript accepts being interpolated into a Template Literal Type.  These are the types that can be used within template literal types without causing a TypeScript error. When a value of one of these types is interpolated into a template literal type, TypeScript will properly convert it to its string representation.",
            "examples": [
              {
                "code": "// All these types can be interpolated:\ntype Valid1 = `Value: ${string}`\ntype Valid2 = `Count: ${number}`\ntype Valid3 = `Flag: ${boolean}`\ntype Valid4 = `ID: ${123n}`\n\n// Example usage in conditional types:\ntype Stringify<T extends Interpolatable> = `${T}`\ntype Result1 = Stringify<42>        // \"42\"\ntype Result2 = Stringify<true>      // \"true\"\ntype Result3 = Stringify<'hello'>   // \"hello\"",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "StaticError",
            "signature": "interface StaticError<\n  $Message extends string = string,\n  $Context extends object = {},\n  $Hint extends string = '(none)',\n> {\n  ERROR: $Message\n  CONTEXT: $Context\n  HINT: $Hint\n}",
            "description": "Represents a type error that can be surfaced at the type level.  This is useful for providing more informative error messages directly in TypeScript's type checking, often used with conditional types or generic constraints. When TypeScript encounters this type, it will display the error information in a structured way.   $Message - A string literal type describing the error  $Context - An object type providing additional context about the error,                      often including the types involved  $Hint - A string literal type providing a hint for resolving the error",
            "examples": [
              {
                "code": "// Creating a custom type error\ntype RequireString<T> = T extends string ? T : StaticError<\n  'Type must be a string',\n  { Received: T },\n  'Consider using string or a string literal type'\n>\n\ntype Good = RequireString<'hello'>  // 'hello'\ntype Bad = RequireString<number>    // StaticError<...>",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using in function constraints\nfunction processString<T>(\n  value: T extends string ? T : StaticError<\n    'Argument must be a string',\n    { ProvidedType: T }\n  >\n): void {\n  // Implementation\n}\n\nprocessString('hello')  // OK\nprocessString(42)       // Type error with custom message",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Error Messages",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 106
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "StaticErrorAny",
            "signature": "type StaticErrorAny = StaticError<string, object, string>",
            "examples": [],
            "category": "Error Messages",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 119
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StaticErrorAssertion",
            "signature": "interface StaticErrorAssertion<\n  $Message extends string = string,\n  $Expected = unknown,\n  $Actual = unknown,\n  $Tip extends string = never,\n> {\n  MESSAGE: $Message\n  EXPECTED: $Expected\n  ACTUAL: $Actual\n  TIP: $Tip\n}",
            "description": "Represents a static assertion error at the type level, optimized for type testing.  This is a simpler, more focused error type compared to StaticError. It's specifically designed for type assertions where you need to communicate expected vs. actual types.   $Message - A string literal type describing the assertion failure  $Expected - The expected type  $Actual - The actual type that was provided",
            "examples": [
              {
                "code": "// Using in parameter assertions\nfunction assertParameters<T extends readonly any[]>(\n  fn: Parameters<typeof fn> extends T ? typeof fn\n    : StaticErrorAssertion<\n      'Parameters mismatch',\n      T,\n      Parameters<typeof fn>\n    >\n): void {}\n\n// Error shows:\n// MESSAGE: 'Parameters mismatch'\n// EXPECTED: [string, number]\n// ACTUAL: [number, string]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Error Messages",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 151
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "Show",
            "signature": "type Show<$Type> = `\\`${Print<$Type>}\\``",
            "description": "Like Print but adds additional styling to display the rendered type in a sentence.  Useful for type-level error messages where you want to clearly distinguish type names from surrounding text. Wraps the printed type with backticks () like inline code in Markdown.   $Type - The type to format and display",
            "examples": [
              {
                "code": "type Message1 = `Expected ${Show<string>} but got ${Show<number>}`\n// Result: \"Expected `string` but got `number`\"\n\ntype Message2 = `The type ${Show<'hello' | 'world'>} is not assignable`\n// Result: \"The type `'hello' | 'world'` is not assignable\"\n\n// Using in error messages\ntype TypeError<Expected, Actual> = StaticError<\n  `Type mismatch: expected ${Show<Expected>} but got ${Show<Actual>}`,\n  { Expected, Actual }\n>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Printing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 188
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ShowInTemplate",
            "signature": "type ShowInTemplate<$Type> = `'${Print<$Type>}'`",
            "description": "Version of Show but uses single quotes instead of backticks.  This can be useful in template literal types where backticks would be rendered as \"\" which is not ideal for readability. Use this when the output will be used within another template literal type or when backticks cause display issues.  Note that when working with TS-level errors, if TS can instantiate all the types involved then the result will be a string, not a string literal type. So when working with TS-level errors, only reach for this variant of Show if you think there is likelihood that types won't be instantiated.   $Type - The type to format and display",
            "examples": [
              {
                "code": "// When backticks would be escaped in output\ntype ErrorInTemplate = `Error: ${ShowInTemplate<string>} is required`\n// Result: \"Error: 'string' is required\"\n\n// Comparing Show vs ShowInTemplate\ntype WithShow = `Type is ${Show<number>}`\n// May display as: \"Type is \\`number\\`\" (escaped backticks)\n\ntype WithShowInTemplate = `Type is ${ShowInTemplate<number>}`\n// Displays as: \"Type is 'number'\" (cleaner)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Printing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 219
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Simplify",
            "signature": "type Simplify<$Type> =\n  & {\n    [_ in keyof $Type]: $Type[_]\n  }\n  & unknown",
            "description": "Simplifies complex type intersections and mapped types for better readability.  Forces TypeScript to evaluate and flatten a type, which is especially useful for: - Intersection types that appear as A & B & C in tooltips - Complex mapped types that show their internal structure - Making type aliases more readable in IDE tooltips   $Type - The type to simplify",
            "examples": [
              {
                "code": "// Without Simplify\ntype Complex = { a: string } & { b: number } & { c: boolean }\n// Tooltip shows: { a: string } & { b: number } & { c: boolean }\n\n// With Simplify\ntype Simple = Simplify<Complex>\n// Tooltip shows: { a: string; b: number; c: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Simplifying complex mapped types\ntype UserPermissions =\n  & { read: boolean }\n  & { write: boolean }\n  & { admin: boolean }\n\ntype FlatPermissions = Simplify<UserPermissions>\n// Shows as: { read: boolean; write: boolean; admin: boolean }\n\n// Useful with generic constraints\nfunction processUser<T extends Simplify<UserPermissions>>(user: T) {\n  // T will show flattened structure in errors and tooltips\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 261
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "SimplifyNullable",
            "signature": "type SimplifyNullable<$T> = null extends $T ? (Simplify<$T> & {}) | null : Simplify<$T> & {}",
            "description": "Simplify a type while preserving | null unions.  This solves a subtle problem with Simplify: when you have Type | null, using Simplify<Type | null> can absorb or transform the null in unexpected ways due to the intersection with & unknown or & {}. This utility checks for null first, then explicitly reconstructs the union to ensure | null remains intact.  **When to use:** - Use SimplifyNullable when simplifying types that may contain | null or | undefined - Use Simplify for non-nullable types or when null handling doesn't matter   $T - The type to simplify",
            "examples": [
              {
                "code": "// Problem: Plain Simplify can mangle nullable unions\ntype User = { name: string } & { age: number }\ntype MaybeUser = User | null\ntype Bad = Simplify<MaybeUser>  // May not preserve | null correctly\n\n// Solution: SimplifyNullable preserves the null union\ntype Good = SimplifyNullable<MaybeUser>  // { name: string; age: number } | null",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Works with non-nullable types too\ntype Simple = SimplifyNullable<{ a: 1 } & { b: 2 }>  // { a: 1; b: 2 }\n\n// Preserves null in unions\ntype Nullable = SimplifyNullable<({ a: 1 } & { b: 2 }) | null>  // { a: 1; b: 2 } | null",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 301
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ExtendsExact",
            "signature": "type ExtendsExact<$Input, $Constraint> =\n  $Input extends $Constraint\n    ? $Constraint extends $Input\n      ? $Input\n      : never\n    : never",
            "description": "Utilities for working with union types at the type level.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 341
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "NotExtends",
            "signature": "type NotExtends<$A, $B> = [$A] extends [$B] ? false : true",
            "description": "Type-level utility that checks if a type does NOT extend another type.  Returns true if type A does not extend type B, false otherwise. Useful for conditional type logic where you need to check the absence of a type relationship.   $A - The type to check  $B - The type to check against",
            "examples": [
              {
                "code": "type T1 = NotExtends<string, number>      // true (string doesn't extend number)\ntype T2 = NotExtends<'hello', string>     // false ('hello' extends string)\ntype T3 = NotExtends<42, number>          // false (42 extends number)\ntype T4 = NotExtends<{ a: 1 }, { b: 2 }>  // true (different properties)",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using in conditional types for optional handling\ntype VarBuilderToType<$Type, $VarBuilder> =\n  $VarBuilder['required'] extends true                     ? Exclude<$Type, undefined> :\n  NotExtends<$VarBuilder['default'], undefined> extends true ? $Type | undefined :\n                                                              $Type\n\n// If default is undefined, type is just $Type\n// If default is not undefined, type is $Type | undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Checking for specific type exclusions\ntype SafeDivide<T> = NotExtends<T, 0> extends true\n  ? number\n  : StaticError<'Cannot divide by zero'>\n\ntype Result1 = SafeDivide<5>   // number\ntype Result2 = SafeDivide<0>   // StaticError<'Cannot divide by zero'>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 390
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Writeable",
            "signature": "type Writeable<$Object> = {\n  -readonly [k in keyof $Object]: $Object[k]\n}",
            "description": "Make all properties in an object mutable (removes readonly modifiers).",
            "examples": [
              {
                "code": "type Readonly = { readonly x: number; readonly y: string }\ntype Mutable = Writeable<Readonly>  // { x: number; y: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 401
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IfExtendsElse",
            "signature": "type IfExtendsElse<$Type, $Extends, $Then, $Else> = $Type extends $Extends ? $Then : $Else",
            "examples": [],
            "deprecated": "- Commented out 2025-01-07  This utility was too strict - requires BIDIRECTIONAL extends, which rejects valid narrowed types (e.g.,  id: true  for  id: boolean ).  Use Obj.NoExcess instead, which: -  Rejects excess properties (what you want) -  Allows valid subtypes/narrowing (what you need)  If a use case for true bidirectional exact matching emerges, uncomment. Otherwise, remove after 3-6 months (target: ~2025-07-01).  Original implementation:",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 440
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IntersectionIgnoreNeverOrAny",
            "signature": "type IntersectionIgnoreNeverOrAny<$T> = IsAny<$T> extends true ? unknown : $T extends never ? unknown : $T",
            "description": "Intersection that ignores never and any.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 445
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "NeverOrAnyToUnknown",
            "signature": "type NeverOrAnyToUnknown<$T> = IsAny<$T> extends true ? unknown : $T extends never ? unknown : $T",
            "description": "Convert never or any to unknown.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 450
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Narrowable",
            "signature": "type Narrowable = string | number | bigint | boolean | []",
            "description": "Any narrowable primitive type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 455
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "AnyAndUnknownToNever",
            "signature": "type AnyAndUnknownToNever<$T> = IsAny<$T> extends true ? never : IsUnknown<$T> extends true ? never : $T",
            "description": "Convert any and unknown to never.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 460
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isTypeWith",
            "signature": "<reference>(reference: reference) => <valueGiven>(value: ValidateIsSupertype<reference, valueGiven>) => value is reference extends valueGiven ? reference : never",
            "description": "Create a type guard that checks if a value equals a reference value.",
            "examples": [
              {
                "code": "const isNull = isTypeWith(null)\nconst value: string | null = getString()\nif (isNull(value)) {\n  // value is narrowed to null\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-guards",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isntTypeWith",
            "signature": "<reference>(reference: reference) => <valueGiven>(value: ValidateIsSupertype<reference, valueGiven>) => value is reference extends valueGiven ? Exclude<valueGiven, reference> : never",
            "description": "Create a type guard that checks if a value does not equal a reference value.",
            "examples": [
              {
                "code": "const isntNull = isntTypeWith(null)\nconst value: string | null = getString()\nif (isntNull(value)) {\n  // value is narrowed to string\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-guards",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 41
            },
            "_tag": "value",
            "type": "function"
          }
        ],
        "category": "Development"
      }
    },
    {
      "_tag": "DrillableNamespaceEntrypoint",
      "path": "./value",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "value"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "General value utilities for common JavaScript values and patterns.  Provides utilities for lazy values, type guards for symbols and dates, identity proxies, and lazy value resolution. Includes helpers for working with deferred computations and value type checking.",
        "exports": [
          {
            "name": "Lazy",
            "signature": "type Lazy<$Value> = () => $Value",
            "description": "A lazy value that is computed when called.  $Value - The type of value that will be returned when the lazy function is invoked",
            "examples": [],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "lazy",
            "signature": "<const value>(value: value) => Lazy<value>",
            "description": "Creates a lazy value that returns the given value when invoked.  value - The type of the value to be lazily returned",
            "examples": [
              {
                "code": "const lazyNumber = lazy(42)\nconsole.log(lazyNumber()) // 42\n\nconst lazyObject = lazy({ foo: 'bar' })\nconsole.log(lazyObject()) // { foo: 'bar' }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "LazyMaybe",
            "signature": "type LazyMaybe<$Value = unknown> = $Value | Lazy<$Value>",
            "description": "A value that may be either immediate or lazy.  $Value - The type of the value, whether immediate or lazy",
            "examples": [],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "resolveLazy",
            "signature": "type resolveLazy<$LazyMaybeValue extends LazyMaybe<any>> =\n  $LazyMaybeValue extends Lazy<infer __value__> ? __value__ : $LazyMaybeValue",
            "description": "Type-level resolution of a LazyMaybe value. Extracts the underlying value type whether it's lazy or immediate.  $LazyMaybeValue - A value that may be lazy or immediate",
            "examples": [],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 45
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "resolveLazyFactory",
            "signature": "<value>(lazyMaybeValue: LazyMaybe<value>) => () => value",
            "description": "Creates a factory function that resolves a lazy or immediate value when called. This is useful when you want to defer the resolution of a LazyMaybe value.  value - The type of the value to be resolved",
            "examples": [
              {
                "code": "const getValue = resolveLazyFactory(42)\nconsole.log(getValue()) // 42\n\nconst getLazyValue = resolveLazyFactory(() => 42)\nconsole.log(getLazyValue()) // 42\n\n// Useful for configuration that may be lazy\nconst getConfig = resolveLazyFactory(() => ({ apiUrl: 'https://api.example.com' }))\nconsole.log(getConfig()) // { apiUrl: 'https://api.example.com' }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 94
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "identityProxy",
            "signature": "{}",
            "description": "A proxy that returns itself for any property access. Useful for default values or chaining patterns.",
            "examples": [
              {
                "code": "identityProxy.foo.bar.baz  // Returns identityProxy\nidentityProxy.anything()  // Returns identityProxy",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 113
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isSymbol",
            "signature": "(value: unknown) => value is symbol",
            "description": "Type guard to check if a value is a symbol.",
            "examples": [
              {
                "code": "isSymbol(Symbol('test'))  // true\nisSymbol('test')  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 130
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isDate",
            "signature": "(value: unknown) => value is Date",
            "description": "Type guard to check if a value is a Date instance.",
            "examples": [
              {
                "code": "isDate(new Date())  // true\nisDate('2024-01-01')  // false\nisDate(Date.now())  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 155
            },
            "_tag": "value",
            "type": "function"
          }
        ],
        "category": "Error Handling & Values"
      }
    }
  ],
  "metadata": {
    "extractedAt": "2025-10-10T04:04:04.150Z",
    "extractorVersion": "0.1.0"
  }
}
