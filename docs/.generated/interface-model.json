{
  "name": "@wollybeard/kit",
  "version": "0.0.0-dripip",
  "entrypoints": [
    {
      "packagePath": "./arr",
      "resolvedPath": "./src/domains/arr/$.ts",
      "module": {
        "name": "Arr",
        "description": "Array utilities for working with readonly and mutable arrays.\n\nProvides functional utilities for array operations including mapping, filtering,\ntype guards, and conversions. Emphasizes immutable operations and type safety.",
        "exports": [
          {
            "name": "Eq",
            "signature": "Eq<Any>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/traits/eq.ts",
              "line": 33
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<Any>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/traits/type.ts",
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "assert",
            "signature": "export function assert(value: unknown): void",
            "description": "Assert that a value is an array.\nThrows a TypeError if the value is not an array.",
            "examples": [
              {
                "code": "Arr.assert(value)\n  // value is now typed as unknown[]\n  value.forEach(item => console.log(item))\n}",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- The value to check",
              "throws": "If the value is not an array"
            },
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 113
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Unknown",
            "signature": "export type Unknown = readonly unknown[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Any",
            "signature": "export type Any = readonly any[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 11
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Empty",
            "signature": "export type Empty = readonly []",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "All",
            "signature": "export type All<$Tuple extends [...boolean[]]> = $Tuple[number] extends true ? true : false",
            "description": "Check if all booleans in a tuple are true.",
            "examples": [
              {
                "code": "type T2 = All<[true, false, true]>  // false",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 26
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsTupleMultiple",
            "signature": "export type IsTupleMultiple<$T> = $T extends [unknown, unknown, ...unknown[]] ? true : false",
            "description": "Check if a tuple has multiple elements.",
            "examples": [
              {
                "code": "type T2 = IsTupleMultiple<[1]>  // false",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 37
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Push",
            "signature": "export type Push<$T extends any[], $V> = [...$T, $V]",
            "description": "Push a value onto a tuple.",
            "examples": [
              {
                "code": "",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 47
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "FirstNonUnknownNever",
            "signature": "export type FirstNonUnknownNever<$T extends any[]> = $T extends [infer __first__, ...infer __rest__]\n  ? unknown extends __first__ ? 0 extends 1 & __first__ ? FirstNonUnknownNever<__rest__> // is any\n    : FirstNonUnknownNever<__rest__> // is unknown\n  : __first__ extends never ? FirstNonUnknownNever<__rest__>\n  : __first__\n  : never",
            "description": "Get the first non-unknown, non-never element from a tuple.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 52
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "empty",
            "signature": "readonly []",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 71
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "emptyArray",
            "signature": "readonly []",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 82
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "EmptyArray",
            "signature": "export type EmptyArray = typeof emptyArray",
            "description": "Type for the empty array constant.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 87
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "includes",
            "signature": "<$T>(array: $T[], value: unknown) => value is $T",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 136
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensure",
            "signature": "<$T>(value: $T | $T[]) => $T[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/arr/arr.ts",
              "line": 156
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "packagePath": "./err",
      "resolvedPath": "./src/utils/err/$.ts",
      "module": {
        "name": "Err",
        "description": "Error handling utilities for robust error management.\n\nProvides utilities for error inspection, stack trace manipulation, try-catch wrappers,\ntype guards, and null safety. Features formatted error logging and error wrapping utilities.",
        "exports": [
          {
            "name": "log",
            "signature": "(error: Error, options?: { color?: boolean; stackTraceColumns?: number; identColumns?: number; showHelp?: boolean; } | undefined) => void",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/$$.ts",
              "line": 19
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "throwNull",
            "signature": "<V>(value: V, message?: string | undefined) => Exclude<V, null>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/$$.ts",
              "line": 35
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "defaultThrowNullMessage",
            "signature": "\"Unexpected null value.\"",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/$$.ts",
              "line": 44
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "guardNull",
            "signature": "<fn extends Fn.AnyAny>(fn: fn, message?: string | undefined) => ReturnExclude<null, fn>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/$$.ts",
              "line": 59
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "InferOptions",
            "signature": "export type InferOptions<$EnvironmentConfigurableOptions extends EnvironmentConfigurableOptionSpec[]> = Ts.Simplify<\n  ArrMut.ReduceWithIntersection<_InferOptions<$EnvironmentConfigurableOptions>>\n>",
            "description": "Type helper for inferring option types from environment configurable option specifications.\nTransforms an array of option specs into a typed options object.",
            "examples": [],
            "tags": {
              "template": "- Array of option specifications",
              "internal": ""
            },
            "sourceLocation": {
              "file": "src/utils/err/inspect.ts",
              "line": 34
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "_InferOptions",
            "signature": "export type _InferOptions<$EnvironmentConfigurableOptions extends EnvironmentConfigurableOptionSpec[]> = {\n  [i in keyof $EnvironmentConfigurableOptions]: {\n    [_ in $EnvironmentConfigurableOptions[i]['name']]?: ReturnType<$EnvironmentConfigurableOptions[i]['parse']>\n  }\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/inspect.ts",
              "line": 38
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "InspectOptions",
            "signature": "export type InspectOptions = InferOptions<typeof optionSpecs>",
            "description": "Options for configuring error inspection output.\nAll options can be overridden via environment variables.",
            "examples": [
              {
                "code": "Err.inspect(error)\n\n// Customize options\nErr.inspect(error, {\n  color: false,\n  stackTraceColumns: 200,\n  showHelp: false\n})\n\n// Set via environment variables\nprocess.env.ERROR_DISPLAY_COLOR = 'false'\nprocess.env.ERROR_DISPLAY_SHOW_HELP = 'false'",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "property": "showHelp - Whether to display the environment variable help section (default: true, env: ERROR_DISPLAY_SHOW_HELP)"
            },
            "sourceLocation": {
              "file": "src/utils/err/inspect.ts",
              "line": 162
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "InspectConfig",
            "signature": "export type InspectConfig = Resolve<typeof optionSpecs>",
            "description": "Resolved configuration for error inspection with values and sources.\nContains the final values after merging defaults, user options, and environment variables.",
            "examples": [],
            "tags": {
              "internal": ""
            },
            "sourceLocation": {
              "file": "src/utils/err/inspect.ts",
              "line": 170
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "inspect",
            "signature": "(error: Error, options?: { color?: boolean; stackTraceColumns?: number; identColumns?: number; showHelp?: boolean; } | undefined) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/inspect.ts",
              "line": 224
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "StackOptions",
            "signature": "export interface StackOptions {\n  /**\n   * Remove internal library frames from the stack trace.\n   * @default true\n   */\n  removeInternal?: boolean\n\n  /**\n   * Patterns to filter out from stack traces.\n   * @default ['node_modules', 'node:internal']\n   */\n  filterPatterns?: string[]\n\n  /**\n   * Maximum number of frames to show.\n   * @default 10\n   */\n  maxFrames?: number\n\n  /**\n   * Include source code context around error location.\n   * @default false\n   */\n  includeSource?: boolean\n\n  /**\n   * Number of source lines to show before and after error.\n   * @default 2\n   */\n  sourceContext?: number\n}",
            "description": "Options for cleaning and formatting stack traces.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 7
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "StackFrame",
            "signature": "export interface StackFrame {\n  /**\n   * Function name or <anonymous>\n   */\n  function: string\n\n  /**\n   * File path\n   */\n  file: string\n\n  /**\n   * Line number\n   */\n  line: number\n\n  /**\n   * Column number\n   */\n  column: number\n\n  /**\n   * Whether this is internal to the library\n   */\n  isInternal: boolean\n\n  /**\n   * Whether this is a native V8 frame\n   */\n  isNative: boolean\n\n  /**\n   * Raw frame string\n   */\n  raw: string\n}",
            "description": "Parsed stack frame information.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 42
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "parseStack",
            "signature": "(stack: string) => StackFrame[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 82
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "StackCleanStats",
            "signature": "export interface StackCleanStats {\n  /**\n   * Total number of frames before filtering.\n   */\n  totalFrames: number\n\n  /**\n   * Number of frames filtered out.\n   */\n  filteredFrames: number\n\n  /**\n   * Number of node_modules frames filtered.\n   */\n  nodeModulesFrames: number\n\n  /**\n   * Number of internal frames filtered.\n   */\n  internalFrames: number\n\n  /**\n   * Number of frames shown.\n   */\n  shownFrames: number\n\n  /**\n   * Whether the output was truncated due to maxFrames.\n   */\n  wasTruncated: boolean\n}",
            "description": "Statistics about stack trace filtering.\nProvides detailed information about what was filtered during stack cleaning.",
            "examples": [
              {
                "code": "console.log(`Filtered ${result.stats.filteredFrames} frames`)\nconsole.log(`Showing ${result.stats.shownFrames} of ${result.stats.totalFrames} total`)",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 159
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "CleanStackResult",
            "signature": "export interface CleanStackResult {\n  /**\n   * The cleaned stack trace string.\n   */\n  stack: string\n\n  /**\n   * Statistics about what was filtered.\n   */\n  stats: StackCleanStats\n}",
            "description": "Result of cleaning a stack trace.\nContains both the cleaned stack string and statistics about what was filtered.",
            "examples": [],
            "tags": {
              "see": "{@link cleanStackWithStats}"
            },
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 197
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "cleanStackWithStats",
            "signature": "(stack: string, options?: StackOptions | undefined) => CleanStackResult",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 230
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "cleanStack",
            "signature": "(stack: string, options?: StackOptions | undefined) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 303
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "formatFrame",
            "signature": "(frame: StackFrame) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 310
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "CleanError",
            "signature": "export class CleanError extends Error {\n  /**\n   * Original uncleaned stack trace.\n   */\n  originalStack?: string\n\n  /**\n   * Additional context for the error.\n   */\n  context?: Context\n\n  constructor(message: string, options?: ErrorOptions & { context?: Context; stackOptions?: StackOptions }) {\n    super(message, options)\n    this.name = this.constructor.name\n\n    if (options?.context) {\n      this.context = options.context\n    }\n\n    // Clean the stack trace\n    if (this.stack) {\n      this.originalStack = this.stack\n      this.stack = cleanStackWithStats(this.stack, options?.stackOptions).stack\n    }\n\n    // Ensure proper prototype chain\n    Object.setPrototypeOf(this, new.target.prototype)\n  }\n}",
            "description": "Enhanced Error class that automatically cleans stack traces.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 320
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "mergeStacks",
            "signature": "(wrapper: Error, cause: Error) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 354
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "captureStackTrace",
            "signature": "(message?: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 402
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getCaller",
            "signature": "(depth?: number) => StackFrame | undefined",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/stack.ts",
              "line": 411
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryCatch",
            "signature": "export function tryCatch<returned, thrown>(promise: Promise<returned>, predicates?: readonly [Bool.TypePredicate<thrown>, ...readonly Bool.TypePredicate<thrown>[]]): Promise<returned | (IsUnknown<thrown> extends true ? Error : thrown)>",
            "description": "Try to execute a function or resolve a promise, catching errors instead of throwing.\nReturns either the successful result or the caught error.",
            "examples": [
              {
                "code": "const result = tryCatch(() => JSON.parse(input)) // parsed value | Error\n\n// With promise\nconst data = await tryCatch(fetch(url)) // Response | Error\n\n// With custom predicates\nconst isNetworkError = (e: unknown): e is NetworkError =>\n  e instanceof Error && e.name === 'NetworkError'\n\nconst response = tryCatch(\n  () => fetch(url),\n  [isNetworkError]\n) // Response | NetworkError",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- Type predicates to filter which errors to catch (defaults to all Error instances)",
              "returns": "The result if successful, or the caught error"
            },
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 94
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrRethrow",
            "signature": "export function tryOrRethrow<$Return>(fn: () => $Return, wrapper: string | WrapOptions | ((cause: Error) => Error)): $Return extends Promise<any> ? $Return : $Return",
            "description": "Try to execute a function and wrap any thrown errors with a higher-level message.\nHandles both synchronous and asynchronous functions automatically.",
            "examples": [
              {
                "code": "const data = await tryOrRethrow(\n  fetchData,\n  'Failed to fetch data'\n)\n\n// With options\nconst user = await tryOrRethrow(\n  () => fetchUser(userId),\n  { message: 'Failed to fetch user', context: { userId } }\n)\n\n// With wrapper function\nconst result = await tryOrRethrow(\n  riskyOperation,\n  wrapWith('Operation failed')\n)\n\n// Custom error wrapper\nconst config = await tryOrRethrow(\n  loadConfig,\n  (cause) => new ConfigError('Failed to load config', { cause })\n)",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- Either a string message, options object, or a function that wraps the error",
              "returns": "The result of the function if successful",
              "throws": "The wrapped error if the function throws"
            },
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 394
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryAllOrRethrow",
            "signature": "export function tryAllOrRethrow<$Fns extends readonly [() => any, ...Array<() => any>]>(fns: $Fns, wrapper: string | WrapOptions | ((cause: Error) => Error)): Promise<{ [K in keyof $Fns]: Awaited<ReturnType<$Fns[K]>>; }>",
            "description": "Try multiple functions and wrap any errors with a higher-level message.\nIf any function throws, all errors are collected into an AggregateError.",
            "examples": [
              {
                "code": "[fetchUsers, fetchPosts],\n  'Failed to load data'\n)\n\n// With context\nconst [config, schema, data] = await tryAllOrRethrow(\n  [loadConfig, loadSchema, loadData],\n  { message: 'Failed to initialize', context: { env: 'production' } }\n)",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- Either a string message, options object, or a function that wraps the error",
              "returns": "Array of results if all succeed",
              "throws": "AggregateError with wrapped individual errors if any fail"
            },
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 433
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "TryCatchDefaultPredicateTypes",
            "signature": "export type TryCatchDefaultPredicateTypes = Error",
            "description": "Default error types caught by try/catch functions when no predicates are specified.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 24
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "tryCatchify",
            "signature": "<fn extends Fn.AnyAny, thrown>(fn: fn, predicates?: readonly [TypePredicate<thrown>, ...TypePredicate<thrown>[]]) => (...args: Parameters<fn>) => AwaitedUnion<ReturnType<fn>, IsUnknown<thrown> extends true ? Error : thrown>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryCatchIgnore",
            "signature": "<$Return>(fn: () => $Return) => $Return",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 155
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOr",
            "signature": "<success, fallback>(fn: () => success, fallback: LazyMaybe<fallback>) => TryOrReturn<success, fallback>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 202
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsync",
            "signature": "<success, fallback>(fn: () => success, fallback: LazyMaybe<fallback>) => Promise<Awaited<success> | Awaited<fallback>>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 250
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsyncOn",
            "signature": "<success>(fn: () => success) => <fallback>(fallback: LazyMaybe<fallback>) => Promise<Awaited<success> | Awaited<fallback>>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 273
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsyncWith",
            "signature": "<fallback>(fallback: LazyMaybe<fallback>) => <success>(fn: () => success) => Promise<Awaited<success> | Awaited<fallback>>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 290
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrOn",
            "signature": "<success>(fn: () => success) => <fallback>(fallback: LazyMaybe<fallback>) => TryOrReturn<success, fallback>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 308
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrWith",
            "signature": "<fallback>(fallback: LazyMaybe<fallback>) => <success>(fn: () => success) => TryOrReturn<success, fallback>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 328
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrUndefined",
            "signature": "<success>(fn: () => success) => TryOrReturn<success, undefined>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 343
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "tryOrNull",
            "signature": "<success>(fn: () => success) => TryOrReturn<success, null>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/try.ts",
              "line": 355
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "is",
            "signature": "(value: unknown) => value is Error",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/type.ts",
              "line": 12
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isAggregateError",
            "signature": "(value: unknown) => value is AggregateError",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/type.ts",
              "line": 21
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isAbortError",
            "signature": "(error: any) => error is DOMException & { name: \"AbortError\"; }",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/type.ts",
              "line": 44
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensure",
            "signature": "(value: unknown) => Error",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/type.ts",
              "line": 57
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Context",
            "signature": "export type Context = object",
            "description": "Context information that can be attached to errors.\nMust be an object to ensure it can be properly serialized and inspected.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/types.ts",
              "line": 5
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ErrorWithContext",
            "signature": "export interface ErrorWithContext extends Error {\n  /**\n   * Additional context information about the error.\n   */\n  context?: Context\n}",
            "description": "An error that includes additional context information.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/types.ts",
              "line": 10
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "WrapOptions",
            "signature": "export interface WrapOptions {\n  /**\n   * The error message for the wrapper error.\n   */\n  message: string\n  /**\n   * Additional context to attach to the error.\n   */\n  context?: Context\n}",
            "description": "Options for wrapping errors with additional context.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/wrap.ts",
              "line": 9
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "wrap",
            "signature": "(cause: unknown, messageOrOptions: string | WrapOptions) => Error",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/wrap.ts",
              "line": 47
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrapOn",
            "signature": "(cause: unknown) => (messageOrOptions: string | WrapOptions) => Error",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/wrap.ts",
              "line": 77
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "wrapWith",
            "signature": "(messageOrOptions: string | WrapOptions) => (cause: unknown) => Error",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/err/wrap.ts",
              "line": 100
            },
            "_tag": "value",
            "type": "const"
          }
        ]
      }
    },
    {
      "packagePath": "./fn",
      "resolvedPath": "./src/domains/fn/$.ts",
      "module": {
        "name": "Fn",
        "description": "Function utilities for functional programming patterns.\n\nProvides utilities for function composition, currying, partial application,\npiping, and common functional patterns like identity and constant functions.\nIncludes function analysis tools and endomorphism utilities.",
        "exports": [
          {
            "name": "Parameter",
            "signature": "export type Parameter = { type: 'name'; value: string } | { type: 'destructured'; names: string[] }",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/analyze.ts",
              "line": 3
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "analyzeFunction",
            "signature": "(fn: (...args: any[]) => unknown) => { body: string; parameters: Parameter[]; }",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/analyze.ts",
              "line": 23
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AnyAny",
            "signature": "export type AnyAny = (...args: any[]) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 5
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParameters2",
            "signature": "export type AnyAnyParameters2 = (arg1: any, arg2: any) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin1",
            "signature": "export type AnyAnyParametersMin1 = (...args: [any, ...any[]]) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin2",
            "signature": "export type AnyAnyParametersMin2 = (...args: [any, any, ...any[]]) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 11
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin3",
            "signature": "export type AnyAnyParametersMin3 = (...args: [any, any, any, ...any[]]) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "is",
            "signature": "TypeGuard<AnyAny>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 15
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "AnyAnyAsync",
            "signature": "export type AnyAnyAsync = (...args: any[]) => Prom.AnyAny",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 17
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GuardedType",
            "signature": "export type GuardedType<$T> = $T extends (x: any) => x is infer __u__ ? __u__ : never",
            "description": "Extract the guarded type from a type guard function.",
            "examples": [
              {
                "code": "type T = GuardedType<typeof isString>  // string",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 28
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExtract",
            "signature": "export type ReturnExtract<$Type, $Fn extends AnyAny> =\n\t$Fn extends (...args: infer __args__) => infer __return__\n\t\t\t? (...args: __args__) =>\n        __return__ extends Prom.AnyAny\n          ? Promise<Extract<Awaited<__return__>, $Type>>\n          : Extract<__return__, $Type>\n\t\t\t: never",
            "description": "Modify function such that it only returns the given type.\n\nAutomatically handles async functions by unwrapping the Promise, extracting the type,\nand rewrapping in a Promise. For sync functions, the type is extracted directly.\n\nAssumes that the given type is among the possible return types of the function.",
            "examples": [
              {
                "code": "type Fn1 = (x: number) => string | number\ntype Result1 = ReturnExtract<string, Fn1>  // (x: number) => string\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string | number>\ntype Result2 = ReturnExtract<string, Fn2>  // (x: number) => Promise<string>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 50
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnReplace",
            "signature": "export type ReturnReplace<$Fn extends AnyAny, $Type> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => $Type\n    : never",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 59
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExclude",
            "signature": "export type ReturnExclude<$Type, $Fn extends AnyAny> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => (\n        __return__ extends Prom.AnyAny\n          ? Promise<Exclude<Awaited<__return__>, $Type>>\n          : Exclude<__return__, $Type>\n    )\n    : never",
            "description": "Modify function such that it does not return the given type.\n\nAutomatically handles async functions by unwrapping the Promise, excluding the type,\nand rewrapping in a Promise. For sync functions, the type is excluded directly.\n\nIf function does not return the given the type, then this is effectively an identity function.",
            "examples": [
              {
                "code": "type Fn1 = (x: number) => string | null\ntype Result1 = ReturnExclude<null, Fn1>  // (x: number) => string\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string | null>\ntype Result2 = ReturnExclude<null, Fn2>  // (x: number) => Promise<string>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 84
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExcludeNull",
            "signature": "export type ReturnExcludeNull<$Fn extends AnyAny> = ReturnExclude<null, $Fn>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 93
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnInclude",
            "signature": "export type ReturnInclude<$Type, $Fn extends AnyAny> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => (\n        __return__ extends Prom.AnyAny\n          ? Promise<$Type | Awaited<__return__>>\n          : $Type | __return__\n    )\n    : never",
            "description": "Modify function such that it can return an additional type along with its original return types.\n\nAutomatically handles async functions by unwrapping the Promise, adding the type to the union,\nand rewrapping in a Promise. For sync functions, the type is added directly to the return type union.\n\nThis is useful for functions that may return early with a specific type (like void).",
            "examples": [
              {
                "code": "type Fn1 = (x: number) => string\ntype Result1 = ReturnInclude<null, Fn1>  // (x: number) => string | null\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string>\ntype Result2 = ReturnInclude<null, Fn2>  // (x: number) => Promise<string | null>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 115
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "bind",
            "signature": "<fn extends AnyAny>(fn: AnyAnyParametersMin1 extends fn ? fn : { Error: \"Given function must have at least one parameter\"; }, arg: Parameters<fn>[0]) => bind<fn>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 126
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "noop",
            "signature": "() => void",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 143
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "$identityPartial",
            "signature": "<value>(value: PartialDeep<value>) => value",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 145
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "applySecond",
            "signature": "<fn extends (...args: any[]) => (arg: any) => any, arg>(fn: fn, arg: arg) => applySecond<fn, arg>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/base.ts",
              "line": 154
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "constant",
            "signature": "<value>(value: value) => () => value",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/constant.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AnyAny2Curried",
            "signature": "export type AnyAny2Curried = (arg1: any) => (arg2: any) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/curry.ts",
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "curry",
            "signature": "<fn extends AnyAny>(fn: AnyAnyParametersMin1 extends fn ? fn : { Error: \"Given function must have at least one parameter\"; }) => curry<fn>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/curry.ts",
              "line": 6
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "uncurry",
            "signature": "<fn extends AnyAny2Curried>(fn: fn) => uncurry<fn>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/curry.ts",
              "line": 54
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "flipCurried",
            "signature": "<fn extends AnyAny2Curried>(fn: fn) => flipCurried<fn>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/curry.ts",
              "line": 66
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "endo",
            "signature": "export type endo<$T = any> = ($value: $T) => $T",
            "description": "Endomorphism - a function from a type to itself.\n\nUnlike {@link identity}, this doesn't preserve the exact value,\njust ensures the output type matches the input type.",
            "examples": [
              {
                "code": "type BuilderOp = Fn.endo<StringBuilder>\nconst addText: BuilderOp = sb => sb.append('text')\n\n// Transformations\ntype StringTransform = Fn.endo<string>\nconst uppercase: StringTransform = s => s.toUpperCase()\nconst trim: StringTransform = s => s.trim()\n\n// Chainable operations\ntype ChainOp = Fn.endo<ChainableAPI>\nconst configure: ChainOp = api => api.setOption('key', 'value')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/endo.ts",
              "line": 23
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "identity",
            "signature": "identity<any>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/identity.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "_",
            "signature": "typeof _",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/partial/runtime.ts",
              "line": 14
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isHole",
            "signature": "(value: unknown) => value is typeof _",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/partial/runtime.ts",
              "line": 20
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "partial",
            "signature": "<$Fn extends Fn.AnyAny, const $Args extends readonly unknown[]>(fn: $Fn, ...args: $Args) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/partial/runtime.ts",
              "line": 47
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "apply",
            "signature": "<$Fn extends Fn.AnyAny, const $Args extends readonly unknown[]>(fn: $Fn, ...args: $Args) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/partial/runtime.ts",
              "line": 88
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "defer",
            "signature": "<$Fn extends Fn.AnyAny>(fn: $Fn, ...args: Parameters<$Fn>) => () => ReturnType<$Fn>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/partial/runtime.ts",
              "line": 108
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isPartialArg",
            "signature": "(_value: unknown) => _value is unknown",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/fn/partial/runtime.ts",
              "line": 119
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "pipe",
            "signature": "export function pipe<value>(value: value): value",
            "description": "Pipe a value through a series of unary functions.",
            "examples": [
              {
                "code": "const double = (x: number) => x * 2\nconst toString = (x: number) => x.toString()\n\npipe(5, add1, double) // 12\npipe(5, add1, double, toString) // \"12\"",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {
              "param": "- Functions to apply in sequence, each receiving the output of the previous",
              "returns": "The final transformed value",
              "remarks": "- Supports up to 10 functions with full type inference\n- Each function must be unary (take exactly one parameter)\n- Does not handle promise chaining - use with synchronous functions\n- For composing functions without an initial value, use {@link compose}"
            },
            "sourceLocation": {
              "file": "src/domains/fn/pipe.ts",
              "line": 25
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "packagePath": "./json",
      "resolvedPath": "./src/utils/json/$.ts",
      "module": {
        "name": "Json",
        "description": "JSON utilities with Effect Schema integration.\n\nProvides type-safe JSON operations including type guards, parsing, encoding,\nand validation using Effect Schema. Supports JSON primitives, objects, and\nrecursive value structures with comprehensive error handling.",
        "exports": [
          {
            "name": "Primitive",
            "signature": "export type Primitive = string | number | boolean | null",
            "description": "JSON primitive type.\nMatches: string, number, boolean, or null.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 16
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "Obj",
            "signature": "export type Obj = { [key in string]?: Value }",
            "description": "JSON object type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 21
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Value",
            "signature": "export type Value = Primitive | Obj | Value[]",
            "description": "JSON value type.\nMatches any valid JSON value: primitives, objects, or arrays (recursively).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 27
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "Object",
            "signature": "export type Obj = { [key in string]?: Value }",
            "description": "JSON object type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 21
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isPrimitive",
            "signature": "(value: unknown) => value is Primitive",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isValue",
            "signature": "(value: unknown) => value is Value",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 55
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isObject",
            "signature": "(value: unknown) => value is Obj",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 75
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PrimitiveSchema",
            "signature": "Union<[typeof String, typeof Number, typeof Boolean, typeof Null]>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 96
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ValueSchema",
            "signature": "Schema<Value, Value, never>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 108
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ObjectSchema",
            "signature": "Record$<typeof String, Schema<Value, Value, never>>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 120
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parseJsonSchema",
            "signature": "SchemaClass<unknown, string, never>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 126
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parseJsonAs",
            "signature": "<A>(schema: Schema<A, A, never>) => transform<SchemaClass<unknown, string, never>, Schema<A, A, never>>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 131
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "codec",
            "signature": "Codec<Value>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 145
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "encode",
            "signature": "Encode<Value>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 161
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "decode",
            "signature": "Decode<Value>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 167
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ObjectParser",
            "signature": "{ parse: (value: unknown) => { readonly [x: string]: Value; }; }",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/json/json.effect.ts",
              "line": 189
            },
            "_tag": "value",
            "type": "const"
          }
        ]
      }
    },
    {
      "packagePath": "./num",
      "resolvedPath": "./src/domains/num/$.ts",
      "module": {
        "name": "Num",
        "description": "Numeric types and utilities with branded types for mathematical constraints.\n\nProvides branded number types (Positive, Negative, Even, Odd, etc.) with\nruntime validation, mathematical operations, range types, and specialized\nnumeric domains like Complex, Ratio, and BigInt. Includes type guards,\nordering, and equivalence utilities.",
        "exports": [
          {
            "name": "Degrees",
            "signature": "export * from './degrees.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/degrees/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Even",
            "signature": "export * from './even.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/even/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Finite",
            "signature": "export * from './finite.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/finite/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Float",
            "signature": "export * from './float.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/float/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "InRange",
            "signature": "export * from './in-range.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/in-range/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Int",
            "signature": "export * from './int.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/int/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Natural",
            "signature": "export * from './natural.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/natural/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Negative",
            "signature": "export * from './negative.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/negative/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "NonNegative",
            "signature": "export * from './non-negative.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/non-negative/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "NonPositive",
            "signature": "export * from './non-positive.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/non-positive/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "NonZero",
            "signature": "export * from './non-zero.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/non-zero/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Odd",
            "signature": "export * from './odd.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/odd/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Percentage",
            "signature": "export * from './percentage.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/percentage/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Positive",
            "signature": "export * from './positive.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/positive/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Radians",
            "signature": "export * from './radians.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/radians/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "SafeInt",
            "signature": "export * from './safe-int.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/safe-int/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Whole",
            "signature": "export * from './whole.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/whole/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Zero",
            "signature": "export * from './zero.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/zero/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Prime",
            "signature": "export * from './prime.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/prime/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Ratio",
            "signature": "export * from './ratio.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/ratio/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Frac",
            "signature": "export * from './frac.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/frac/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Complex",
            "signature": "export * from './complex.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/complex/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "BigInt",
            "signature": "export * from './big-integer.js'\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/big-integer/$$.ts",
              "line": 1
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Arb",
            "signature": "Arb<number>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/traits/arb.ts",
              "line": 34
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Eq",
            "signature": "Eq<number>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/traits/eq.ts",
              "line": 21
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<number>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/traits/type.ts",
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "add",
            "signature": "(a: number, b: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "addWith",
            "signature": "(a: number) => (b: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 48
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "subtract",
            "signature": "(a: number, b: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 65
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "subtractWith",
            "signature": "(a: number) => (b: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 88
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "multiply",
            "signature": "(a: number, b: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 106
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "multiplyWith",
            "signature": "(b: number) => (a: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 132
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "divide",
            "signature": "(dividend: number, divisor: NonZero) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 151
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "divideWith",
            "signature": "(divisor: NonZero) => (dividend: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 177
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "power",
            "signature": "(base: number, exponent: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 204
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "powerWith",
            "signature": "(exponent: number) => (base: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 230
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "round",
            "signature": "(value: number, precision?: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 258
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "roundWith",
            "signature": "(precision?: number | undefined) => (value: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 286
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Floor",
            "signature": "export type Floor<_T extends number> = Int",
            "description": "Type-level floor transformation.\nFloor always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 292
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "floor",
            "signature": "<T extends Finite>(value: T) => Int",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 319
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Ceil",
            "signature": "export type Ceil<_T extends number> = Int",
            "description": "Type-level ceil transformation.\nCeil always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 327
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ceil",
            "signature": "<T extends Finite>(value: T) => Int",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 355
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Trunc",
            "signature": "export type Trunc<_T extends number> = Int",
            "description": "Type-level trunc transformation.\nTrunc always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 363
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "trunc",
            "signature": "<T extends Finite>(value: T) => Int",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 390
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sqrt",
            "signature": "export type Sqrt<T extends number> = T extends Positive ? Positive\n  : T extends NonNegative ? NonNegative\n  : number",
            "description": "Type-level sqrt transformation.\nSquare root of non-negative returns non-negative.\nSquare root of positive returns positive (except for 0).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 399
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sqrt",
            "signature": "<T extends NonNegative>(value: T) => Sqrt<T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 429
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "cbrt",
            "signature": "(value: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 451
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log",
            "signature": "(value: Positive) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 475
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log10",
            "signature": "(value: Positive) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 502
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log2",
            "signature": "(value: Positive) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 530
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sin",
            "signature": "export type Sin<_T extends number> = InRange<-1, 1>",
            "description": "Type-level sine transformation.\nSine always returns a value in the range [-1, 1].",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 538
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sin",
            "signature": "<T extends Finite>(radians: T) => Sin<_T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 565
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Cos",
            "signature": "export type Cos<_T extends number> = InRange<-1, 1>",
            "description": "Type-level cosine transformation.\nCosine always returns a value in the range [-1, 1].",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 573
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "cos",
            "signature": "<T extends Finite>(radians: T) => Cos<_T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 600
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tan",
            "signature": "(radians: Finite) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 628
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "asin",
            "signature": "(value: InRange<-1, 1>) => Radians",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 658
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "acos",
            "signature": "(value: InRange<-1, 1>) => Radians",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 689
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan",
            "signature": "(value: Finite) => Radians",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 718
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan2",
            "signature": "(y: Finite, x: Finite) => Radians",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 749
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan2With",
            "signature": "(y: Finite) => (x: Finite) => Radians",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 762
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "degToRad",
            "signature": "(degrees: Degrees) => Radians",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 790
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "radToDeg",
            "signature": "(radians: Radians) => Degrees",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 820
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Min",
            "signature": "export type Min<A extends number, B extends number> = A | B",
            "description": "Type-level min transformation.\nReturns the union of both input types (the more general type).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 828
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "min",
            "signature": "<A extends number, B extends number>(a: A, b: B) => Min<A, B>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 853
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "minWith",
            "signature": "(a: number) => (b: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 866
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Max",
            "signature": "export type Max<A extends number, B extends number> = A | B",
            "description": "Type-level max transformation.\nReturns the union of both input types (the more general type).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 872
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "max",
            "signature": "<A extends number, B extends number>(a: A, b: B) => Max<A, B>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 897
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "maxWith",
            "signature": "(a: number) => (b: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 910
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "gcd",
            "signature": "(a: Int, b: Int) => Natural",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 941
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "gcdWith",
            "signature": "(a: Int) => (b: Int) => Natural",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 971
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "lcm",
            "signature": "(a: Int, b: Int) => Whole",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 1002
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lcmWith",
            "signature": "(a: Int) => (b: Int) => Whole",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 1020
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "PI",
            "signature": "number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 1039
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "E",
            "signature": "number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 1059
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "TAU",
            "signature": "number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 1081
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "GOLDEN_RATIO",
            "signature": "number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/math.ts",
              "line": 1105
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "is",
            "signature": "(value: unknown) => value is number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 16
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isNaN",
            "signature": "(value: unknown) => value is number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 23
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Abs",
            "signature": "export type Abs<T extends number> = T extends Positive ? Positive\n  : T extends Negative ? Positive\n  : T extends NonPositive ? NonNegative\n  : T extends Zero ? Zero\n  : NonNegative",
            "description": "Type-level absolute value transformation.\nMaps number types to their absolute value types.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 31
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "abs",
            "signature": "<T extends number>(value: T) => Abs<T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sign",
            "signature": "export type Sign<T extends number> = T extends Positive ? 1\n  : T extends Negative ? -1\n  : T extends Zero ? 0\n  : -1 | 0 | 1",
            "description": "Type-level sign transformation.\nMaps number types to their sign (-1, 0, 1).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 58
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sign",
            "signature": "<T extends number>(value: T) => Sign<T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 78
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "inc",
            "signature": "(value: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 85
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "dec",
            "signature": "(value: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 92
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Mod",
            "signature": "export type Mod<_T extends number, _U extends NonZero> = NonNegative",
            "description": "Type-level modulo transformation.\nModulo always returns a non-negative result.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 100
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mod",
            "signature": "<T extends number, U extends NonZero>(dividend: T, divisor: U) => NonNegative",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 123
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "modOn",
            "signature": "<T extends number>(dividend: T) => <U extends NonZero>(divisor: U) => NonNegative",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 141
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "modWith",
            "signature": "<U extends NonZero>(divisor: U) => <T extends number>(dividend: T) => NonNegative",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 162
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "NumberLiteral",
            "signature": "export type NumberLiteral = number",
            "description": "Number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 169
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PlusOne",
            "signature": "export type PlusOne<$n extends NumberLiteral> = [\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n  20,\n  21,\n][\n  $n\n]",
            "description": "Add one to a number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 174
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MinusOne",
            "signature": "export type MinusOne<$n extends NumberLiteral> = [\n  -1,\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n][\n  $n\n]",
            "description": "Subtract one from a number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/operations.ts",
              "line": 203
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RangeOptions",
            "signature": "export interface RangeOptions {\n  /**\n   * The step between each number in the range.\n   * @default 1\n   */\n  step?: number\n  /**\n   * Whether to include the end value in the range.\n   * @default false\n   */\n  inclusive?: boolean\n}",
            "description": "Options for generating numeric ranges.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 4
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "range",
            "signature": "(start: number, end: number, options?: RangeOptions | undefined) => number[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeFrom",
            "signature": "(start: number) => (end: number, options?: RangeOptions | undefined) => number[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 96
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeTo",
            "signature": "(end: number) => (start: number, options?: RangeOptions | undefined) => number[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 117
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeStep",
            "signature": "(start: number, end: number, step: number) => number[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 136
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeStepWith",
            "signature": "(step: number) => (start: number, end: number) => number[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 157
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeInclusive",
            "signature": "(start: number, end: number) => number[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 175
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "times",
            "signature": "<T>(n: number, fn: (index: number) => T) => T[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 200
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "timesWith",
            "signature": "<T>(fn: (index: number) => T) => (n: number) => T[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 229
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lerp",
            "signature": "(start: number, end: number, t: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 259
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lerpBetween",
            "signature": "(start: number, end: number) => (t: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 309
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mapRange",
            "signature": "(value: number, fromMin: number, fromMax: number, toMin: number, toMax: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 339
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mapRangeFrom",
            "signature": "(fromMin: number, fromMax: number, toMin: number, toMax: number) => (value: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 414
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "sequence",
            "signature": "(n: number) => number[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 440
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrap",
            "signature": "(value: number, min: number, max: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 471
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrapWithin",
            "signature": "(min: number, max: number) => (value: number) => number",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/num/range.ts",
              "line": 534
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "packagePath": "./obj",
      "resolvedPath": "./src/domains/obj/$.ts",
      "module": {
        "name": "Obj",
        "description": "Object utilities for working with plain JavaScript objects.\n\nProvides type-safe utilities for object operations including property access,\nmanipulation, merging, filtering, and transformations. Supports both value-level\nand type-level operations with strong type inference.",
        "exports": [
          {
            "name": "Eq",
            "signature": "Eq<object>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/traits/eq.ts",
              "line": 33
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<object>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/traits/type.ts",
              "line": 5
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "pick",
            "signature": "<T extends object, K extends keyof T>(obj: T, keys: readonly K[]) => Pick<T, K>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "omit",
            "signature": "<T extends object, K extends keyof T>(obj: T, keys: readonly K[]) => Omit<T, K>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 80
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "policyFilter",
            "signature": "<$Object extends object, $Key extends Keyof<$Object>, $Mode extends \"allow\" | \"deny\">(mode: $Mode, obj: $Object, keys: readonly $Key[]) => PolicyFilter<$Object, $Key, $Mode>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 106
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "filter",
            "signature": "<$Object extends object>(obj: $Object, predicate: (key: keyof $Object, value: $Object[keyof $Object], obj: $Object) => boolean) => Partial<$Object>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 149
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "partition",
            "signature": "<$Object extends object, $Key extends keyof $Object>(obj: $Object, pickedKeys: readonly $Key[]) => { omitted: Omit<$Object, $Key>; picked: Pick<$Object, $Key>; }",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 177
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "pickMatching",
            "signature": "<T extends object>(obj: T, predicate: (key: string) => boolean) => Partial<T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 214
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Keyof",
            "signature": "export type Keyof<$Object extends object> = object extends $Object ? PropertyKey : (keyof $Object)",
            "description": "Like keyof but returns PropertyKey for object type.\nHelper type for generic object key operations.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 241
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PolicyFilter",
            "signature": "export type PolicyFilter<\n  $Object extends object,\n  $Key extends Keyof<$Object>,\n  $Mode extends 'allow' | 'deny',\n> = $Mode extends 'allow'\n      ? Pick<$Object, Extract<$Key, keyof $Object>>\n      : Omit<$Object, Extract<$Key, keyof $Object>>",
            "description": "Filter object properties based on a policy mode and set of keys.",
            "examples": [
              {
                "code": "// Allow mode: keep only specified keys\ntype PublicUser = PolicyFilter<User, 'id' | 'name', 'allow'>\n// Result: { id: number; name: string }\n\n// Deny mode: remove specified keys\ntype SafeUser = PolicyFilter<User, 'password', 'deny'>\n// Result: { id: number; name: string; email: string }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 258
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickWhereValueExtends",
            "signature": "export type PickWhereValueExtends<$Obj extends object, $Constraint> = {\n  [k in keyof $Obj as $Obj[k] extends $Constraint ? k : never]: $Obj[k]\n}",
            "description": "Pick properties from an object where the values extend a given constraint.",
            "examples": [
              {
                "code": "type BooleanProps = PickWhereValueExtends<User, boolean>\n// Result: { isActive: boolean; flag: boolean }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 275
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "SuffixKeyNames",
            "signature": "export type SuffixKeyNames<$Suffix extends string, $Object extends object> = {\n  [k in keyof $Object as k extends string ? `${k}${$Suffix}` : k]: $Object[k]\n}",
            "description": "Add a suffix to all property names in an object.",
            "examples": [
              {
                "code": "// { a_old: string; b_old: number }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 288
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OmitKeysWithPrefix",
            "signature": "export type OmitKeysWithPrefix<$Object extends object, $Prefix extends string> = {\n  [k in keyof $Object as k extends `${$Prefix}${string}` ? never : k]: $Object[k]\n}",
            "description": "Omit all keys that start with a specific prefix.",
            "examples": [
              {
                "code": "// { c: boolean }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 301
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickRequiredProperties",
            "signature": "export type PickRequiredProperties<$T extends object> = {\n  [k in keyof $T as {} extends Pick<$T, k> ? never : k]: $T[k]\n}",
            "description": "Pick only the required (non-optional) properties from an object.",
            "examples": [
              {
                "code": "",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 313
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RequireProperties",
            "signature": "export type RequireProperties<$O extends object, $K extends keyof $O> = Ts.Simplify<$O & { [k in $K]-?: $O[k] }>",
            "description": "Make specific properties required in an object.",
            "examples": [
              {
                "code": "// { a: string; b?: number }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 326
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PartialOrUndefined",
            "signature": "export type PartialOrUndefined<$T> = {\n  [k in keyof $T]?: $T[k] | undefined\n}",
            "description": "Make all properties optional and allow undefined values.",
            "examples": [
              {
                "code": "// { a?: string | undefined; b?: number | undefined }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 337
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickOptionalPropertyOrFallback",
            "signature": "export type PickOptionalPropertyOrFallback<$Object extends object, $Property extends keyof $Object, $Fallback> =\n  {} extends Pick<$Object, $Property> ? $Object[$Property] : $Fallback",
            "description": "Pick an optional property or use fallback if required.",
            "examples": [
              {
                "code": "type T2 = PickOptionalPropertyOrFallback<{ a: string }, 'a', never>  // never",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 350
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OnlyKeysInArray",
            "signature": "export type OnlyKeysInArray<$Obj extends object, $KeysArray extends readonly string[]> = {\n  [k in keyof $Obj as k extends $KeysArray[number] ? k : never]: $Obj[k]\n}",
            "description": "Pick only the properties from an object that exist in a provided array of keys.",
            "examples": [
              {
                "code": "type PublicUser = OnlyKeysInArray<User, ['name', 'email']>\n// Result: { name: string; email: string }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/filter.ts",
              "line": 362
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "getWith",
            "signature": "<pathInput extends PropertyPathInput>(pathInput: pathInput) => <obj extends InferShapeFromPropertyPath<normalizePropertyPathInput<pathInput>>>(obj: obj) => getWith<normalizePropertyPathInput<pathInput>, obj>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 61
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getOn",
            "signature": "(obj: object) => (pathInput: PropertyPathInput) => unknown",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 118
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "entries",
            "signature": "<obj extends Any>(obj: obj) => { [K in keyof obj]-?: undefined extends obj[K] ? {} extends Pick<obj, K> ? [K, Exclude<obj[K]>] : [K, obj[K]] : [K, obj[K]]; }[keyof obj][]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 150
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "stringKeyEntries",
            "signature": "<$T extends object>(obj: $T) => [string & keyof $T, $T[keyof $T]][]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 175
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "entriesStrict",
            "signature": "<$T extends object>(obj: $T) => { [k in keyof $T]: [k, Exclude<$T[k], undefined>]; }[keyof $T][]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 190
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "keysStrict",
            "signature": "<$T extends object>(obj: $T) => (keyof $T)[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 210
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getRandomly",
            "signature": "<obj extends Any>(obj: obj) => keyof obj extends never ? undefined : obj[keyof obj]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 226
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getValueAtPath",
            "signature": "<$T, ___Path extends readonly string[]>(obj: $T, path: ___Path) => any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 253
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "values",
            "signature": "<$T extends object>(obj: $T) => values<$T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 281
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "GetKeyOr",
            "signature": "export type GetKeyOr<$T, $Key, $Or> = $Key extends keyof $T ? $T[$Key] : $Or",
            "description": "Get value at key, or return fallback if key doesn't exist.",
            "examples": [
              {
                "code": "type T2 = GetKeyOr<{ a: string }, 'b', never>  // never",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 296
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GetOrNever",
            "signature": "export type GetOrNever<$O extends object, $P extends string> = $P extends keyof $O ? $O[$P]\n  : $P extends `${infer __head__}.${infer __tail__}`\n    ? __head__ extends keyof $O ? GetOrNever<$O[__head__] & object, __tail__>\n    : never\n  : never",
            "description": "Get value at key or return never.",
            "examples": [
              {
                "code": "type T2 = GetOrNever<{ a: string }, 'b'>  // never",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 307
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "keyofOr",
            "signature": "export type keyofOr<$Obj extends object, $Or> = [keyof $Obj] extends [never] ? $Or : $Obj[keyof $Obj]",
            "description": "Get the union of all value types from an object, or return fallback if no keys.",
            "examples": [
              {
                "code": "type T2 = keyofOr<{}, 'fallback'>  // 'fallback'",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 322
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "KeysArray",
            "signature": "export type KeysArray<$Obj extends object> = Array<keyof $Obj>",
            "description": "Create an array type containing the keys of an object.",
            "examples": [
              {
                "code": "type UserKeys = KeysArray<User>\n// Result: Array<'name' | 'age' | 'email'>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 333
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "KeysReadonlyArray",
            "signature": "export type KeysReadonlyArray<$Obj extends object> = ReadonlyArray<keyof $Obj>",
            "description": "Create a readonly array type containing the keys of an object.",
            "examples": [
              {
                "code": "type UserKeys = KeysReadonlyArray<User>\n// Result: ReadonlyArray<'name' | 'age' | 'email'>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 344
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StringKeyof",
            "signature": "export type StringKeyof<$T> = keyof $T & string",
            "description": "Extract only string keys from an object.",
            "examples": [
              {
                "code": "",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 354
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "PrimitiveFieldKeys",
            "signature": "export type PrimitiveFieldKeys<$T> = {\n  [K in keyof $T]: $T[K] extends string | number | boolean | bigint | null | undefined ? K\n    : $T[K] extends Date ? K\n    : never\n}[keyof $T]",
            "description": "Extract keys from an object type that have primitive values.\nUseful for serialization scenarios where only primitive values can be safely transferred.",
            "examples": [
              {
                "code": "id: number\n  name: string\n  createdAt: Date\n  metadata: { tags: string[] }\n  isActive: boolean\n}\ntype SerializableKeys = PrimitiveFieldKeys<User>\n// Result: 'id' | 'name' | 'createdAt' | 'isActive'\n// Note: Date is considered primitive for serialization purposes",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/get.ts",
              "line": 373
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "DeepObjectValue",
            "signature": "export type DeepObjectValue = string | boolean | null | number | DeepObject | DeepObjectValue[]",
            "description": "A deep object value can be any JSON-serializable value including nested objects and arrays.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/map-entries-deep.ts",
              "line": 6
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "DeepObject",
            "signature": "export type DeepObject = { [key: string]: DeepObjectValue }",
            "description": "A deep object is a plain object with string keys and deep object values.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/map-entries-deep.ts",
              "line": 11
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mapEntriesDeep",
            "signature": "<$value extends DeepObjectValue>(value: $value, visitor: (key: string, value: DeepObjectValue) => { key: string; value: DeepObjectValue; } | undefined) => $value",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/map-entries-deep.ts",
              "line": 41
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mergeWith",
            "signature": "(mergers?: MergeOptions | undefined) => <obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 41
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "merge",
            "signature": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 77
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeWithArrayPush",
            "signature": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 102
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeWithArrayPushDedupe",
            "signature": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 131
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeDefaults",
            "signature": "<obj1 extends Any, obj1Defaults extends Partial<obj1>>(obj1: obj1, obj1Defaults: obj1Defaults) => { [_ in keyof (obj1 & obj1Defaults)]: (obj1 & obj1Defaults)[_]; }",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 165
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "shallowMergeDefaults",
            "signature": "<$Defaults extends object, $Input extends object>(defaults: $Defaults, input: $Input) => $Defaults & $Input",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 187
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "spreadShallow",
            "signature": "<$Objects extends readonly (object | undefined)[]>(...objects: $Objects) => {}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 220
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "MergeShallow",
            "signature": "export type MergeShallow<\n  $Object1 extends Any,\n  $Object2 extends Any,\n  __ =\n    {} extends $Object1\n      ? $Object2\n      : & $Object2\n        // Keys from $Object1 that are NOT in $Object2\n        & {\n            [__k__ in keyof $Object1 as __k__ extends keyof $Object2 ? never : __k__]: $Object1[__k__]\n          }\n> = __",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 247
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MergeAllShallow",
            "signature": "export type MergeAllShallow<$Objects extends readonly object[]> =\n  $Objects extends readonly [infer $First extends object, ...infer $Rest extends object[]]\n    ? $Rest extends readonly []\n      ? $First\n      : MergeShallow<$First, MergeAllShallow<$Rest>>\n    : {}",
            "description": "Recursively merge an array of objects using shallow merge semantics.\nEach object in the array overrides properties from previous objects.",
            "examples": [
              {
                "code": "// Result: { a: string; b: number; c: boolean }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 271
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MergeAll",
            "signature": "export type MergeAll<$Objects extends object[]> = $Objects extends\n  [infer __first__ extends object, ...infer __rest__ extends object[]] ? __first__ & MergeAll<__rest__>\n  : {}",
            "description": "Merge an array of object types into a single type using deep merge semantics.\nUses TypeScript's intersection type (`&`) for merging.",
            "examples": [
              {
                "code": "// Result: { a: string; b: number }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 288
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReplaceProperty",
            "signature": "export type ReplaceProperty<$Obj extends object, $Key extends keyof $Obj, $NewType> =\n  & Omit<$Obj, $Key>\n  & {\n    [_ in $Key]: $NewType\n  }",
            "description": "Replace the type of a specific property in an object.",
            "examples": [
              {
                "code": "type UpdatedUser = ReplaceProperty<User, 'id', string>\n// Result: { id: string; name: string; age: number }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 301
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "Replace",
            "signature": "export type Replace<$Object1, $Object2> = Omit<$Object1, keyof $Object2> & $Object2",
            "description": "Replace properties in an object type with new types.\nUseful for overriding specific property types.",
            "examples": [
              {
                "code": "type SerializedUser = Replace<User, { createdAt: string }>\n// Result: { id: number; name: string; createdAt: string }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/merge.ts",
              "line": 317
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "assert",
            "signature": "export function assert(value: unknown): void",
            "description": "Assert that a value is an object.\nThrows a TypeError if the value is not an object (including null).",
            "examples": [
              {
                "code": "Obj.assert(value)\n  // value is now typed as object\n  console.log(Object.keys(value))\n}",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- The value to check",
              "throws": "If the value is not an object"
            },
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 32
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isShape",
            "signature": "<type>(spec: Record<PropertyKey, \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\">) => (value: unknown) => value is type",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 69
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "setPrivateState",
            "signature": "<obj extends Any>(obj: obj, value: object) => obj",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 110
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getPrivateState",
            "signature": "<state extends Any>(obj: object) => state",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 151
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "hasNonUndefinedKeys",
            "signature": "(object: object) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 169
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PartialDeep",
            "signature": "export type PartialDeep<$Type> =\n  $Type extends Array<infer __inner__>                  ? Array<PartialDeep<__inner__>> :\n  $Type extends ReadonlyArray<infer __inner__>          ? ReadonlyArray<PartialDeep<__inner__>> :\n  $Type extends Promise<infer __inner__>                ? Promise<PartialDeep<__inner__>> :\n  $Type extends Function                                ? $Type :\n  $Type extends object                                  ? {\n                                                            [key in keyof $Type]?: PartialDeep<$Type[key]>\n                                                          } :\n                                                        // else\n                                                          $Type",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 176
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Writeable",
            "signature": "export type Writeable<$Obj extends object> = Writable<$Obj>",
            "description": "Make all properties of an object writable (remove readonly modifiers).",
            "examples": [
              {
                "code": "type WritableUser = Writeable<ReadonlyUser>\n// Result: { id: number; name: string }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 211
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ToParameters",
            "signature": "export type ToParameters<$Params extends object | undefined> =\n  undefined extends $Params ? [params?: $Params] :\n  $Params extends undefined ? [params?: $Params] :\n                              [params: $Params]",
            "description": "Convert an object to a parameters tuple.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 217
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ToParametersExact",
            "signature": "export type ToParametersExact<\n  $Input extends object,\n  $Params extends object | undefined,\n> = IsEmpty<$Input> extends true ? []\n  : ToParameters<$Params>",
            "description": "Convert an object to parameters tuple with exact matching.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 225
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyKeyToString",
            "signature": "export type PropertyKeyToString<$Key extends PropertyKey> = $Key extends string ? $Key\n  : $Key extends number ? `${$Key}`\n  : never",
            "description": "Convert PropertyKey to string if possible.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/obj.ts",
              "line": 234
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPathExpression",
            "signature": "export type PropertyPathExpression = string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPath",
            "signature": "export type PropertyPath = readonly string[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 6
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPathInput",
            "signature": "export type PropertyPathInput = PropertyPathExpression | PropertyPath",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 8
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "normalizePropertyPathInput",
            "signature": "<pathInput extends PropertyPathInput>(pathInput: pathInput) => normalizePropertyPathInput<pathInput>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 29
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PropertyPathSeparator",
            "signature": "\".\"",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 50
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parsePropertyPathExpression",
            "signature": "<expression extends string>(expression: expression) => parsePropertyPathExpression<expression>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 77
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "InferShapeFromPropertyPath",
            "signature": "export type InferShapeFromPropertyPath<$PropertyPath extends PropertyPath> =\n\t$PropertyPath extends readonly []\n\t\t? {}\n\t\t: _InferShapeFromPropertyPath<$PropertyPath>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 88
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "_InferShapeFromPropertyPath",
            "signature": "export type _InferShapeFromPropertyPath<$PropertyPath extends PropertyPath> =\n  $PropertyPath extends readonly [infer __key__ extends string, ...infer __tail__ extends readonly string[]]\n    ? { [_ in __key__]?: InferShapeFromPropertyPath<__tail__> }\n    : unknown",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/path.ts",
              "line": 94
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Any",
            "signature": "export type Any = object",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsEmpty",
            "signature": "export type IsEmpty<$Obj extends object> = keyof $Obj extends never ? true : false",
            "description": "Type-level check to determine if an object type has no keys.",
            "examples": [
              {
                "code": "type NotEmpty = IsEmpty<{ a: 1 }> // false",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 24
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Empty",
            "signature": "export type Empty = Record<string, never>",
            "description": "Type for an empty object.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 29
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "empty",
            "signature": "() => Empty",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 49
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "NoExcess",
            "signature": "export type NoExcess<$Expected, $Actual> = $Actual & Record<Exclude<keyof $Actual, keyof $Expected>, never>",
            "description": "Enforces that a type has no excess properties beyond those defined in the expected type.\n\nThis utility intersects the actual type with a record that marks all excess keys as `never`,\ncausing TypeScript to reject values with properties not present in the expected type.\nParticularly useful in generic contexts where excess property checking is bypassed.",
            "examples": [
              {
                "code": "// Standard generic - allows excess properties\nfunction test1<T extends User>(input: T): void {}\ntest1({ name: 'Alice', age: 30, extra: true })  // ✓ No error (excess allowed)\n\n// With NoExcess - rejects excess\nfunction test2<T extends User>(input: Obj.NoExcess<User, T>): void {}\ntest2({ name: 'Alice', age: 30, extra: true })  // ✗ Error: 'extra' is never\ntest2({ name: 'Alice', age: 30 })  // ✓ OK",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "type Config = { id: string; debug?: boolean }\n\nfunction configure<T extends Config>(config: Obj.NoExcess<Config, T>): void {}\n\nconfigure({ id: 'test' })  // ✓ OK - optional omitted\nconfigure({ id: 'test', debug: true })  // ✓ OK - optional included\nconfigure({ id: 'test', invalid: 'x' })  // ✗ Error: 'invalid' is never",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- The actual type to check for excess properties",
              "remarks": "This works by creating a type that's the intersection of:\n1. The actual type as-is\n2. A record marking excess keys (keys in Actual but not in Expected) as `never`\n\nWhen a property is typed as `never`, TypeScript requires that it either:\n- Not be present at all, OR\n- Have a value that extends `never` (which is impossible for non-never types)\n\nThis forces a type error when excess properties are provided.",
              "see": "{@link NoExcessNonEmpty} for non-empty variant"
            },
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 100
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "NoExcessNonEmpty",
            "signature": "export type NoExcessNonEmpty<$Value extends object, $Constraint> = IsEmpty<$Value> extends true ? never\n  : NoExcess<$Constraint, $Value>",
            "description": "Like {@link NoExcess} but also requires the object to be non-empty.\n\nEnforces that:\n1. Object has at least one property (not empty)\n2. Object has no excess properties beyond the constraint",
            "examples": [
              {
                "code": "type T1 = NoExcessNonEmpty<{ name: 'Alice' }, User>        // ✓ Pass\ntype T2 = NoExcessNonEmpty<{}, User>                       // ✗ Fail - empty\ntype T3 = NoExcessNonEmpty<{ name: 'Bob', age: 30 }, User> // ✗ Fail - excess",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 118
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isEmpty",
            "signature": "(obj: object) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 151
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isEmpty$",
            "signature": "<$T extends object>(obj: $T) => obj is $T & Empty",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/type.ts",
              "line": 182
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "HasOptionalKeys",
            "signature": "export type HasOptionalKeys<$Obj extends object> = OptionalKeys<$Obj> extends never ? false : true",
            "description": "Check if an interface has any optional properties.",
            "examples": [
              {
                "code": "type T2 = HasOptionalKeys<{ a: string }>  // false",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/predicates.ts",
              "line": 12
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OptionalKeys",
            "signature": "export type OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]",
            "description": "Extract keys that are optional in the interface.",
            "examples": [
              {
                "code": "type Optional = OptionalKeys<Obj>  // 'b' | 'c'",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/predicates.ts",
              "line": 23
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RequiredKeys",
            "signature": "export type RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>",
            "description": "Extract keys that are required in the interface.",
            "examples": [
              {
                "code": "type Required = RequiredKeys<Obj>  // 'a'",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/predicates.ts",
              "line": 36
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasRequiredKeys",
            "signature": "export type HasRequiredKeys<$Obj extends object> = RequiredKeys<$Obj> extends never ? false : true",
            "description": "Check if an interface has any required properties.",
            "examples": [
              {
                "code": "type T2 = HasRequiredKeys<{ a?: string }>  // false\ntype T3 = HasRequiredKeys<{ a: string; b?: number }>  // true",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/predicates.ts",
              "line": 48
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasOptionalKey",
            "signature": "export type HasOptionalKey<$Object extends object, $Key extends keyof $Object> = undefined extends $Object[$Key] ? true\n  : false",
            "description": "Check if a key is optional in an object.",
            "examples": [
              {
                "code": "type T2 = HasOptionalKey<{ a: string }, 'a'>  // false",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/predicates.ts",
              "line": 59
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsKeyOptional",
            "signature": "export type IsKeyOptional<$T extends Undefined.Maybe<object>, $K extends string> = $K extends keyof $T\n  ? ({} extends Pick<$T, $K> ? true : false)\n  : false",
            "description": "Check if a key is optional in an object.",
            "examples": [
              {
                "code": "type T2 = IsKeyOptional<{ a: string }, 'a'>  // false\ntype T3 = IsKeyOptional<{ a: string }, 'b'>  // false",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/predicates.ts",
              "line": 72
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasKey",
            "signature": "export type HasKey<$T extends object, $K extends string> = $K extends keyof $T ? true : false",
            "description": "Check if a key exists in an object.",
            "examples": [
              {
                "code": "type T2 = HasKey<{ a: string }, 'b'>  // false",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/predicates.ts",
              "line": 85
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertySignature",
            "signature": "export type PropertySignature = {\n  name: string\n  type: any\n  optional: boolean\n  optionalUndefined: boolean\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/property-signature.ts",
              "line": 1
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mapValues",
            "signature": "<rec extends Record<PropertyKey, any>, newValue>(obj: rec, fn: (value: rec[keyof rec], key: keyof rec) => newValue) => Record<keyof rec, newValue>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/obj/update.ts",
              "line": 23
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "packagePath": "./prom",
      "resolvedPath": "./src/domains/prom/$.ts",
      "module": {
        "name": "Prom",
        "description": "Promise utilities for asynchronous operations.\n\nProvides utilities for working with Promises including deferred promise\ncreation, promise combinators, and async control flow patterns.",
        "exports": [
          {
            "name": "Deferred",
            "signature": "export interface Deferred<$Value> {\n  /**\n   * The promise that will be resolved or rejected.\n   */\n  promise: Promise<$Value>\n  /**\n   * Resolve the promise with a value.\n   */\n  resolve: (value: $Value) => void\n  /**\n   * Reject the promise with an error.\n   */\n  reject: (error: unknown) => void\n  /**\n   * Whether the promise has been resolved.\n   */\n  readonly isResolved: boolean\n  /**\n   * Whether the promise has been rejected.\n   */\n  readonly isRejected: boolean\n  /**\n   * Whether the promise has been settled (resolved or rejected).\n   */\n  readonly isSettled: boolean\n}",
            "description": "A deferred promise with exposed resolve and reject functions.",
            "examples": [
              {
                "code": "// Later resolve it\ndeferred.resolve(42)\n\n// Or reject it\ndeferred.reject(new Error('failed'))\n\n// Use the promise\nawait deferred.promise  // 42",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "const deferred = createDeferred<number>()\nconsole.log(deferred.isResolved)  // false\ndeferred.resolve(42)\nconsole.log(deferred.isResolved)  // true\nconsole.log(deferred.isSettled)   // true",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/deferred.ts",
              "line": 28
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "createDeferred",
            "signature": "<$T>(options?: { strict?: boolean; } | undefined) => Deferred<$T>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/deferred.ts",
              "line": 82
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "maybeAsync",
            "signature": "export function maybeAsync<T, R = T, E = unknown>(fn: () => T, handlers: MaybeAsyncHandlers<T extends Promise<infer U> ? U : T, R, E> = {}): T extends Promise<infer U> ? Promise<R | E | U> : T | R | E",
            "description": "Handle a function that might return a promise or a regular value,\nwith unified handlers for both sync and async cases.",
            "examples": [
              {
                "code": "const result = maybeAsync(\n  () => fetchData(),\n  {\n    then: (data) => processData(data),\n    catch: (error) => ({ success: false, error })\n  }\n)\n\n// Just error handling\nconst safeResult = maybeAsync(\n  () => riskyOperation(),\n  {\n    catch: (error, isAsync) => {\n      console.error(`Failed ${isAsync ? 'async' : 'sync'}:`, error)\n      return null\n    }\n  }\n)\n\n// Just success handling\nconst transformed = maybeAsync(\n  () => getValue(),\n  {\n    then: (value) => value.toUpperCase()\n  }\n)",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- Object with then/catch handlers",
              "returns": "The result, potentially wrapped in a Promise"
            },
            "sourceLocation": {
              "file": "src/domains/prom/prom.ts",
              "line": 137
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Any",
            "signature": "export type Any = Promise<unknown>",
            "description": "Type representing a Promise of unknown type.\nUseful for generic promise handling where the resolved type is not important.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/prom.ts",
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAny",
            "signature": "export type AnyAny = Promise<any>",
            "description": "Type representing a Promise of any type.\nLess type-safe than {@link Any}, use with caution.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/prom.ts",
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Maybe",
            "signature": "export type Maybe<$Type> = $Type | Promise<$Type>",
            "description": "Type representing a value that may or may not be wrapped in a Promise.",
            "examples": [
              {
                "code": "function process<T>(value: Maybe<T>): Promise<T> {\n  return Promise.resolve(value)\n}\n\nprocess(42) // accepts number\nprocess(Promise.resolve(42)) // accepts Promise<number>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/prom.ts",
              "line": 29
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "isShape",
            "signature": "(value: unknown) => value is AnyAny",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/prom.ts",
              "line": 51
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AwaitedUnion",
            "signature": "export type AwaitedUnion<$MaybePromise, $Additional> =\n  $MaybePromise extends Promise<infer __promised__>\n    ? Promise<Awaited<__promised__ | $Additional>>\n    : $MaybePromise | $Additional",
            "description": "Type that adds an additional type to a potentially promised union.\nIf the input is a Promise, the additional type is added to the promised value.\nIf the input is not a Promise, creates a union with the additional type.",
            "examples": [
              {
                "code": "type Result1 = AwaitedUnion<Promise<string>, number> // Promise<string | number>\n\n// with non-promise input\ntype Result2 = AwaitedUnion<string, number> // string | number",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/prom.ts",
              "line": 76
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MaybeAsyncHandlers",
            "signature": "export interface MaybeAsyncHandlers<T, R = T, E = unknown> {\n  /**\n   * Handler for successful values (sync or async).\n   */\n  then?: (value: T) => R\n\n  /**\n   * Handler for errors (sync or async).\n   * @param error - The caught error\n   * @param isAsync - Whether the error occurred asynchronously\n   */\n  catch?: (error: unknown, isAsync: boolean) => E\n}",
            "description": "Options for handling values that might be promises.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/prom/prom.ts",
              "line": 84
            },
            "_tag": "type",
            "type": "interface"
          }
        ]
      }
    },
    {
      "packagePath": "./rec",
      "resolvedPath": "./src/domains/rec/$.ts",
      "module": {
        "name": "Rec",
        "description": "Record utilities for working with plain JavaScript objects as dictionaries.\n\nProvides type-safe operations for records (objects with PropertyKey indexes)\nincluding type guards, merging, creation, and index signature manipulation.\nStrictly validates plain objects, rejecting arrays and class instances.",
        "exports": [
          {
            "name": "Any",
            "signature": "export type Any = AnyKeyTo<unknown>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyReadonly",
            "signature": "export type AnyReadonly = AnyReadonlyKeyTo<unknown>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 6
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyKeyTo",
            "signature": "export type AnyKeyTo<$Value> = {\n  [key: PropertyKey]: $Value\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 8
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyReadonlyKeyTo",
            "signature": "export type AnyReadonlyKeyTo<$Value> = {\n  readonly [key: PropertyKey]: $Value\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 12
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Value",
            "signature": "export type Value = {\n  [key: PropertyKey]: Lang.Value\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 16
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "is",
            "signature": "(value: unknown) => value is Any",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "merge",
            "signature": "<rec1 extends Any, rec2 extends Any>(rec1: rec1, rec2: rec2) => rec1 & rec2",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 97
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Optional",
            "signature": "export type Optional<$Key extends PropertyKey, $Value> = {\n  [K in $Key]?: $Value\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 101
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RemoveIndex",
            "signature": "export type RemoveIndex<$T> = {\n  [k in keyof $T as string extends k ? never : number extends k ? never : k]: $T[k]\n}",
            "description": "Remove index signatures from an object type.\nUseful for converting Record types to object types with only known keys.",
            "examples": [
              {
                "code": "type WithoutIndex = RemoveIndex<WithIndex>  // { a: string; b: number }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 115
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsHasIndex",
            "signature": "export type IsHasIndex<$T, $Key extends PropertyKey = string> = $Key extends keyof $T ? true : false",
            "description": "Check if a type has an index signature.",
            "examples": [
              {
                "code": "type T2 = IsHasIndex<{ a: string }>  // false\ntype T3 = IsHasIndex<{ [key: number]: any }, number>  // true",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 129
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "create",
            "signature": "<value>() => Record<PropertyKey, value>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/rec/rec.ts",
              "line": 169
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "packagePath": "./str",
      "resolvedPath": "./src/domains/str/$.ts",
      "module": {
        "name": "Str",
        "description": "String utilities for text manipulation and analysis.\n\nProvides comprehensive string operations including case conversion, splitting,\nmatching, replacement, templating, and character utilities. Features type-safe\nAPIs with strong inference for string literals and patterns.",
        "exports": [
          {
            "name": "Arb",
            "signature": "Arb<string>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/traits/arb.ts",
              "line": 31
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Eq",
            "signature": "Eq<string>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/traits/eq.ts",
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": "Type<string>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/traits/type.ts",
              "line": 5
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Empty",
            "signature": "export type Empty = ''",
            "description": "Type for an empty string.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type.ts",
              "line": 18
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isEmpty",
            "signature": "(value: string) => value is \"\"",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type.ts",
              "line": 13
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "defaultRender",
            "signature": "(value: string[]) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/builder.ts",
              "line": 11
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Builder",
            "signature": "export interface Builder {\n  /**\n   * Add lines to the builder.\n   * @param linesInput - Lines to add (null values are filtered out)\n   * @returns The builder instance for chaining\n   */\n  (...linesInput: LinesInput): Builder\n  /**\n   * Add content using template literal syntax.\n   * @param strings - Template string array\n   * @param values - Interpolated values\n   * @returns The builder instance for chaining\n   */\n  (strings: TemplateStringsArray, ...values: string[]): Builder\n  /**\n   * The internal state containing accumulated lines.\n   */\n  state: State\n  /**\n   * Render the accumulated lines into a single string.\n   * @returns The rendered string\n   */\n  render: () => string\n  /**\n   * Alias for render() to support string coercion.\n   * @returns The rendered string\n   */\n  toString(): string\n}",
            "description": "String builder interface for constructing multi-line strings.\nSupports both function call syntax and template literal syntax.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/builder.ts",
              "line": 17
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "LinesInput",
            "signature": "export type LinesInput = (Line | null)[]",
            "description": "Input type for lines - allows null values which are filtered out.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/builder.ts",
              "line": 50
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Lines",
            "signature": "export type Lines = Line[]",
            "description": "Array of line strings.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/builder.ts",
              "line": 55
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Line",
            "signature": "export type Line = string",
            "description": "A single line of text.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/builder.ts",
              "line": 60
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "State",
            "signature": "export interface State {\n  /**\n   * Accumulated lines.\n   */\n  lines: Lines\n}",
            "description": "Internal state of the string builder.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/builder.ts",
              "line": 65
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "Case",
            "signature": "export { camelCase as camel } from 'es-toolkit'\n\n/**\n * Convert string to kebab-case.\n * @example\n * ```typescript\n * kebab('helloWorld') // 'hello-world'\n * kebab('FooBar') // 'foo-bar'\n * ```\n */\nexport { kebabCase as kebab } from 'es-toolkit'\n\n/**\n * Convert string to PascalCase.\n * @example\n * ```typescript\n * pascal('hello-world') // 'HelloWorld'\n * pascal('foo_bar') // 'FooBar'\n * ```\n */\nexport { pascalCase as pascal } from 'es-toolkit'\n\n/**\n * Convert string to snake_case.\n * @example\n * ```typescript\n * snake('helloWorld') // 'hello_world'\n * snake('FooBar') // 'foo_bar'\n * ```\n */\nexport { snakeCase as snake } from 'es-toolkit'\n\n/**\n * Convert string to Title Case.\n * Replaces hyphens and underscores with spaces and capitalizes the first letter of each word.\n * @param str - The string to convert\n * @returns The title cased string\n * @example\n * ```typescript\n * title('hello-world') // 'Hello World'\n * title('foo_bar') // 'Foo Bar'\n * title('the quick brown fox') // 'The Quick Brown Fox'\n * ```\n */\nexport const title = (str: string) => {\n  return str\n    .replaceAll(/[-_]/g, ' ')\n    .replace(/\\b\\w/g, l => l.toUpperCase())\n}\n\n/**\n * Convert string to UPPERCASE with type-level transformation.\n * Preserves the uppercase type at the type level.\n *\n * @param str - The string to convert\n * @returns The uppercase string with Uppercase<S> type\n * @example\n * ```typescript\n * uppercase('hello')  // Type: \"HELLO\" (not string)\n * uppercase('world')  // Type: \"WORLD\"\n *\n * // Works with plain strings too\n * uppercase('hello world') // 'HELLO WORLD'\n * uppercase('FooBar') // 'FOOBAR'\n * ```\n */\nexport const capAll = <$S extends string>(str: $S): Uppercase<$S> => {\n  return str.toUpperCase() as Uppercase<$S>\n}\n\n/**\n * Convert the first letter of a string to lowercase with type-level transformation.\n *\n * @param s - The string to convert\n * @returns The string with lowercase first letter and Uncapitalize<S> type\n * @example\n * ```typescript\n * lowerCaseFirst('Hello')  // Type: \"hello\"\n * lowerCaseFirst('World')  // Type: \"world\"\n * lowerCaseFirst('HELLO')  // Type: \"hELLO\"\n * ```\n */\nexport const uncapFirst = <$S extends string>(s: $S): Uncapitalize<$S> => {\n  return (s.charAt(0).toLowerCase() + s.slice(1)) as Uncapitalize<$S>\n}\n\n/**\n * Capitalize the first letter of a string with type-level transformation.\n *\n * @param string - The string to capitalize\n * @returns The string with capitalized first letter and Capitalize<S> type\n * @example\n * ```typescript\n * capitalizeFirst('hello')  // Type: \"Hello\"\n * capitalizeFirst('world')  // Type: \"World\"\n * capitalizeFirst('foo bar')  // Type: \"Foo bar\"\n * ```\n */\nexport const capFirst = <$S extends string>(string: $S): Capitalize<$S> => {\n  return (string.charAt(0).toUpperCase() + string.slice(1)) as Capitalize<$S>\n}\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/case/case.ts",
              "line": 9
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Char",
            "signature": "export type LetterUpper =\n  | 'A'\n  | 'B'\n  | 'C'\n  | 'D'\n  | 'E'\n  | 'F'\n  | 'G'\n  | 'H'\n  | 'I'\n  | 'J'\n  | 'K'\n  | 'L'\n  | 'M'\n  | 'N'\n  | 'O'\n  | 'P'\n  | 'Q'\n  | 'R'\n  | 'S'\n  | 'T'\n  | 'U'\n  | 'V'\n  | 'W'\n  | 'X'\n  | 'Y'\n  | 'Z'\n\n/**\n * Lowercase letter.\n */\nexport type LetterLower =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z'\n\n/**\n * Any letter (uppercase or lowercase).\n */\nexport type Letter = LetterLower | LetterUpper\n\n/**\n * Digit character.\n */\nexport type Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\n//\n//\n//\n//\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ • Values\n//\n//\n\n/**\n * Non-breaking space character (U+00A0).\n * A space character that prevents line breaks at its position.\n * @see https://unicode-explorer.com/c/00A0\n */\nexport const spaceNoBreak = `\\u00A0`\n\n/**\n * Regular space character (U+0020).\n * The standard space character.\n * @see https://unicode-explorer.com/c/0020\n */\nexport const spaceRegular = `\\u0020`\n\n/**\n * Line feed (newline) character.\n * Used to create line breaks in text.\n */\nexport const newline = `\\n`\n\n/**\n * Bullet character (U+2022).\n * Standard bullet point symbol: •\n * @see https://unicode-explorer.com/c/2022\n */\nexport const bullet = `\\u2022`\n\n/**\n * Middle dot character (U+00B7).\n * Centered dot symbol: ·\n * @see https://unicode-explorer.com/c/00B7\n */\nexport const middleDot = `\\u00B7`\n\n/** @see https://unicode-explorer.com/c/2219 */\n// export const bulletOperator = `\\u2219`\n\n/**\n * Black circle character (U+25CF).\n * Filled circle symbol: ●\n * @see https://unicode-explorer.com/c/25CF\n */\nexport const blackCircle = `\\u25CF`\n\n/**\n * White bullet character (U+25E6).\n * Hollow circle symbol: ◦\n * @see https://unicode-explorer.com/c/25E6\n */\nexport const whiteBullet = `\\u25E6`\n\n/**\n * Inverse bullet character (U+25D8).\n * Inverse white circle symbol: ◘\n * @see https://unicode-explorer.com/c/25D8\n */\nexport const inverseBullet = `\\u25D8`\n\n/**\n * Square with left half black character (U+25E7).\n * Half-filled square symbol: ◧\n * @see https://unicode-explorer.com/c/25E7\n */\nexport const squareWithLeftHalfBlack = `\\u25E7`\n\n/**\n * Rightwards arrow character (U+2192).\n * Right-pointing arrow symbol: →\n * @see https://unicode-explorer.com/c/2192\n */\nexport const rightwardsArrow = `\\u2192`\n",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/char/char.ts",
              "line": 12
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "RegExpMatchResult",
            "signature": "export type RegExpMatchResult<$Matches extends Matches> =\n  & Omit<RegExpMatchArray, 'groups'>\n  & {\n      groups:\n        $Matches['groups'] extends readonly [MatchItem,... readonly MatchItem[]]\n          ? ArrMut.ReduceWithIntersection<ToGroupsProperties<$Matches['groups']>>\n          : undefined\n    }\n  & (\n      $Matches extends { indicies: readonly [MatchItem,... readonly MatchItem[]] }\n        ? [originalValue: string, ...$Matches['indicies']]\n        : [originalValue: string]\n    )",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 17
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "pattern",
            "signature": "<matches extends Matches>(pattern: RegExp) => Pattern<matches>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 52
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Matches",
            "signature": "export type Matches = {\n  groups?: (string | undefined)[]\n  indicies?: (string | undefined)[]\n}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 57
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "match",
            "signature": "<matches extends Matches>(string: string, pattern: RegExp | Pattern<matches>) => Option<RegExpMatchResult<matches>>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 78
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PatternInput",
            "signature": "export type PatternInput = string | RegExp",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 88
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "isMatch",
            "signature": "(value: string, pattern: PatternInput) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 102
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isMatchOn",
            "signature": "(value: string) => (pattern: PatternInput) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 120
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isMatchWith",
            "signature": "(pattern: PatternInput) => (value: string) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 133
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isntMatch",
            "signature": "(pattern: PatternInput) => (value: string) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 146
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isntMatchOn",
            "signature": "(pattern: PatternInput) => (value: string) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 155
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isntMatchWith",
            "signature": "(value: string) => (pattern: PatternInput) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 162
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "PatternsInput",
            "signature": "export type PatternsInput = ArrMut.Maybe<string | RegExp>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 166
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isMatchAny",
            "signature": "(value: string, patterns: PatternsInput) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 180
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isMatchAnyOn",
            "signature": "(value: string) => (patterns: PatternsInput) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 190
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isMatchAnyWith",
            "signature": "(patterns: PatternsInput) => (value: string) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 204
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isNotMatchAny",
            "signature": "(patternOrPatterns: PatternsInput) => (value: string) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 217
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isNotMatchAnyOn",
            "signature": "(patternOrPatterns: PatternsInput) => (value: string) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 226
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isNotMatchAnyWith",
            "signature": "(value: string) => (patternOrPatterns: PatternsInput) => boolean",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/match.ts",
              "line": 233
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "titlizeSlug",
            "signature": "(str: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/misc.ts",
              "line": 16
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensureEnd",
            "signature": "(string: string, ending: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/misc.ts",
              "line": 20
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "trim",
            "signature": "(value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 26
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeading",
            "signature": "(replacement: string, matcher: string, value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeadingWith",
            "signature": "(replacement: string) => (matcher: string) => (value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 60
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeadingOn",
            "signature": "(value: string) => (replacement: string) => (matcher: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 69
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "stripLeading",
            "signature": "(matcher: string) => (value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 84
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "replace",
            "signature": "(replacement: string, matcher: PatternsInput, value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 108
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceWith",
            "signature": "(replacement: string) => (matcher: PatternsInput) => (value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 120
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceOn",
            "signature": "(value: string) => (replacement: string) => (matcher: PatternsInput) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 129
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "append",
            "signature": "(value1: string, value2: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 153
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "appendOn",
            "signature": "(value1: string) => (value2: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 162
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "appendWith",
            "signature": "(value2: string) => (value1: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 174
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "prepend",
            "signature": "(value1: string, value2: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 190
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "prependOn",
            "signature": "(value1: string) => (value2: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 199
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "prependWith",
            "signature": "(value2: string) => (value1: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 211
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "repeat",
            "signature": "(value: string, count: number) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 234
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "repeatOn",
            "signature": "(value: string) => (count: number) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 243
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "repeatWith",
            "signature": "(count: number) => (value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 255
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurrounding",
            "signature": "(str: string, target: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 277
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "removeSurroundingOn",
            "signature": "(str: string) => (target: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 302
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingWith",
            "signature": "(target: string) => (str: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 309
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "truncate",
            "signature": "(str: string, maxLength?: number) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 331
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "truncateOn",
            "signature": "(str: string) => (maxLength?: number | undefined) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 344
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "truncateWith",
            "signature": "(maxLength?: number | undefined) => (str: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 356
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "strip",
            "signature": "(matcher: PatternsInput) => (value: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 377
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingSpaceRegular",
            "signature": "(str: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 385
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingSpaceNoBreak",
            "signature": "(str: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/replace.ts",
              "line": 393
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "split",
            "signature": "(value: string, separator: string) => string[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 17
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "splitOn",
            "signature": "(value: string) => (separator: string) => string[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 27
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "splitWith",
            "signature": "(separator: string) => (value: string) => string[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 39
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "join",
            "signature": "(value: string[], separator: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 54
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "joinOn",
            "signature": "(value: string[]) => (separator: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 63
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "joinWith",
            "signature": "(separator: string) => (value: string[]) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 75
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "merge",
            "signature": "(string1: string, string2: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 89
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mergeOn",
            "signature": "(string1: string) => (string2: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/split.ts",
              "line": 103
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "table",
            "signature": "(input: { data: Record<string, string>; separator?: string | false | undefined; separatorAlignment?: boolean; }) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/table.ts",
              "line": 31
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "interpolate",
            "signature": "(template: string) => (args: TemplateArgs) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/template.ts",
              "line": 17
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "templateVariablePattern",
            "signature": "RegExp",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/template.ts",
              "line": 28
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "TemplateArgs",
            "signature": "export type TemplateArgs = Record<string, Json.Value>",
            "description": "Arguments object for template interpolation.\nMaps variable names to their JSON-serializable values.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/template.ts",
              "line": 34
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isTemplateStringsArray",
            "signature": "(args: unknown) => args is TemplateStringsArray",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/template.ts",
              "line": 52
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "defaultIndentSize",
            "signature": "2",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 10
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "defaultIndentCharacter",
            "signature": "\" \"",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 15
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "defaultLineSeparator",
            "signature": "\"\\n\"",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "lines",
            "signature": "(value: string) => string[]",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 35
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "unlines",
            "signature": "(value: string[]) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 48
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "indent",
            "signature": "(text: string, size?: number | undefined) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 63
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "indentOn",
            "signature": "(text: string) => (size?: number | undefined) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 73
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "indentWith",
            "signature": "(size?: number | undefined) => (text: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 85
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "stripIndent",
            "signature": "(text: string) => string",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/text.ts",
              "line": 106
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "EndsWith",
            "signature": "export type EndsWith<S extends string, T extends string> = S extends `${string}${T}` ? true : false",
            "description": "Check if a string ends with a specific suffix.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type-level.ts",
              "line": 12
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StartsWith",
            "signature": "export type StartsWith<S extends string, T extends string> = S extends `${T}${string}` ? true : false",
            "description": "Check if a string starts with a specific prefix.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type-level.ts",
              "line": 17
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "LastSegment",
            "signature": "export type LastSegment<S extends string> = S extends `${string}/${infer Rest}` ? LastSegment<Rest>\n  : S",
            "description": "Extract the last segment from a path-like string (after the last '/').",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type-level.ts",
              "line": 22
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RemoveTrailingSlash",
            "signature": "export type RemoveTrailingSlash<S extends string> = S extends `${infer Rest}/` ? Rest extends '' ? '/' : Rest\n  : S",
            "description": "Remove trailing slash from a string.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type-level.ts",
              "line": 28
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Split",
            "signature": "export type Split<S extends string, D extends string, Acc extends string[] = []> = S extends '' ? Acc\n  : S extends `${infer Segment}${D}${infer Rest}` ? Segment extends '' ? Split<Rest, D, Acc>\n    : Segment extends '.' ? Split<Rest, D, Acc>\n    : Split<Rest, D, [...Acc, Segment]>\n  : S extends '.' ? Acc\n  : [...Acc, S]",
            "description": "Split a string by a delimiter, filtering out empty segments and '.' segments.\nThis is useful for path-like strings.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type-level.ts",
              "line": 35
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Contains",
            "signature": "export type Contains<S extends string, C extends string> = S extends `${string}${C}${string}` ? true : false",
            "description": "Check if string contains a character.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/domains/str/type-level.ts",
              "line": 45
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "LiteralOnly",
            "signature": "export type LiteralOnly<\n  T extends string,\n  $ErrorMessage extends string = 'Expected a literal string',\n> = string extends T ? Ts.StaticError<\n    $ErrorMessage,\n    { ReceivedType: T },\n    'Use a string literal instead of string type'\n  >\n  : T",
            "description": "Constraint that only accepts literal strings.\nReturns StaticError for non-literal string type with customizable error message.",
            "examples": [],
            "tags": {
              "template": "- Custom error message to display when T is not a literal"
            },
            "sourceLocation": {
              "file": "src/domains/str/type-level.ts",
              "line": 54
            },
            "_tag": "type",
            "type": "type-alias"
          }
        ]
      }
    },
    {
      "packagePath": "./test",
      "resolvedPath": "./src/utils/test/$.ts",
      "module": {
        "name": "Test",
        "description": "Enhanced test utilities for table-driven testing with Vitest.\n\nProvides builder API and type-safe utilities for parameterized tests with\nbuilt-in support for todo, skip, and only cases.\n\n@example Basic table-driven testing with builder API\n```typescript\nconst add = (a: number, b: number) => a + b\n\nTest.describe('addition')\n  .on(add)\n  .cases(\n    [[2, 3], 5],\n    [[0, 0], 0],\n    [[-1, 1], 0]\n  )\n  .test()\n```\n\n@example Custom test logic\n```typescript\nTest.describe('validation')\n  .i<string>()\n  .o<boolean>()\n  .cases(\n    { n: 'valid email', i: 'user@example.com', o: true },\n    { n: 'invalid', i: 'not-email', o: false },\n    { n: 'future feature', todo: 'Not implemented yet' }\n  )\n  .test((input, expected) => {\n    expect(isValid(input)).toBe(expected)\n  })\n```\n\n@example Property-based testing\n```typescript\nTest.property(\n  'reversing array twice returns original',\n  fc.array(fc.integer()),\n  (arr) => {\n    const reversed = arr.slice().reverse()\n    const reversedTwice = reversed.slice().reverse()\n    expect(reversedTwice).toEqual(arr)\n  }\n)\n```",
        "exports": [
          {
            "_tag": "value",
            "name": "Matchers",
            "type": "namespace",
            "signature": "export * as Matchers",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/test/$$.ts",
              "line": 1
            },
            "module": {
              "name": "Matchers",
              "description": "",
              "exports": []
            }
          },
          {
            "name": "property",
            "signature": "<Ts extends [unknown, ...unknown[]]>(...args: [description: string, ...arbitraries: { [K in keyof Ts]: Arbitrary<Ts[K]>; }, predicate: (...args: Ts) => boolean | void]) => void",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/test/property.ts",
              "line": 38
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "on",
            "signature": "export function on<$fn extends Fn.AnyAny>($fn: $fn): TestBuilder<UpdateState<BuilderTypeStateEmpty, { fn: $fn; }>>",
            "description": "Creates a test table builder for testing a specific function.\n\nThis is a shorthand for `describe().on(fn)` when you don't need a describe block.\nTypes are automatically inferred from the function signature, making it ideal for\nquick function testing with minimal boilerplate.\n\n## Case Formats\n\nTest cases can be specified in multiple formats:\n\n**Tuple Format** (most common):\n- `[[arg1, arg2], expected]` - Test with expected output\n- `['name', [arg1, arg2], expected]` - Named test case\n- `[[arg1, arg2]]` - Snapshot test (no expected value)\n\n**Object Format** (more verbose but clearer):\n- `{ input: [arg1, arg2], output: expected }`\n- `{ input: [arg1, arg2], output: expected, skip: true, comment: 'name' }`\n- `{ todo: 'Not implemented yet', comment: 'name' }`",
            "examples": [
              {
                "code": "Test.on(add)\n  .cases(\n    [[2, 3], 5],                    // add(2, 3) === 5\n    [[0, 0], 0],                    // add(0, 0) === 0\n    [[-1, 1], 0]                    // add(-1, 1) === 0\n  )\n  .test()\n\n// Using different case formats\nTest.on(multiply)\n  .cases(\n    [[2, 3], 6],                              // Tuple format\n    ['zero case', [5, 0], 0],                 // Named tuple\n    { input: [-2, 3], output: -6 },           // Object format\n    { input: [100, 100], output: 10000, comment: 'large numbers' }\n  )\n  .test()\n\n// Custom assertions\nTest.on(divide)\n  .cases([[10, 2], 5], [[10, 0], Infinity])\n  .test(({ result, output }) => {\n    if (output === Infinity) {\n      expect(result).toBe(Infinity)\n    } else {\n      expect(result).toBeCloseTo(output, 2)\n    }\n  })\n\n// Output transformation - build full expectations from partials\nTest.on(createUser)\n  .onOutput((partial, context) => ({ ...defaultUser, name: context.input[0], ...partial }))\n  .cases(\n    [['Alice'], { role: 'admin' }],           // Only specify differences\n    [['Bob'], { role: 'user', age: 30 }]\n  )\n  .test()",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "Test.on(parseInt)\n  .cases(\n    ['42'],      // Returns: 42\n    ['hello'],   // Returns: NaN\n  )\n  .test()\n\n// Validation functions - errors documented in snapshots\nTest.on(Positive.from)\n  .cases(\n    [1], [10], [100],        // THEN RETURNS the value\n    [0], [-1], [-10],        // THEN THROWS \"Value must be positive\"\n  )\n  .test()",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- The function to test. Types are inferred from its signature",
              "returns": "A {@link TestBuilder} for configuring and running tests",
              "see": "{@link describe} for creating tests with a describe block"
            },
            "sourceLocation": {
              "file": "src/utils/test/table/constructors.ts",
              "line": 117
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "describe",
            "signature": "export function describe(description?: string): TestBuilderEmpty",
            "description": "Creates a test table builder for property-based and example-based testing.\n\nTest tables allow you to define multiple test cases with inputs and expected outputs,\nreducing boilerplate and making tests more maintainable. The builder supports two modes:\n\n## Modes\n\n**Function Mode** - Test a specific function with `.on(fn)`:\n- Types are automatically inferred from the function signature\n- Test cases specify function arguments and expected return values\n- Default assertion compares actual vs expected using Effect's equality\n\n**Generic Mode** - Define custom types with `.i<T>()` and `.o<T>()`:\n- Explicitly specify input and output types\n- Provide custom test logic to validate cases\n- Useful for testing complex behaviors beyond simple function calls\n\n## Features\n\n**Nested Describes** - Use ` > ` separator to create nested describe blocks:\n- `Test.describe('Parent > Child')` creates `describe('Parent', () => describe('Child', ...))`\n- Multiple tests with the same prefix share the outer describe block\n- Supports any depth: `'API > Users > Create'` creates three levels\n\n**Matrix Testing** - Use `.matrix()` to run cases across parameter combinations:\n- Generates cartesian product of all matrix value arrays\n- Each test case runs once for each combination\n- Matrix values available as `matrix` in test context\n- Combines with nested describes for organized test suites",
            "examples": [
              {
                "code": "Test.describe('addition')\n  .on(add)\n  .cases(\n    [[2, 3], 5],                          // add(2, 3) should return 5\n    ['negative', [-1, -2], -3],           // Named test case\n    [[0, 0], 0]                           // Edge case\n  )\n  .test()  // Uses default assertion (Effect's Equal.equals)\n\n// Generic mode - custom validation logic\nTest.describe('email validation')\n  .inputType<string>()\n  .outputType<boolean>()\n  .cases(\n    ['user@example.com', true],\n    ['invalid.com', false],\n    ['', false]\n  )\n  .test(({ input, output }) => {\n    const result = isValidEmail(input)\n    expect(result).toBe(output)\n  })\n\n// Nested describe blocks with ' > ' separator\nTest.describe('Transform > String')  // Creates nested: Transform -> String\n  .inputType<string>()\n  .outputType<string>()\n  .cases(['hello', 'HELLO'])\n  .test(({ input, output }) => {\n    expect(input.toUpperCase()).toBe(output)\n  })\n\nTest.describe('Transform > Number')  // Shares 'Transform' parent describe\n  .inputType<number>()\n  .outputType<number>()\n  .cases([42, 42])\n  .test(({ input, output }) => {\n    expect(input).toBe(output)\n  })\n\n// Matrix testing - runs each case for all parameter combinations\nTest.describe('string transform')\n  .inputType<string>()\n  .outputType<string>()\n  .matrix({\n    uppercase: [true, false],\n    prefix: ['', 'pre_'],\n  })\n  .cases(\n    ['hello', 'hello'],\n    ['world', 'world']\n  )\n  .test(({ input, output, matrix }) => {\n    // Runs 4 times (2 cases × 2 uppercase × 2 prefix = 8 tests)\n    let result = input\n    if (matrix.prefix) result = matrix.prefix + result\n    if (matrix.uppercase) result = result.toUpperCase()\n\n    let expected = output\n    if (matrix.prefix) expected = matrix.prefix + expected\n    if (matrix.uppercase) expected = expected.toUpperCase()\n\n    expect(result).toBe(expected)\n  })",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "param": "- Optional description for the test suite. Supports ` > ` separator for nested describe blocks.",
              "returns": "A {@link TestBuilder} for chaining configuration, cases, and execution",
              "see": "{@link TestBuilder.matrix matrix()} for matrix testing documentation"
            },
            "sourceLocation": {
              "file": "src/utils/test/table/constructors.ts",
              "line": 233
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "packagePath": "./ts",
      "resolvedPath": "./src/utils/ts/$.ts",
      "module": {
        "name": "Ts",
        "description": "TypeScript type utilities and type-level programming helpers.\n\nProvides comprehensive type-level utilities including type printing, static\nerrors, type guards, simplification utilities, exact type matching, and\ntype testing tools. Features conditional types, type transformations, and\ntype-level assertions for advanced TypeScript patterns.",
        "exports": [
          {
            "_tag": "value",
            "name": "Kind",
            "type": "namespace",
            "signature": "export * as Kind",
            "description": "Higher-kinded type utilities for TypeScript.\n\nProvides type-level functions and utilities for simulating higher-kinded\ntypes in TypeScript, enabling more advanced type-level programming patterns.\n\n@module",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/$$.ts",
              "line": 1
            },
            "module": {
              "name": "Kind",
              "description": "Higher-kinded type utilities for TypeScript.\n\nProvides type-level functions and utilities for simulating higher-kinded\ntypes in TypeScript, enabling more advanced type-level programming patterns.\n\n@module",
              "exports": [
                {
                  "name": "Apply",
                  "signature": "export type Apply<$Kind, $Args> =\n  // @ts-expect-error - Intentional type manipulation for kind simulation\n  ($Kind & { parameters: $Args })['return']",
                  "description": "Higher-kinded type utilities for TypeScript.\n\nProvides type-level functions and utilities for simulating higher-kinded\ntypes in TypeScript, enabling more advanced type-level programming patterns.",
                  "examples": [],
                  "tags": {
                    "module": ""
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 32
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Kind",
                  "signature": "export interface Kind<$Params = unknown, $Return = unknown> {\n  readonly parameters: $Params\n  readonly return: $Return\n}",
                  "description": "Define a kind (higher-kinded type) function interface.\n\nProvides a standard structure for defining type-level functions\nthat can be applied using the Apply utility.",
                  "examples": [
                    {
                      "code": "return: Box<this['parameters'][0]>\n}",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "template": "- The return type this kind produces"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 52
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "Parameters",
                  "signature": "export type Parameters<$Kind> = $Kind extends Kind<infer P, any> ? P : never",
                  "description": "Extract the parameter types from a kind.",
                  "examples": [],
                  "tags": {
                    "template": "- The kind to extract parameters from"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 62
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Return",
                  "signature": "export type Return<$Kind> = $Kind extends Kind<any, infer R> ? R : never",
                  "description": "Extract the return type from a kind.",
                  "examples": [],
                  "tags": {
                    "template": "- The kind to extract return type from"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 69
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Identity",
                  "signature": "export interface Identity extends Kind {\n  // @ts-expect-error\n  return: this['parameters'][0]\n}",
                  "description": "Create a type-level identity function.\n\nReturns the input type unchanged. Useful as a default or\nplaceholder in kind compositions.",
                  "examples": [
                    {
                      "code": "",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 82
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "Const",
                  "signature": "export interface Const<$Const> extends Kind {\n  return: $Const\n}",
                  "description": "Create a type-level constant function.\n\nAlways returns the same type regardless of input.",
                  "examples": [
                    {
                      "code": "",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "template": "- The constant type to always return"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 99
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "PrivateKindReturn",
                  "signature": "typeof PrivateKindReturn",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 114
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "PrivateKindParameters",
                  "signature": "typeof PrivateKindParameters",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 120
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "Private",
                  "signature": "export interface Private {\n  [PrivateKindReturn]: unknown\n  [PrivateKindParameters]: unknown\n}",
                  "description": "Private kind interface using symbols instead of string keys.\n\nThis provides a more secure way to define higher-kinded types\nas the symbols cannot be accessed outside the module.",
                  "examples": [
                    {
                      "code": "```ts\ninterface BoxKind extends PrivateKind {\n  //",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {
                    "ts-expect-error": "[PRIVATE_KIND_RETURN]: Box<this[PRIVATE_KIND_PARAMETERS][0]>\n  [PRIVATE_KIND_PARAMETERS]: unknown\n}\n```"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 138
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "PrivateApply",
                  "signature": "export type PrivateApply<$Kind extends Private, $Args> = ($Kind & { [PrivateKindParameters]: $Args })[PrivateKindReturn]",
                  "description": "Apply arguments to a private kind.",
                  "examples": [
                    {
                      "code": "",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "template": "- The arguments to apply"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 154
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "MaybePrivateApplyOr",
                  "signature": "export type MaybePrivateApplyOr<$MaybeKind, $Args, $Or> =\n  $MaybeKind extends Private\n    ? PrivateApply<$MaybeKind, $Args>\n    : $Or",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 157
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsPrivateKind",
                  "signature": "export type IsPrivateKind<T> = T extends Private ? true : false",
                  "description": "Check if a type is a private kind.",
                  "examples": [
                    {
                      "code": "type Test2 = IsPrivateKind<string> // false",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "template": "- The type to check"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/kind.ts",
                    "line": 173
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Test",
            "type": "namespace",
            "signature": "export * as Test",
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/$$.ts",
              "line": 3
            },
            "module": {
              "name": "Test",
              "description": "",
              "exports": [
                {
                  "name": "exact",
                  "signature": "export type exact<$Expected, $Actual> = (<T>() => T extends $Actual ? 1 : 2) extends\n  (<T>() => T extends $Expected ? 1 : 2) ? true\n  // If structural equality fails, check if bidirectional assignability passes\n  : $Actual extends $Expected ? $Expected extends $Actual ? StaticErrorAssertion<\n        'Types are mutually assignable but not structurally equal',\n        $Expected,\n        $Actual,\n        'Use bid() for mutual assignability OR apply Simplify<T> to normalize types'\n      >\n    : StaticErrorAssertion<'Types are not structurally equal', $Expected, $Actual>\n  : StaticErrorAssertion<'Types are not structurally equal', $Expected, $Actual>",
                  "description": "Assert that two types are exactly equal (structurally).\n\nUses a conditional type inference trick to check exact structural equality,\ncorrectly handling any, never, and unknown edge cases.\n\nThis checks for structural equality - types must have the same structure,\nnot just compute to the same result. For bidirectional extends, use {@link bid}.\n\nWhen exact equality fails but bidirectional assignability passes, provides\na helpful tip about using {@link bid} or applying {@link Simplify} from `#ts`.",
                  "examples": [
                    {
                      "code": "Ts.Test.exact<string, string>,           // ✓ Pass\n  Ts.Test.exact<string | number, string>,  // ✗ Fail - Type error\n  Ts.Test.exact<{ a: 1 }, { a: 1 }>,       // ✓ Pass\n  Ts.Test.exact<any, unknown>,             // ✗ Fail - Type error\n  Ts.Test.exact<1 | 2, 2 | 1>              // ✗ Fail with tip - types are mutually assignable but not structurally equal\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 65
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "bid",
                  "signature": "export type bid<$Expected, $Actual> = $Actual extends $Expected ? $Expected extends $Actual\n    // Both directions pass - check if exact would also pass\n    ? (<T>() => T extends $Actual ? 1 : 2) extends (<T>() => T extends $Expected ? 1 : 2)\n      // Exact also passes - check if linting is enabled\n      ? GetTestSetting<'lintBidForExactPossibility'> extends true ? StaticErrorAssertion<\n          'Types are structurally equal',\n          $Expected,\n          $Actual,\n          'Use exact() instead - bid() is only needed when types are mutually assignable but not structurally equal'\n        >\n      : true // Linting disabled, allow it\n    : true // Only bid passes (not exact) - this is correct usage\n  : StaticErrorAssertion<\n    'Types are not bidirectionally assignable (Expected does not extend Actual)',\n    $Expected,\n    $Actual\n  >\n  : StaticErrorAssertion<\n    'Types are not bidirectionally assignable (Actual does not extend Expected)',\n    $Expected,\n    $Actual\n  >",
                  "description": "Assert that two types are bidirectionally assignable (mutually assignable).\n\nThis checks that types are mutually assignable (A extends B and B extends A),\nwhich means they compute to the same result even if their structure differs.\n\nUse this when you care about semantic equality rather than structural equality.\nFor strict structural equality, use {@link exact}.\n\n**Linting:** When `KitLibrarySettings.Ts.Test.Settings.lintBidForExactPossibility` is `true`,\nthis will show an error if {@link exact} would work, encouraging use of the stricter assertion.\nSee module documentation for configuration example.",
                  "examples": [
                    {
                      "code": "Ts.Test.bid<string, string>,      // ✓ Pass (or error if linting enabled - should use exact)\n  Ts.Test.bid<1 | 2, 2 | 1>,        // ✓ Pass (or error if linting enabled - should use exact)\n  Ts.Test.bid<string & {}, string>, // ✓ Pass - both compute to string (exact would fail)\n  Ts.Test.bid<string, number>       // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "see": "documentation for how to enable strict linting"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 132
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "sub",
                  "signature": "export type sub<$Expected, $Actual> = $Actual extends $Expected ? true\n  : StaticErrorAssertion<\n    'Actual type does not extend expected type',\n    $Expected,\n    $Actual\n  >",
                  "description": "Assert that a type extends (is a subtype of) another type.\n\nEquivalent to TypeScript's `extends` keyword: checks if `$Actual extends $Expected`.\nThis is useful for validating type relationships and narrowing.\n\nFor exact type equality (not just subtyping), use {@link exact} instead.",
                  "examples": [
                    {
                      "code": "Ts.Test.sub<string, 'hello'>,           // ✓ Pass - 'hello' extends string\n  Ts.Test.sub<'hello', string>,           // ✗ Fail - string doesn't extend 'hello'\n  Ts.Test.sub<{ a: 1 }, { a: 1; b: 2 }>,  // ✓ Pass - more specific extends less specific\n  Ts.Test.sub<object, { a: 1 }>           // ✓ Pass - { a: 1 } extends object\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 205
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNoExcess",
                  "signature": "export type subNoExcess<$Expected, $Actual> = $Actual extends $Expected\n  ? Exclude<keyof $Actual, keyof $Expected> extends never ? true\n  : StaticErrorAssertion<\n    'Type has excess properties not present in expected type',\n    $Expected,\n    $Actual\n  >\n  : StaticErrorAssertion<\n    'Actual type does not extend expected type',\n    $Expected,\n    $Actual\n  >",
                  "description": "Assert that a type extends the expected type AND has no excess properties.\n\nSimilar to {@link sub} but also rejects excess properties beyond those defined\nin the expected type. This catches common bugs like typos in configuration objects\nor accidentally passing extra properties.\n\nThis is particularly useful for:\n- Validating configuration objects\n- Checking function parameters that shouldn't have extra properties\n- Testing that types don't have unexpected fields",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.subNoExcess<Config, { id: true }>,               // ✓ Pass\n  Ts.Test.subNoExcess<Config, { id: true; name: 'test' }>, // ✓ Pass - optional included\n  Ts.Test.subNoExcess<Config, { id: true; $skip: true }>,  // ✗ Fail - excess property\n  Ts.Test.subNoExcess<Config, { id: 'wrong' }>             // ✗ Fail - wrong type\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    },
                    {
                      "code": "type Q = { id: boolean }\n\ntype T1 = Ts.Test.sub<Q, { id: true; extra: 1 }>         // ✓ Pass (sub allows excess)\ntype T2 = Ts.Test.subNoExcess<Q, { id: true; extra: 1 }> // ✗ Fail (subNoExcess rejects)",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "see": "{@link exact} for exact structural equality"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 288
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNot",
                  "signature": "export type subNot<$NotExpected, $Actual> = $Actual extends $NotExpected ? StaticErrorAssertion<\n    'Actual type extends type it should not extend',\n    $NotExpected,\n    $Actual\n  >\n  : true",
                  "description": "Assert that a type does NOT extend another type.",
                  "examples": [
                    {
                      "code": "Ts.Test.subNot<number, string>,  // ✓ Pass\n  Ts.Test.subNot<string, 'hello'>  // ✗ Fail - 'hello' extends string\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 368
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalNever",
                  "signature": "export type equalNever<$Actual> = [$Actual] extends [never] ? true\n  : StaticErrorAssertion<'Type is not never', never, $Actual>",
                  "description": "Assert that a type is exactly `never`.",
                  "examples": [
                    {
                      "code": "Ts.Test.equalNever<never>,  // ✓ Pass\n  Ts.Test.equalNever<string>  // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 420
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalAny",
                  "signature": "export type equalAny<$Actual> = 0 extends 1 & $Actual ? true\n  : StaticErrorAssertion<'Type is not any', never, $Actual>",
                  "description": "Assert that a type is exactly `any`.\n\nUses the `0 extends 1 & T` trick to detect `any`.",
                  "examples": [
                    {
                      "code": "Ts.Test.equalAny<any>,      // ✓ Pass\n  Ts.Test.equalAny<unknown>,  // ✗ Fail - Type error\n  Ts.Test.equalAny<string>    // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 458
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalUnknown",
                  "signature": "export type equalUnknown<$Actual> = unknown extends $Actual ? (0 extends 1 & $Actual ? StaticErrorAssertion<\n      'Type is any, not unknown',\n      unknown,\n      $Actual\n    >\n    : true)\n  : StaticErrorAssertion<'Type is not unknown', never, $Actual>",
                  "description": "Assert that a type is exactly `unknown`.",
                  "examples": [
                    {
                      "code": "Ts.Test.equalUnknown<unknown>,  // ✓ Pass\n  Ts.Test.equalUnknown<any>,      // ✗ Fail - Type error\n  Ts.Test.equalUnknown<string>    // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 494
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalEmptyObject",
                  "signature": "export type equalEmptyObject<$Actual extends object> = Obj.IsEmpty<$Actual> extends true ? true\n  : StaticErrorAssertion<'Type is not an empty object (has keys)', Obj.Empty, $Actual>",
                  "description": "Assert that a type is an empty object (no properties).\n\nUses {@link Obj.IsEmpty} from kit to check if the object has no keys.\nNote: `{}` in TypeScript means \"any non-nullish value\", not an empty object.",
                  "examples": [
                    {
                      "code": "Ts.Test.equalEmptyObject<Record<string, never>>,  // ✓ Pass\n  Ts.Test.equalEmptyObject<{}>,                      // ✗ Fail - {} is not empty\n  Ts.Test.equalEmptyObject<{ a: 1 }>                 // ✗ Fail - has properties\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 543
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "sup",
                  "signature": "export type sup<$Supertype, $Actual> = $Actual extends $Supertype ? true\n  : StaticErrorAssertion<'Actual type does not extend expected supertype', $Supertype, $Actual>",
                  "description": "Assert that a type is a supertype of (i.e., extended by) another type.\n\nEquivalent to TypeScript's `extends` keyword: checks if `$Actual extends $Supertype`.\nThis is the reverse parameter order of {@link sub} - the expected type is the supertype.\nLess commonly used than `sub` - most cases should use `sub` with reversed parameters for clarity.",
                  "examples": [
                    {
                      "code": "Ts.Test.sup<object, { a: 1 }>,  // ✓ Pass - { a: 1 } extends object (object is supertype)\n  Ts.Test.sup<{ a: 1 }, object>,  // ✗ Fail - object doesn't extend { a: 1 }\n  Ts.Test.sup<string, 'hello'>    // ✓ Pass - 'hello' extends string (string is supertype)\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 593
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "parameters",
                  "signature": "export type parameters<$Expected extends readonly any[], $Function extends (...args: any[]) => any> = sub<\n  $Expected,\n  Parameters<$Function>\n>",
                  "description": "Assert that a function's parameters match the expected type.\nCombines `Parameters<typeof fn>` with assertion in one step.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.parameters<[number, number], typeof add>,  // ✓ Pass\n  Ts.Test.parameters<[string, string], typeof add>   // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 643
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "promise",
                  "signature": "export type promise<$Type, $Actual> = $Actual extends Promise<$Type> ? true\n  : StaticErrorAssertion<\n    'Type is not a Promise with expected element type',\n    Promise<$Type>,\n    $Actual\n  >",
                  "description": "Assert that a type is a Promise with specific element type.",
                  "examples": [
                    {
                      "code": "Ts.Test.promise<number, Promise<number>>,  // ✓ Pass\n  Ts.Test.promise<string, Promise<number>>,  // ✗ Fail - Type error\n  Ts.Test.promise<number, number>            // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 686
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "promiseNot",
                  "signature": "export type promiseNot<$Actual> = $Actual extends Promise<any> ? StaticErrorAssertion<\n    'Type is a Promise but should not be',\n    never,\n    $Actual\n  >\n  : true",
                  "description": "Assert that a type is NOT a Promise.",
                  "examples": [
                    {
                      "code": "Ts.Test.promiseNot<number>,          // ✓ Pass\n  Ts.Test.promiseNot<Promise<number>>  // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 726
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "array",
                  "signature": "export type array<$ElementType, $Actual> = $Actual extends $ElementType[] ? true\n  : StaticErrorAssertion<\n    'Type is not an array with expected element type',\n    $ElementType[],\n    $Actual\n  >",
                  "description": "Assert that a type is an array with specific element type.",
                  "examples": [
                    {
                      "code": "Ts.Test.array<string, string[]>,  // ✓ Pass\n  Ts.Test.array<number, string[]>,  // ✗ Fail - Type error\n  Ts.Test.array<string, string>     // ✗ Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 765
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "exactConst",
                  "signature": "<$Expected>() => <const $Actual>(_actual: (<T>() => T extends $Actual ? 1 : 2) extends <T>() => T extends $Expected ? 1 : 2 ? $Actual : StaticErrorAssertion<\"Actual value type is not exactly equal to expected type\", $Expected, $Actual, never>) => void",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 825
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subConst",
                  "signature": "<$Expected>() => <const $Actual>(_actual: $Actual extends $Expected ? $Actual : StaticErrorAssertion<\"Actual value type does not extend expected type\", $Expected, $Actual, never>) => void",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 853
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "bidConst",
                  "signature": "<$Expected>() => <const $Actual>(_actual: $Actual extends $Expected ? $Expected extends $Actual ? $Actual : StaticErrorAssertion<\"Types are not bidirectionally assignable (Expected does not extend Actual)\", $Expected, $Actual, never> : StaticErrorAssertion<\"Types are not bidirectionally assignable (Actual does not extend Expected)\", $Expected, $Actual, never>) => void",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 882
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "Case",
                  "signature": "export type Case<$Result extends true> = $Result",
                  "description": "Type-level test assertion that requires the result to be true.\nUsed in type-level test suites to ensure a type evaluates to true.",
                  "examples": [
                    {
                      "code": "Ts.Test.Case<Equal<string, string>>,  // OK - evaluates to true\n  Ts.Test.Case<Equal<string, number>>,  // Error - doesn't extend true\n]",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 917
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Cases",
                  "signature": "export type Cases<\n  _T1 extends true = true,\n  _T2 extends true = true,\n  _T3 extends true = true,\n  _T4 extends true = true,\n  _T5 extends true = true,\n  _T6 extends true = true,\n  _T7 extends true = true,\n  _T8 extends true = true,\n  _T9 extends true = true,\n  _T10 extends true = true,\n  _T11 extends true = true,\n  _T12 extends true = true,\n  _T13 extends true = true,\n  _T14 extends true = true,\n  _T15 extends true = true,\n  _T16 extends true = true,\n  _T17 extends true = true,\n  _T18 extends true = true,\n  _T19 extends true = true,\n  _T20 extends true = true,\n  _T21 extends true = true,\n  _T22 extends true = true,\n  _T23 extends true = true,\n  _T24 extends true = true,\n  _T25 extends true = true,\n  _T26 extends true = true,\n  _T27 extends true = true,\n  _T28 extends true = true,\n  _T29 extends true = true,\n  _T30 extends true = true,\n  _T31 extends true = true,\n  _T32 extends true = true,\n  _T33 extends true = true,\n  _T34 extends true = true,\n  _T35 extends true = true,\n  _T36 extends true = true,\n  _T37 extends true = true,\n  _T38 extends true = true,\n  _T39 extends true = true,\n  _T40 extends true = true,\n  _T41 extends true = true,\n  _T42 extends true = true,\n  _T43 extends true = true,\n  _T44 extends true = true,\n  _T45 extends true = true,\n  _T46 extends true = true,\n  _T47 extends true = true,\n  _T48 extends true = true,\n  _T49 extends true = true,\n  _T50 extends true = true,\n  _T51 extends true = true,\n  _T52 extends true = true,\n  _T53 extends true = true,\n  _T54 extends true = true,\n  _T55 extends true = true,\n  _T56 extends true = true,\n  _T57 extends true = true,\n  _T58 extends true = true,\n  _T59 extends true = true,\n  _T60 extends true = true,\n  _T61 extends true = true,\n  _T62 extends true = true,\n  _T63 extends true = true,\n  _T64 extends true = true,\n  _T65 extends true = true,\n  _T66 extends true = true,\n  _T67 extends true = true,\n  _T68 extends true = true,\n  _T69 extends true = true,\n  _T70 extends true = true,\n  _T71 extends true = true,\n  _T72 extends true = true,\n  _T73 extends true = true,\n  _T74 extends true = true,\n  _T75 extends true = true,\n  _T76 extends true = true,\n  _T77 extends true = true,\n  _T78 extends true = true,\n  _T79 extends true = true,\n  _T80 extends true = true,\n  _T81 extends true = true,\n  _T82 extends true = true,\n  _T83 extends true = true,\n  _T84 extends true = true,\n  _T85 extends true = true,\n  _T86 extends true = true,\n  _T87 extends true = true,\n  _T88 extends true = true,\n  _T89 extends true = true,\n  _T90 extends true = true,\n  _T91 extends true = true,\n  _T92 extends true = true,\n  _T93 extends true = true,\n  _T94 extends true = true,\n  _T95 extends true = true,\n  _T96 extends true = true,\n  _T97 extends true = true,\n  _T98 extends true = true,\n  _T99 extends true = true,\n  _T100 extends true = true,\n> = true",
                  "description": "Type-level batch assertion helper that accepts multiple assertions.\nEach type parameter must extend true, allowing batch type assertions.",
                  "examples": [
                    {
                      "code": "Equal<string, string>,     // ✓ Pass\n  Extends<string, 'hello'>,  // ✓ Pass\n  Never<never>               // ✓ Pass\n>\n\n// Type error if any assertion fails\ntype _ = Ts.Test.Cases<\n  Equal<string, string>,     // ✓ Pass\n  Equal<string, number>,     // ✗ Fail - Type error here\n  Extends<string, 'hello'>   // ✓ Pass\n>",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/test.ts",
                    "line": 939
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Union",
            "type": "namespace",
            "signature": "export * as Union",
            "description": "Valid values for discriminant properties in tagged unions.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/$$.ts",
              "line": 6
            },
            "module": {
              "name": "Union",
              "description": "Valid values for discriminant properties in tagged unions.",
              "exports": [
                {
                  "name": "DiscriminantPropertyValue",
                  "signature": "export type DiscriminantPropertyValue = string | number | symbol",
                  "description": "Valid values for discriminant properties in tagged unions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 4
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "__FORCE_DISTRIBUTION__",
                  "signature": "export type __FORCE_DISTRIBUTION__ = any",
                  "description": "Marker type to make forced union distribution explicit and self-documenting.\n\nTypeScript distributes unions in conditional types when the checked type is a naked type parameter.\nUsing this marker in your conditional type makes the intent explicit to readers.",
                  "examples": [
                    {
                      "code": "type Transform<T> = T extends string ? Uppercase<T> : T\n\n// With marker - explicitly documents that distribution is desired\ntype Transform<T> = T extends __FORCE_DISTRIBUTION__ ? T extends string ? Uppercase<T> : T : never\n\n// More typical usage pattern\ntype MapUnion<T> = T extends __FORCE_DISTRIBUTION__\n  ? TransformSingleMember<T>\n  : never",
                      "twoslashEnabled": true,
                      "language": "ts"
                    },
                    {
                      "code": "type AddPrefix<T> = T extends __FORCE_DISTRIBUTION__\n  ? T extends string ? `prefix_${T}` : T\n  : never\n\ntype Result = AddPrefix<'a' | 'b' | 'c'>\n// 'prefix_a' | 'prefix_b' | 'prefix_c'",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 37
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Include",
                  "signature": "export type Include<$T, $U> = $T extends $U ? $T : never",
                  "description": "Include only types that extend a constraint (opposite of Exclude).\nFilters a union type to only include members that extend the constraint.",
                  "examples": [
                    {
                      "code": "type T2 = Union.Include<'a' | 'b' | 1 | 2, string>  // 'a' | 'b'",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 49
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "ToTuple",
                  "signature": "export type ToTuple<\n  $Union,\n  ___L = LastOf<$Union>,\n  ___N = [$Union] extends [never] ? true : false,\n> = true extends ___N ? []\n  : [...ToTuple<Exclude<$Union, ___L>>, ___L]",
                  "description": "Convert a union type to a tuple type.",
                  "examples": [
                    {
                      "code": "",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 59
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "ToIntersection",
                  "signature": "export type ToIntersection<$U> = ($U extends any ? (k: $U) => void : never) extends ((k: infer __i__) => void) ? __i__\n  : never",
                  "description": "Convert a union type to an intersection type.",
                  "examples": [
                    {
                      "code": "type I = Union.ToIntersection<U>  // { a: string } & { b: number }",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 75
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "LastOf",
                  "signature": "export type LastOf<$T> = ToIntersection<$T extends any ? () => $T : never> extends () => infer __r__ ? __r__\n  : never",
                  "description": "Get the last type in a union.",
                  "examples": [
                    {
                      "code": "",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 86
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Expanded",
                  "signature": "export type Expanded<$Union> = $Union",
                  "description": "Force union distribution in conditional types.",
                  "examples": [
                    {
                      "code": "",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 97
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IgnoreAnyOrUnknown",
                  "signature": "export type IgnoreAnyOrUnknown<$T> = unknown extends $T ? never : $T",
                  "description": "Union that ignores any and unknown.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 102
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsAnyMemberExtends",
                  "signature": "export type IsAnyMemberExtends<$Union, $Type> =\n  (\n    // [1] Force distribution\n    $Union extends any ?\n      ($Union /* member */ extends $Type ? true : false) :\n      never // [1]\n  ) extends false\n    ? false\n    : true",
                  "description": "Check if any member of a union extends a type.",
                  "examples": [
                    {
                      "code": "type T2 = Union.IsAnyMemberExtends<number | boolean, string>  // false",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 114
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsHas",
                  "signature": "export type IsHas<$Type, $LookingFor> =\n  _IsHas<$Type, $LookingFor> extends false\n    ? false\n    : true",
                  "description": "Checks if a union type contains a specific type.\n\nReturns `true` if any member of the union type extends the target type,\n`false` otherwise. This is useful for conditional type logic based on\nunion membership.",
                  "examples": [
                    {
                      "code": "type HasDate = Union.IsHas<string | number, Date>                // false\ntype HasLiteral = Union.IsHas<'a' | 'b' | 'c', 'b'>             // true\n\n// Useful in conditional types\ntype ProcessValue<T> = Union.IsHas<T, Promise<any>> extends true\n  ? 'async'\n  : 'sync'\n\ntype R1 = ProcessValue<string | Promise<string>>  // 'async'\ntype R2 = ProcessValue<string | number>           // 'sync'",
                      "twoslashEnabled": true,
                      "language": "ts"
                    },
                    {
                      "code": "type Events = { type: 'click' } | { type: 'hover' } | { type: 'focus' }\ntype HasClick = Union.IsHas<Events, { type: 'click' }>  // true\n\n// Check for any promise in union\ntype MaybeAsync<T> = Union.IsHas<T, Promise<any>>\ntype R3 = MaybeAsync<string | Promise<number>>  // true\ntype R4 = MaybeAsync<string | number>           // false",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "template": "- The type to search for"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 162
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Merge",
                  "signature": "export type Merge<$U> = {\n  [\n    k in (\n      $U extends any ? keyof $U : never\n    )\n  ]: $U extends any ? (k extends keyof $U ? $U[k] : never) : never\n}",
                  "description": "Merge all members of a union into a single type.",
                  "examples": [
                    {
                      "code": "type M = Union.Merge<U>  // { a: string; b: number }",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": "src/utils/ts/union.ts",
                    "line": 182
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "_tag": "value",
            "name": "Variance",
            "type": "namespace",
            "signature": "export * as Variance",
            "description": "Phantom type helper that makes a type parameter covariant.\n\n@remarks\nCovariance allows subtypes to be assigned to supertypes (natural direction).\nExample: `Phantom<Covariant<1>>` can be assigned to `Phantom<Covariant<number>>`.\n\nUse this when you want narrower types to flow to wider types:\n- Literal types → base types (`1` → `number`, `'hello'` → `string`)\n- Subclasses → base classes\n- More specific → more general\n\n@example\n```ts\ninterface Container<T> {\n  readonly __type?: Covariant<T>\n}\n\nlet narrow: Container<1> = {}\nlet wide: Container<number> = {}\n\nwide = narrow  // ✅ Allowed (1 extends number)\nnarrow = wide  // ❌ Error (number does not extend 1)\n```\n\n@see {@link https://www.typescriptlang.org/docs/handbook/type-compatibility.html | TypeScript Type Compatibility}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/$$.ts",
              "line": 7
            },
            "module": {
              "name": "Variance",
              "description": "Phantom type helper that makes a type parameter covariant.\n\n@remarks\nCovariance allows subtypes to be assigned to supertypes (natural direction).\nExample: `Phantom<Covariant<1>>` can be assigned to `Phantom<Covariant<number>>`.\n\nUse this when you want narrower types to flow to wider types:\n- Literal types → base types (`1` → `number`, `'hello'` → `string`)\n- Subclasses → base classes\n- More specific → more general\n\n@example\n```ts\ninterface Container<T> {\n  readonly __type?: Covariant<T>\n}\n\nlet narrow: Container<1> = {}\nlet wide: Container<number> = {}\n\nwide = narrow  // ✅ Allowed (1 extends number)\nnarrow = wide  // ❌ Error (number does not extend 1)\n```\n\n@see {@link https://www.typescriptlang.org/docs/handbook/type-compatibility.html | TypeScript Type Compatibility}",
              "exports": [
                {
                  "name": "Co",
                  "signature": "export type Co<$T> = () => $T",
                  "description": "Phantom type helper that makes a type parameter covariant.",
                  "examples": [
                    {
                      "code": "readonly __type?: Covariant<T>\n}\n\nlet narrow: Container<1> = {}\nlet wide: Container<number> = {}\n\nwide = narrow  // ✅ Allowed (1 extends number)\nnarrow = wide  // ❌ Error (number does not extend 1)",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "remarks": "Covariance allows subtypes to be assigned to supertypes (natural direction).\nExample: `Phantom<Covariant<1>>` can be assigned to `Phantom<Covariant<number>>`.\n\nUse this when you want narrower types to flow to wider types:\n- Literal types → base types (`1` → `number`, `'hello'` → `string`)\n- Subclasses → base classes\n- More specific → more general",
                    "see": "{@link https://www.typescriptlang.org/docs/handbook/type-compatibility.html | TypeScript Type Compatibility}"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/variance.ts",
                    "line": 28
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Contra",
                  "signature": "export type Contra<$T> = (value: $T) => void",
                  "description": "Phantom type helper that makes a type parameter contravariant.",
                  "examples": [
                    {
                      "code": "readonly __type?: Contravariant<T>\n}\n\nlet narrow: Handler<1> = {}\nlet wide: Handler<number> = {}\n\nnarrow = wide  // ✅ Allowed (reversed direction!)\nwide = narrow  // ❌ Error",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "remarks": "Contravariance allows supertypes to be assigned to subtypes (opposite direction).\nExample: `Phantom<Contravariant<number>>` can be assigned to `Phantom<Contravariant<1>>`.\n\nThis is useful for function parameters where a handler that accepts wider types\ncan substitute for one that accepts narrower types.",
                    "see": "{@link https://www.typescriptlang.org/docs/handbook/type-compatibility.html#function-parameter-bivariance | Function Parameter Bivariance}"
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/variance.ts",
                    "line": 55
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "In",
                  "signature": "export type In<$T> = (value: $T) => $T",
                  "description": "Phantom type helper that makes a type parameter invariant.",
                  "examples": [
                    {
                      "code": "readonly __type?: Invariant<T>\n}\n\nlet one: Exact<1> = {}\nlet num: Exact<number> = {}\n\nnum = one  // ❌ Error (no direction works)\none = num  // ❌ Error (no direction works)",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "remarks": "Invariance requires exact type matches - no subtype or supertype assignments allowed.\nThis is the strictest variance, useful when you need precise type guarantees."
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/variance.ts",
                    "line": 77
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Bi",
                  "signature": "export type Bi<$T> = { bivariantHack(value: $T): void }['bivariantHack']",
                  "description": "Phantom type helper that makes a type parameter bivariant (unsafe).",
                  "examples": [
                    {
                      "code": "readonly __type?: Bivariant<T>\n}\n\nlet one: Unsafe<1> = {}\nlet num: Unsafe<number> = {}\n\nnum = one  // ⚠️ Allowed (both directions work)\none = num  // ⚠️ Allowed (unsafe!)",
                      "twoslashEnabled": true,
                      "language": "ts"
                    }
                  ],
                  "tags": {
                    "remarks": "Bivariance allows assignments in BOTH directions. This is generally unsafe as it\ncan allow runtime type errors. Only use when absolutely necessary."
                  },
                  "sourceLocation": {
                    "file": "src/utils/ts/variance.ts",
                    "line": 99
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "name": "Print",
            "signature": "export type Print<$Type, $Fallback extends string | undefined = undefined> =\n  // Language base category types\n    IsAny<$Type> extends true     ? 'any'\n  : IsUnknown<$Type> extends true ? 'unknown'\n  : IsNever<$Type> extends true   ? 'never'\n\n  // Special union type boolean which we display as boolean insead of true | false\n  : [$Type] extends [boolean]      ? ([boolean] extends [$Type] ? 'boolean' : `${$Type}`)\n\n  // General unions types\n  : UnionToTuple<$Type> extends ArrMut.Any2OrMoreRO ? _PrintUnion<UnionToTuple<$Type>>\n\n  // Primitive and literal types\n  : $Type extends true             ? 'true'\n  : $Type extends false            ? 'false'\n  : $Type extends void             ? ($Type extends undefined ? 'undefined' : 'void')\n  : $Type extends string           ? (string extends $Type    ? 'string'  : `'${$Type}'`)\n  : $Type extends number           ? (number extends $Type    ? 'number'  : `${$Type}`)\n  : $Type extends bigint           ? (bigint extends $Type    ? 'bigint'  : `${$Type}n`)\n  : $Type extends null             ? 'null'\n  : $Type extends undefined        ? 'undefined'\n\n  // User-provided fallback takes precedence if type is not a primitive\n  : $Fallback extends string       ? $Fallback\n\n  // Common object types and specific generic patterns\n  : $Type extends Promise<infer T> ? `Promise<${Print<T>}>`\n  : $Type extends (infer T)[]      ? `Array<${Print<T>}>`\n  : $Type extends readonly (infer T)[]      ? `ReadonlyArray<${Print<T>}>`\n  : $Type extends Date             ? 'Date'\n  : $Type extends RegExp           ? 'RegExp'\n  //\n  : $Type extends Function         ? 'Function'\n  : $Type extends symbol           ? 'symbol'\n\n  // General object fallback\n  : $Type extends object           ? 'object'\n\n  // Ultimate fallback\n  : '?'",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/print.ts",
              "line": 6
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "_PrintUnion",
            "signature": "export type _PrintUnion<$Type extends ArrMut.AnyRO> =\n    $Type extends readonly [infer __first__, ...infer __rest__ extends ArrMut.Any1OrMoreRO]\n      ? `${Print<__first__>} | ${_PrintUnion<__rest__>}`\n      : $Type extends readonly [infer __first__]\n        ? `${Print<__first__>}`\n        : $Type extends ArrMut.EmptyRO\n          ? ''\n          : never",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/print.ts",
              "line": 48
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "as",
            "signature": "<$value>(value?: unknown) => $value",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 22
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Interpolatable",
            "signature": "export type Interpolatable =\n  | string\n  | number\n  | bigint\n  | boolean\n  | null\n  | undefined\n  | symbol\n  | object\n  | unknown\n  | any\n  | never",
            "description": "Types that TypeScript accepts being interpolated into a Template Literal Type.\n\nThese are the types that can be used within template literal types without causing\na TypeScript error. When a value of one of these types is interpolated into a\ntemplate literal type, TypeScript will properly convert it to its string representation.",
            "examples": [
              {
                "code": "type Valid1 = `Value: ${string}`\ntype Valid2 = `Count: ${number}`\ntype Valid3 = `Flag: ${boolean}`\ntype Valid4 = `ID: ${123n}`\n\n// Example usage in conditional types:\ntype Stringify<T extends Interpolatable> = `${T}`\ntype Result1 = Stringify<42>        // \"42\"\ntype Result2 = Stringify<true>      // \"true\"\ntype Result3 = Stringify<'hello'>   // \"hello\"",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 46
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "StaticError",
            "signature": "export interface StaticError<\n  $Message extends string = string,\n  $Context extends object = {},\n  $Hint extends string = '(none)',\n> {\n  ERROR: $Message\n  CONTEXT: $Context\n  HINT: $Hint\n}",
            "description": "Represents a type error that can be surfaced at the type level.\n\nThis is useful for providing more informative error messages directly in TypeScript's\ntype checking, often used with conditional types or generic constraints. When TypeScript\nencounters this type, it will display the error information in a structured way.",
            "examples": [
              {
                "code": "type RequireString<T> = T extends string ? T : StaticError<\n  'Type must be a string',\n  { Received: T },\n  'Consider using string or a string literal type'\n>\n\ntype Good = RequireString<'hello'>  // 'hello'\ntype Bad = RequireString<number>    // StaticError<...>",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "function processString<T>(\n  value: T extends string ? T : StaticError<\n    'Argument must be a string',\n    { ProvidedType: T }\n  >\n): void {\n  // Implementation\n}\n\nprocessString('hello')  // OK\nprocessString(42)       // Type error with custom message",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- A string literal type providing a hint for resolving the error"
            },
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 100
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "StaticErrorAny",
            "signature": "export type StaticErrorAny = StaticError<string, object, string>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 110
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StaticErrorAssertion",
            "signature": "export interface StaticErrorAssertion<\n  $Message extends string = string,\n  $Expected = unknown,\n  $Actual = unknown,\n  $Tip extends string = never,\n> {\n  MESSAGE: $Message\n  EXPECTED: $Expected\n  ACTUAL: $Actual\n  TIP: $Tip\n}",
            "description": "Represents a static assertion error at the type level, optimized for type testing.\n\nThis is a simpler, more focused error type compared to {@link StaticError}. It's specifically\ndesigned for type assertions where you need to communicate expected vs. actual types.",
            "examples": [
              {
                "code": "function assertParameters<T extends readonly any[]>(\n  fn: Parameters<typeof fn> extends T ? typeof fn\n    : StaticErrorAssertion<\n      'Parameters mismatch',\n      T,\n      Parameters<typeof fn>\n    >\n): void {}\n\n// Error shows:\n// MESSAGE: 'Parameters mismatch'\n// EXPECTED: [string, number]\n// ACTUAL: [number, string]",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- The actual type that was provided"
            },
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 140
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "Show",
            "signature": "export type Show<$Type> = `\\`${Print<$Type>}\\``",
            "description": "Like {@link Print} but adds additional styling to display the rendered type in a sentence.\n\nUseful for type-level error messages where you want to clearly distinguish type names\nfrom surrounding text. Wraps the printed type with backticks (\\`) like inline code in Markdown.",
            "examples": [
              {
                "code": "// Result: \"Expected `string` but got `number`\"\n\ntype Message2 = `The type ${Show<'hello' | 'world'>} is not assignable`\n// Result: \"The type `'hello' | 'world'` is not assignable\"\n\n// Using in error messages\ntype TypeError<Expected, Actual> = StaticError<\n  `Type mismatch: expected ${Show<Expected>} but got ${Show<Actual>}`,\n  { Expected, Actual }\n>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- The type to format and display"
            },
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 175
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ShowInTemplate",
            "signature": "export type ShowInTemplate<$Type> = `'${Print<$Type>}'`",
            "description": "Version of {@link Show} but uses single quotes instead of backticks.\n\nThis can be useful in template literal types where backticks would be rendered as \"\\`\"\nwhich is not ideal for readability. Use this when the output will be used within\nanother template literal type or when backticks cause display issues.\n\nNote that when working with TS-level errors, if TS can instantiate all the types involved then\nthe result will be a string, not a string literal type. So when working with TS-level errors,\nonly reach for this variant of {@link Show} if you think there is likelihood that types won't be instantiated.",
            "examples": [
              {
                "code": "type ErrorInTemplate = `Error: ${ShowInTemplate<string>} is required`\n// Result: \"Error: 'string' is required\"\n\n// Comparing Show vs ShowInTemplate\ntype WithShow = `Type is ${Show<number>}`\n// May display as: \"Type is \\`number\\`\" (escaped backticks)\n\ntype WithShowInTemplate = `Type is ${ShowInTemplate<number>}`\n// Displays as: \"Type is 'number'\" (cleaner)",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- The type to format and display"
            },
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 204
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Simplify",
            "signature": "export type Simplify<$Type> =\n  & {\n    [_ in keyof $Type]: $Type[_]\n  }\n  & unknown",
            "description": "Simplifies complex type intersections and mapped types for better readability.\n\nForces TypeScript to evaluate and flatten a type, which is especially useful for:\n- Intersection types that appear as `A & B & C` in tooltips\n- Complex mapped types that show their internal structure\n- Making type aliases more readable in IDE tooltips",
            "examples": [
              {
                "code": "type Complex = { a: string } & { b: number } & { c: boolean }\n// Tooltip shows: { a: string } & { b: number } & { c: boolean }\n\n// With Simplify\ntype Simple = Simplify<Complex>\n// Tooltip shows: { a: string; b: number; c: boolean }",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "type UserPermissions =\n  & { read: boolean }\n  & { write: boolean }\n  & { admin: boolean }\n\ntype FlatPermissions = Simplify<UserPermissions>\n// Shows as: { read: boolean; write: boolean; admin: boolean }\n\n// Useful with generic constraints\nfunction processUser<T extends Simplify<UserPermissions>>(user: T) {\n  // T will show flattened structure in errors and tooltips\n}",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- The type to simplify"
            },
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 244
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "SimplifyNullable",
            "signature": "export type SimplifyNullable<$T> = null extends $T ? (Simplify<$T> & {}) | null : Simplify<$T> & {}",
            "description": "Simplify a type while preserving `| null` unions.\n\nThis solves a subtle problem with {@link Simplify}: when you have `Type | null`,\nusing `Simplify<Type | null>` can absorb or transform the `null` in unexpected ways\ndue to the intersection with `& unknown` or `& {}`. This utility checks for null first,\nthen explicitly reconstructs the union to ensure `| null` remains intact.\n\n**When to use:**\n- Use {@link SimplifyNullable} when simplifying types that may contain `| null` or `| undefined`\n- Use {@link Simplify} for non-nullable types or when null handling doesn't matter",
            "examples": [
              {
                "code": "type User = { name: string } & { age: number }\ntype MaybeUser = User | null\ntype Bad = Simplify<MaybeUser>  // May not preserve | null correctly\n\n// Solution: SimplifyNullable preserves the null union\ntype Good = SimplifyNullable<MaybeUser>  // { name: string; age: number } | null",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "type Simple = SimplifyNullable<{ a: 1 } & { b: 2 }>  // { a: 1; b: 2 }\n\n// Preserves null in unions\ntype Nullable = SimplifyNullable<({ a: 1 } & { b: 2 }) | null>  // { a: 1; b: 2 } | null",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- The type to simplify"
            },
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 284
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ExtendsExact",
            "signature": "export type ExtendsExact<$Input, $Constraint> =\n  $Input extends $Constraint\n    ? $Constraint extends $Input\n      ? $Input\n      : never\n    : never",
            "description": "Utilities for working with union types at the type level.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 324
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "NotExtends",
            "signature": "export type NotExtends<$A, $B> = [$A] extends [$B] ? false : true",
            "description": "Type-level utility that checks if a type does NOT extend another type.\n\nReturns `true` if type A does not extend type B, `false` otherwise.\nUseful for conditional type logic where you need to check the absence\nof a type relationship.",
            "examples": [
              {
                "code": "type T2 = NotExtends<'hello', string>     // false ('hello' extends string)\ntype T3 = NotExtends<42, number>          // false (42 extends number)\ntype T4 = NotExtends<{ a: 1 }, { b: 2 }>  // true (different properties)",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "type VarBuilderToType<$Type, $VarBuilder> =\n  $VarBuilder['required'] extends true                     ? Exclude<$Type, undefined> :\n  NotExtends<$VarBuilder['default'], undefined> extends true ? $Type | undefined :\n                                                              $Type\n\n// If default is undefined, type is just $Type\n// If default is not undefined, type is $Type | undefined",
                "twoslashEnabled": true,
                "language": "ts"
              },
              {
                "code": "type SafeDivide<T> = NotExtends<T, 0> extends true\n  ? number\n  : StaticError<'Cannot divide by zero'>\n\ntype Result1 = SafeDivide<5>   // number\ntype Result2 = SafeDivide<0>   // StaticError<'Cannot divide by zero'>",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {
              "template": "- The type to check against",
              "returns": "`true` if $A does not extend $B, `false` otherwise"
            },
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 373
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Writeable",
            "signature": "export type Writeable<$Object> = {\n  -readonly [k in keyof $Object]: $Object[k]\n}",
            "description": "Make all properties in an object mutable (removes readonly modifiers).",
            "examples": [
              {
                "code": "type Mutable = Writeable<Readonly>  // { x: number; y: string }",
                "twoslashEnabled": true,
                "language": "ts"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 384
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IfExtendsElse",
            "signature": "export type IfExtendsElse<$Type, $Extends, $Then, $Else> = $Type extends $Extends ? $Then : $Else",
            "examples": [],
            "deprecated": "- Commented out 2025-01-07\n\nThis utility was too strict - requires BIDIRECTIONAL extends, which rejects\nvalid narrowed types (e.g., { id: true } for { id: boolean }).\n\nUse Obj.NoExcess instead, which:\n- ✓ Rejects excess properties (what you want)\n- ✓ Allows valid subtypes/narrowing (what you need)\n\nIf a use case for true bidirectional exact matching emerges, uncomment.\nOtherwise, remove after 3-6 months (target: ~2025-07-01).\n\nOriginal implementation:",
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 423
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IntersectionIgnoreNeverOrAny",
            "signature": "export type IntersectionIgnoreNeverOrAny<$T> = IsAny<$T> extends true ? unknown : $T extends never ? unknown : $T",
            "description": "Intersection that ignores never and any.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 428
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "NeverOrAnyToUnknown",
            "signature": "export type NeverOrAnyToUnknown<$T> = IsAny<$T> extends true ? unknown : $T extends never ? unknown : $T",
            "description": "Convert never or any to unknown.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 433
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Narrowable",
            "signature": "export type Narrowable = string | number | bigint | boolean | []",
            "description": "Any narrowable primitive type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 438
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "AnyAndUnknownToNever",
            "signature": "export type AnyAndUnknownToNever<$T> = IsAny<$T> extends true ? never : IsUnknown<$T> extends true ? never : $T",
            "description": "Convert any and unknown to never.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/ts.ts",
              "line": 443
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isTypeWith",
            "signature": "<reference>(reference: reference) => <valueGiven>(value: ValidateIsSupertype<reference, valueGiven>) => value is reference extends valueGiven ? reference : never",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/type-guards.ts",
              "line": 18
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isntTypeWith",
            "signature": "<reference>(reference: reference) => <valueGiven>(value: ValidateIsSupertype<reference, valueGiven>) => value is reference extends valueGiven ? Exclude<valueGiven, reference> : never",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/ts/type-guards.ts",
              "line": 41
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    },
    {
      "packagePath": "./value",
      "resolvedPath": "./src/utils/value/$.ts",
      "module": {
        "name": "Value",
        "description": "General value utilities for common JavaScript values and patterns.\n\nProvides utilities for lazy values, type guards for symbols and dates,\nidentity proxies, and lazy value resolution. Includes helpers for working\nwith deferred computations and value type checking.",
        "exports": [
          {
            "name": "Lazy",
            "signature": "export type Lazy<$Value> = () => $Value",
            "description": "A lazy value that is computed when called.",
            "examples": [],
            "tags": {
              "template": "- The type of value that will be returned when the lazy function is invoked"
            },
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "lazy",
            "signature": "<const value>(value: value) => Lazy<value>",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 23
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "LazyMaybe",
            "signature": "export type LazyMaybe<$Value = unknown> = $Value | Lazy<$Value>",
            "description": "A value that may be either immediate or lazy.",
            "examples": [],
            "tags": {
              "template": "- The type of the value, whether immediate or lazy"
            },
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 29
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "resolveLazy",
            "signature": "export type resolveLazy<$LazyMaybeValue extends LazyMaybe<any>> =\n  $LazyMaybeValue extends Lazy<infer __value__> ? __value__ : $LazyMaybeValue",
            "description": "Type-level resolution of a LazyMaybe value.\nExtracts the underlying value type whether it's lazy or immediate.",
            "examples": [],
            "tags": {
              "template": "- A value that may be lazy or immediate"
            },
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 37
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "resolveLazyFactory",
            "signature": "<value>(lazyMaybeValue: LazyMaybe<value>) => () => value",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 82
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "identityProxy",
            "signature": "{}",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 99
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isSymbol",
            "signature": "(value: unknown) => value is symbol",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 114
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isDate",
            "signature": "(value: unknown) => value is Date",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": "src/utils/value/value.ts",
              "line": 137
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      }
    }
  ],
  "metadata": {
    "extractedAt": "2025-10-09T03:42:08.368Z",
    "extractorVersion": "0.1.0"
  }
}
