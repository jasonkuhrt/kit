{
  "name": "@wollybeard/kit",
  "version": "0.0.0-dripip",
  "entrypoints": [
    {
      "path": "./arr",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "arr"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Array utilities for working with readonly and mutable arrays.  \n\nProvides functional utilities for array operations including mapping, filtering, type guards, and conversions. Emphasizes immutable operations and type safety.",
        "category": "Core Data Structures",
        "exports": [
          {
            "name": "Eq",
            "signature": {
              "type": "Eq<Any>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Eq trait implementation for immutable arrays.  \n\nProvides deep structural equality for readonly arrays by recursively comparing elements using their appropriate Eq implementations.",
            "examples": [
              {
                "code": "import { Arr } from '@wollybeard/kit'\n\n// Basic array equality\nArr.Eq.is([1, 2, 3], [1, 2, 3]) // true\nArr.Eq.is([1, 2, 3], [1, 2, 4]) // false\nArr.Eq.is([1, 2], [1, 2, 3]) // false (different lengths)\n\n// Nested arrays\nArr.Eq.is(\n  [[1, 2], [3, 4]],\n  [[1, 2], [3, 4]]\n) // true\n\n// Mixed types\nArr.Eq.is(\n  [1, 'hello', true],\n  [1, 'hello', true]\n) // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": {
              "type": "Type<Any>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Type trait implementation for immutable arrays.  \n\nProvides type checking for readonly array values using Array.isArray.",
            "examples": [
              {
                "code": "import { Arr } from '@wollybeard/kit'\n\nArr.Type.is([1, 2, 3])     // true\nArr.Type.is([])            // true\nArr.Type.is('not array')   // false\nArr.Type.is(null)          // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 21
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "assert",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The value to check"
                    }
                  ],
                  "returnType": "void",
                  "throws": [
                    "TypeError If the value is not an array"
                  ]
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Assert that a value is an array. Throws a TypeError if the value is not an array.",
            "examples": [
              {
                "code": "function process(value: unknown) {\n  Arr.assert(value)\n  // value is now typed as unknown[]\n  value.forEach(item => console.log(item))\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {
              "throws": "TypeError If the value is not an array"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 124
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Unknown",
            "signature": {
              "text": "type Unknown = readonly unknown[]",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Any",
            "signature": {
              "text": "type Any = readonly any[]",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Empty",
            "signature": {
              "text": "type Empty = readonly []",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "All",
            "signature": {
              "text": "type All<$Tuple extends [...boolean[]]> = $Tuple[number] extends true ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if all booleans in a tuple are true.",
            "examples": [
              {
                "code": "type T1 = All<[true, true, true]>  // true\ntype T2 = All<[true, false, true]>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsTupleMultiple",
            "signature": {
              "text": "type IsTupleMultiple<$T> = $T extends [unknown, unknown, ...unknown[]] ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a tuple has multiple elements.",
            "examples": [
              {
                "code": "type T1 = IsTupleMultiple<[1, 2]>  // true\ntype T2 = IsTupleMultiple<[1]>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 39
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Push",
            "signature": {
              "text": "type Push<$T extends any[], $V> = [...$T, $V]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Push a value onto a tuple.",
            "examples": [
              {
                "code": "type T = Push<[1, 2], 3>  // [1, 2, 3]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "FirstNonUnknownNever",
            "signature": {
              "text": "type FirstNonUnknownNever<$T extends any[]> = $T extends [infer __first__, ...infer __rest__]\n  ? unknown extends __first__ ? 0 extends 1 & __first__ ? FirstNonUnknownNever<__rest__> // is any\n    : FirstNonUnknownNever<__rest__> // is unknown\n  : __first__ extends never ? FirstNonUnknownNever<__rest__>\n  : __first__\n  : never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Get the first non-unknown, non-never element from a tuple.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 57
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "empty",
            "signature": {
              "type": "readonly []",
              "_tag": "ValueSignatureModel"
            },
            "description": "Empty array constant.",
            "examples": [
              {
                "code": "import { Arr } from '@wollybeard/kit'\n\nconst emptyArray = Arr.empty\nconsole.log(emptyArray) // []",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use Array.empty from Effect instead",
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 78
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "emptyArray",
            "signature": {
              "type": "readonly []",
              "_tag": "ValueSignatureModel"
            },
            "description": "Empty array constant (frozen). Useful as a default value or sentinel.",
            "examples": [
              {
                "code": "const arr = items ?? Arr.emptyArray",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 90
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "EmptyArray",
            "signature": {
              "text": "type EmptyArray = typeof emptyArray",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type for the empty array constant.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 97
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "includes",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "array",
                      "type": "$T[]",
                      "optional": false,
                      "rest": false,
                      "description": "The array to search in"
                    },
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The unknown value to search for"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value is in the array, with type narrowing",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type-safe array includes check that narrows the type of the value. Unlike the standard `includes`, this provides proper type narrowing.",
            "examples": [
              {
                "code": "const fruits = ['apple', 'banana', 'orange'] as const\nconst value: unknown = 'apple'\n\nif (Arr.includes(fruits, value)) {\n  // value is now typed as 'apple' | 'banana' | 'orange'\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Search",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 148
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensure",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "$T | $T[]",
                      "optional": false,
                      "rest": false,
                      "description": "The value to ensure as array"
                    }
                  ],
                  "returnType": "$T[]",
                  "returnDoc": "An array containing the value(s)",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Ensure a value is an array. If the value is already an array, return it as-is. Otherwise, wrap it in an array.",
            "examples": [
              {
                "code": "Arr.ensure('hello')  // ['hello']\nArr.ensure(['a', 'b'])  // ['a', 'b']\nArr.ensure(42)  // [42]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Normalization",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 169
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "last",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "array",
                      "type": "readonly $T[]",
                      "optional": false,
                      "rest": false,
                      "description": "The array to get the last element from"
                    }
                  ],
                  "returnType": "$T | undefined",
                  "returnDoc": "The last element, or `undefined` if the array is empty",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get the last element of an array.",
            "examples": [
              {
                "code": "Arr.last([1, 2, 3])  // 3\nArr.last(['a'])  // 'a'\nArr.last([])  // undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 186
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "transpose",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "rows",
                      "type": "readonly (readonly $T[])[]",
                      "optional": false,
                      "rest": false,
                      "description": "The 2D array to transpose"
                    }
                  ],
                  "returnType": "$T[][]",
                  "returnDoc": "The transposed 2D array",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Transpose a 2D array (convert rows to columns and vice versa). This is a classic matrix transpose operation.  \n\nHandles ragged arrays (rows with different lengths) by creating columns that only contain elements from rows that had values at that position.",
            "examples": [
              {
                "code": "const rows = [\n  [1, 2, 3],\n  [4, 5, 6]\n]\nArr.transpose(rows)\n// [[1, 4], [2, 5], [3, 6]]\n\nconst table = [\n  ['Alice', 'Engineer', '100k'],\n  ['Bob', 'Designer', '90k']\n]\nArr.transpose(table)\n// [['Alice', 'Bob'], ['Engineer', 'Designer'], ['100k', '90k']]\n\n// Ragged array (uneven row lengths)\nconst ragged = [[1, 2, 3], [4, 5]]\nArr.transpose(ragged)\n// [[1, 4], [2, 5], [3]]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "arr"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arr",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 222
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./err",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "err"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Error handling utilities for robust error management.  \n\nProvides utilities for error inspection, stack trace manipulation, try-catch wrappers, type guards, and null safety. Features formatted error logging and error wrapping utilities.",
        "category": "Error Handling & Values",
        "exports": [
          {
            "name": "log",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "error",
                      "type": "Error",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "options",
                      "type": "{ color?: boolean; stackTraceColumns?: number; identColumns?: number; maxFrames?: number; showHelp?: boolean; } | undefined",
                      "optional": true,
                      "rest": false
                    }
                  ],
                  "returnType": "void",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Log an error to console with nice formatting.",
            "examples": [],
            "category": "Inspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 23
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "throwNull",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "V"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "V",
                      "optional": false,
                      "rest": false,
                      "description": "The value to check"
                    },
                    {
                      "name": "message",
                      "type": "string | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Optional custom error message"
                    }
                  ],
                  "returnType": "Exclude<V, null>",
                  "returnDoc": "The value if not null",
                  "throws": [
                    "Error if the value is null"
                  ]
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Throw an error if the value is null, otherwise return the non-null value.",
            "examples": [
              {
                "code": "const result = throwNull(maybeNull) // throws if null\nconst safe = throwNull(maybeNull, 'Custom error message')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {
              "throws": "Error if the value is null"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 41
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "defaultThrowNullMessage",
            "signature": {
              "type": "\"Unexpected null value.\"",
              "_tag": "ValueSignatureModel"
            },
            "description": "Default error message used by throwNull when no custom message is provided.",
            "examples": [],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 52
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "guardNull",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fn",
                      "constraint": "Fn.AnyAny"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "fn",
                      "optional": false,
                      "rest": false,
                      "description": "The function to wrap"
                    },
                    {
                      "name": "message",
                      "type": "string | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Optional custom error message when null is returned"
                    }
                  ],
                  "returnType": "ReturnExclude<null, fn>",
                  "returnDoc": "A wrapped function that throws on null return values",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Wrap a function to throw an error if it returns null.",
            "examples": [
              {
                "code": "const find = (id: string) => items.find(item => item.id === id) ?? null\nconst findOrThrow = guardNull(find, 'Item not found')\n\nconst item = findOrThrow('123') // throws if not found",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 69
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ContextualError",
            "signature": {
              "text": "type ContextualError<$Context extends Record<string, unknown> = Record<string, unknown>> = Error & {\n  context: $Context\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "An error with additional contextual data.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "contextual",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 6
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "createContextualError",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Context",
                      "constraint": "Record<string, unknown>"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "message",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The error message"
                    },
                    {
                      "name": "context",
                      "type": "$Context",
                      "optional": false,
                      "rest": false,
                      "description": "Contextual data to attach to the error"
                    }
                  ],
                  "returnType": "ContextualError<$Context>",
                  "returnDoc": "An Error instance with the context attached",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create an error with contextual data about it.  \n\nThe context object is attached to the error instance and the message property is made enumerable for better debugging experience.",
            "examples": [
              {
                "code": "const error = Err.createContextualError('Failed to fetch user', {\n  userId: '123',\n  endpoint: '/api/users',\n  statusCode: 404\n})\n\nconsole.log(error.context.userId) // '123'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "contextual",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 33
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "_InferOptions",
            "signature": {
              "text": "type _InferOptions<$EnvironmentConfigurableOptions extends EnvironmentConfigurableOptionSpec[]> = {\n  [i in keyof $EnvironmentConfigurableOptions]: {\n    [_ in $EnvironmentConfigurableOptions[i]['name']]?: ReturnType<$EnvironmentConfigurableOptions[i]['parse']>\n  }\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 38
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "InspectOptions",
            "signature": {
              "text": "type InspectOptions = InferOptions<typeof optionSpecs>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Options for configuring error inspection output. All options can be overridden via environment variables.  \n\n color - Whether to use ANSI color codes for better readability (default: true, env: ERROR_DISPLAY_COLOR)  stackTraceColumns - Maximum column width before truncating stack trace lines (default: 120, env: ERROR_DISPLAY_STACK_TRACE_COLUMNS)  identColumns - Number of spaces to use for indentation (default: 4, env: ERROR_DISPLAY_IDENT_COLUMNS)  maxFrames - Maximum number of stack frames to show; 0 to hide stack traces entirely (default: 10, env: ERROR_DISPLAY_MAX_FRAMES)  showHelp - Whether to display the environment variable help section (default: true, env: ERROR_DISPLAY_SHOW_HELP)",
            "examples": [
              {
                "code": "// Use default options\nErr.inspect(error)\n\n// Customize options\nErr.inspect(error, {\n  color: false,\n  stackTraceColumns: 200,\n  showHelp: false\n})\n\n// Hide stack traces (useful for test snapshots)\nErr.inspect(error, { maxFrames: 0, showHelp: false, color: false })\n\n// Set via environment variables\nprocess.env.ERROR_DISPLAY_COLOR = 'false'\nprocess.env.ERROR_DISPLAY_SHOW_HELP = 'false'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Inspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 175
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "inspect",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "error",
                      "type": "Error",
                      "optional": false,
                      "rest": false,
                      "description": "The error to inspect"
                    },
                    {
                      "name": "options",
                      "type": "{ color?: boolean; stackTraceColumns?: number; identColumns?: number; maxFrames?: number; showHelp?: boolean; } | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Optional configuration for formatting"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "A formatted string representation of the error",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Render an error to a string with detailed formatting.  \n\nFeatures: - Nested error support (causes and aggregate errors) - Context object formatting - Stack trace cleaning with filtering indicators - Tree-like visual guides for nested structures - Configurable via options or environment variables",
            "examples": [
              {
                "code": "// Simple error\nconst error = new Error('Something went wrong')\nconsole.log(Err.inspect(error))\n\n// Error with context\nconst contextError = new Error('API failed')\ncontextError.context = { userId: 123, endpoint: '/api/users' }\nconsole.log(Err.inspect(contextError))\n\n// Aggregate error with multiple failures\nconst errors = [\n  new Error('Database connection failed'),\n  new Error('Redis timeout')\n]\nconst aggregate = new AggregateError(errors, 'Multiple services failed')\nconsole.log(Err.inspect(aggregate))\n\n// Disable help section\nconsole.log(Err.inspect(error, { showHelp: false }))",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Inspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "inspect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 239
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "StackOptions",
            "signature": {
              "text": "interface StackOptions {\n  /**\n   * Remove internal library frames from the stack trace.\n   * @default true\n   */\n  removeInternal?: boolean\n\n  /**\n   * Patterns to filter out from stack traces.\n   * @default ['node_modules', 'node:internal']\n   */\n  filterPatterns?: string[]\n\n  /**\n   * Maximum number of frames to show.\n   * @default 10\n   */\n  maxFrames?: number\n\n  /**\n   * Include source code context around error location.\n   * @default false\n   */\n  includeSource?: boolean\n\n  /**\n   * Number of source lines to show before and after error.\n   * @default 2\n   */\n  sourceContext?: number\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Options for cleaning and formatting stack traces.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "StackFrame",
            "signature": {
              "text": "interface StackFrame {\n  /**\n   * Function name or <anonymous>\n   */\n  function: string\n\n  /**\n   * File path\n   */\n  file: string\n\n  /**\n   * Line number\n   */\n  line: number\n\n  /**\n   * Column number\n   */\n  column: number\n\n  /**\n   * Whether this is internal to the library\n   */\n  isInternal: boolean\n\n  /**\n   * Whether this is a native V8 frame\n   */\n  isNative: boolean\n\n  /**\n   * Raw frame string\n   */\n  raw: string\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Parsed stack frame information.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 46
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "parseStack",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "stack",
                      "type": "string",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "StackFrame[]",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Parse a stack trace string into structured frames.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 88
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "StackCleanStats",
            "signature": {
              "text": "interface StackCleanStats {\n  /**\n   * Total number of frames before filtering.\n   */\n  totalFrames: number\n\n  /**\n   * Number of frames filtered out.\n   */\n  filteredFrames: number\n\n  /**\n   * Number of node_modules frames filtered.\n   */\n  nodeModulesFrames: number\n\n  /**\n   * Number of internal frames filtered.\n   */\n  internalFrames: number\n\n  /**\n   * Number of frames shown.\n   */\n  shownFrames: number\n\n  /**\n   * Whether the output was truncated due to maxFrames.\n   */\n  wasTruncated: boolean\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Statistics about stack trace filtering. Provides detailed information about what was filtered during stack cleaning.",
            "examples": [
              {
                "code": "const result = cleanStackWithStats(error.stack)\nconsole.log(`Filtered ${result.stats.filteredFrames} frames`)\nconsole.log(`Showing ${result.stats.shownFrames} of ${result.stats.totalFrames} total`)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 167
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "CleanStackResult",
            "signature": {
              "text": "interface CleanStackResult {\n  /**\n   * The cleaned stack trace string.\n   */\n  stack: string\n\n  /**\n   * Statistics about what was filtered.\n   */\n  stats: StackCleanStats\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Result of cleaning a stack trace. Contains both the cleaned stack string and statistics about what was filtered.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 207
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "cleanStackWithStats",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "stack",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The raw stack trace string to clean"
                    },
                    {
                      "name": "options",
                      "type": "StackOptions | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Optional configuration for filtering and formatting"
                    }
                  ],
                  "returnType": "CleanStackResult",
                  "returnDoc": "Object containing cleaned stack and filtering statistics",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Clean a stack trace by removing internal frames and applying filters. Returns both the cleaned stack and detailed statistics about filtering.",
            "examples": [
              {
                "code": "const error = new Error('Something failed')\nconst result = cleanStackWithStats(error.stack, {\n  removeInternal: true,\n  filterPatterns: ['node_modules'],\n  maxFrames: 10\n})\n\nconsole.log(result.stack) // Cleaned stack trace\nconsole.log(`Filtered ${result.stats.nodeModulesFrames} node_modules frames`)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 242
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "cleanStack",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "stack",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The raw stack trace string to clean"
                    },
                    {
                      "name": "options",
                      "type": "StackOptions | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Optional configuration for filtering"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The cleaned stack trace string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Clean a stack trace by removing internal frames and applying filters.",
            "examples": [],
            "deprecated": "Use cleanStackWithStats for detailed filtering information",
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 318
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "formatFrame",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "frame",
                      "type": "StackFrame",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Format a stack frame for better readability.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 327
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "CleanError",
            "signature": {
              "ctor": {
                "typeParameters": [],
                "parameters": [
                  {
                    "name": "message",
                    "type": "string",
                    "optional": false,
                    "rest": false
                  },
                  {
                    "name": "options",
                    "type": "(ErrorOptions & { context?: object; stackOptions?: StackOptions; }) | undefined",
                    "optional": true,
                    "rest": false
                  }
                ],
                "returnType": "CleanError",
                "throws": []
              },
              "properties": [
                {
                  "name": "originalStack",
                  "type": "string | undefined",
                  "optional": true,
                  "readonly": false,
                  "static": false,
                  "description": "Original uncleaned stack trace."
                },
                {
                  "name": "context",
                  "type": "object | undefined",
                  "optional": true,
                  "readonly": false,
                  "static": false,
                  "description": "Additional context for the error."
                }
              ],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Enhanced Error class that automatically cleans stack traces.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 339
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "mergeStacks",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "wrapper",
                      "type": "Error",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "cause",
                      "type": "Error",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Merge stack traces from multiple errors (useful for wrapped errors). This preserves the full error chain while removing duplicates.",
            "examples": [],
            "category": "Stack Traces",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 375
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "captureStackTrace",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "message",
                      "type": "string",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "'Captured stack'"
                    }
                  ],
                  "returnType": "string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Capture the current stack trace at a specific point. Useful for adding trace information without throwing.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 423
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getCaller",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "depth",
                      "type": "number",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "1"
                    }
                  ],
                  "returnType": "StackFrame | undefined",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get the caller information from the current stack.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "stack",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 432
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryCatch",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "returned"
                    },
                    {
                      "name": "thrown"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "promise",
                      "type": "Promise<returned>",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "predicates",
                      "type": "readonly [TypePredicate<thrown>, ...TypePredicate<thrown>[]] | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Type predicates to filter which errors to catch (defaults to all Error instances)"
                    }
                  ],
                  "returnType": "Promise<returned | (IsUnknown<thrown> extends true ? Error : thrown)>",
                  "returnDoc": "The result if successful, or the caught error",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "returned"
                    },
                    {
                      "name": "thrown"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => returned",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "predicates",
                      "type": "readonly [TypePredicate<thrown>, ...TypePredicate<thrown>[]] | undefined",
                      "optional": true,
                      "rest": false
                    }
                  ],
                  "returnType": "AwaitedUnion<returned, IsUnknown<thrown> extends true ? Error : thrown>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "returned"
                    },
                    {
                      "name": "thrown"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fnOrPromise",
                      "type": "Promise<any> | (() => returned)",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "predicates",
                      "type": "readonly [TypePredicate<thrown>, ...TypePredicate<thrown>[]]",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "[\n    is as Bool.TypePredicate<thrown>,\n  ]"
                    }
                  ],
                  "returnType": "any",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Try to execute a function or resolve a promise, catching errors instead of throwing. Returns either the successful result or the caught error.",
            "examples": [
              {
                "code": "// With function\nconst result = tryCatch(() => JSON.parse(input)) // parsed value | Error\n\n// With promise\nconst data = await tryCatch(fetch(url)) // Response | Error\n\n// With custom predicates\nconst isNetworkError = (e: unknown): e is NetworkError =>\n  e instanceof Error && e.name === 'NetworkError'\n\nconst response = tryCatch(\n  () => fetch(url),\n  [isNetworkError]\n) // Response | NetworkError",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 109
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrRethrow",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Return"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => $Return",
                      "optional": false,
                      "rest": false,
                      "description": "The function to execute"
                    },
                    {
                      "name": "wrapper",
                      "type": "string | WrapOptions | ((cause: Error) => Error)",
                      "optional": false,
                      "rest": false,
                      "description": "Either a string message, options object, or a function that wraps the error"
                    }
                  ],
                  "returnType": "$Return extends Promise<any> ? $Return : $Return",
                  "returnDoc": "The result of the function if successful",
                  "throws": [
                    "The wrapped error if the function throws"
                  ]
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Try to execute a function and wrap any thrown errors with a higher-level message. Handles both synchronous and asynchronous functions automatically.",
            "examples": [
              {
                "code": "// Simple string message\nconst data = await tryOrRethrow(\n  fetchData,\n  'Failed to fetch data'\n)\n\n// With options\nconst user = await tryOrRethrow(\n  () => fetchUser(userId),\n  { message: 'Failed to fetch user', context: { userId } }\n)\n\n// With wrapper function\nconst result = await tryOrRethrow(\n  riskyOperation,\n  wrapWith('Operation failed')\n)\n\n// Custom error wrapper\nconst config = await tryOrRethrow(\n  loadConfig,\n  (cause) => new ConfigError('Failed to load config', { cause })\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {
              "throws": "The wrapped error if the function throws"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 406
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryAllOrRethrow",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Fns",
                      "constraint": "readonly [() => any, ...Array<() => any>]"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fns",
                      "type": "$Fns",
                      "optional": false,
                      "rest": false,
                      "description": "Array of functions to execute"
                    },
                    {
                      "name": "wrapper",
                      "type": "string | WrapOptions | ((cause: Error) => Error)",
                      "optional": false,
                      "rest": false,
                      "description": "Either a string message, options object, or a function that wraps the error"
                    }
                  ],
                  "returnType": "Promise<{ [K in keyof $Fns]: Awaited<ReturnType<$Fns[K]>>; }>",
                  "returnDoc": "Array of results if all succeed",
                  "throws": [
                    "AggregateError with wrapped individual errors if any fail"
                  ]
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Try multiple functions and wrap any errors with a higher-level message. If any function throws, all errors are collected into an AggregateError.",
            "examples": [
              {
                "code": "const [users, posts] = await tryAllOrRethrow(\n  [fetchUsers, fetchPosts],\n  'Failed to load data'\n)\n\n// With context\nconst [config, schema, data] = await tryAllOrRethrow(\n  [loadConfig, loadSchema, loadData],\n  { message: 'Failed to initialize', context: { env: 'production' } }\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {
              "throws": "AggregateError with wrapped individual errors if any fail"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 447
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "TryCatchDefaultPredicateTypes",
            "signature": {
              "text": "type TryCatchDefaultPredicateTypes = Error",
              "_tag": "TypeSignatureModel"
            },
            "description": "Default error types caught by try/catch functions when no predicates are specified.",
            "examples": [],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "tryCatchify",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fn",
                      "constraint": "Fn.AnyAny"
                    },
                    {
                      "name": "thrown"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "fn",
                      "optional": false,
                      "rest": false,
                      "description": "The function to transform"
                    },
                    {
                      "name": "predicates",
                      "type": "readonly [TypePredicate<thrown>, ...TypePredicate<thrown>[]]",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "[is as Bool.TypePredicate<thrown>]",
                      "description": "Type predicates to filter which errors to catch (defaults to all Error instances)"
                    }
                  ],
                  "returnType": "(...args: Parameters<fn>) => AwaitedUnion<ReturnType<fn>, IsUnknown<thrown> extends true ? Error : thrown>",
                  "returnDoc": "A new function that returns results or errors instead of throwing",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Transform a function to return caught errors instead of throwing them. The transformed function will return either the result or the caught error.",
            "examples": [
              {
                "code": "// Transform a throwing function\nconst parseJsonSafe = tryCatchify(JSON.parse)\nconst result = parseJsonSafe('{\"valid\": true}') // { valid: true }\nconst error = parseJsonSafe('invalid') // SyntaxError\n\n// With custom error predicates\nconst isNetworkError = (e: unknown): e is NetworkError =>\n  e instanceof Error && e.name === 'NetworkError'\n\nconst fetchSafe = tryCatchify(fetch, [isNetworkError])\nconst response = await fetchSafe(url) // Response | NetworkError",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 63
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryCatchIgnore",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Return"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => $Return",
                      "optional": false,
                      "rest": false,
                      "description": "The function to execute"
                    }
                  ],
                  "returnType": "$Return",
                  "returnDoc": "The result of the function if successful, undefined otherwise",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Try to execute a function and silently ignore any errors. Returns the result if successful, or undefined if it throws. For async functions, errors are silently caught without rejection.",
            "examples": [
              {
                "code": "// Sync function\ntryCatchIgnore(() => JSON.parse(invalidJson)) // returns undefined\n\n// Async function\nawait tryCatchIgnore(async () => {\n  throw new Error('Network error')\n}) // returns undefined, no rejection",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Catch",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 167
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOr",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "success"
                    },
                    {
                      "name": "fallback"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => success",
                      "optional": false,
                      "rest": false,
                      "description": "The function to execute"
                    },
                    {
                      "name": "fallback",
                      "type": "LazyMaybe<fallback>",
                      "optional": false,
                      "rest": false,
                      "description": "The fallback value or function (must be sync if fn is sync)"
                    }
                  ],
                  "returnType": "TryOrReturn<success, fallback>",
                  "returnDoc": "The result of the function if successful, or the fallback value if it throws",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Try to execute a function and return a fallback value if it throws.  \n\n**Type constraints:** - If `fn` is synchronous, `fallback` must also be synchronous - If `fn` is asynchronous, `fallback` can be either sync or async - For sync functions with async fallbacks, use tryOrAsync instead",
            "examples": [
              {
                "code": "// Sync function with sync fallback\nconst data = tryOr(\n  () => JSON.parse(input),\n  { error: 'Invalid JSON' }\n)\n\n// Async function with sync fallback\nconst config = await tryOr(\n  async () => loadConfig(),\n  () => getDefaultConfig()\n)\n\n// Async function with async fallback\nconst data = await tryOr(\n  async () => fetchFromPrimary(),\n  async () => fetchFromSecondary()\n)\n\n// This would be a TYPE ERROR:\n// const bad = tryOr(\n//   () => 42,                    // sync\n//   async () => 'fallback'       // async - not allowed!\n// )",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 212
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsync",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "success"
                    },
                    {
                      "name": "fallback"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => success",
                      "optional": false,
                      "rest": false,
                      "description": "The function to execute (sync or async)"
                    },
                    {
                      "name": "fallback",
                      "type": "LazyMaybe<fallback>",
                      "optional": false,
                      "rest": false,
                      "description": "The fallback value or function (sync or async)"
                    }
                  ],
                  "returnType": "Promise<Awaited<success> | Awaited<fallback>>",
                  "returnDoc": "Always returns a Promise of the result or fallback",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Try to execute a function and return a fallback value if it throws. Always returns a Promise, allowing async fallbacks for sync functions.  \n\nUse this when: - You have a sync function with an async fallback - You want consistent async behavior regardless of input types",
            "examples": [
              {
                "code": "// Sync function with async fallback\nconst data = await tryOrAsync(\n  () => readFileSync('config.json'),\n  async () => fetchDefaultConfig()\n)\n\n// Ensures consistent Promise return\nconst result = await tryOrAsync(\n  () => 42,\n  () => 'fallback'\n) // Always Promise<number | string>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 248
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsyncOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "success"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => success",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<fallback>(fallback: LazyMaybe<fallback>) => Promise<Awaited<success> | Awaited<fallback>>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of tryOrAsync that takes the function first. Useful for creating reusable async error handlers.",
            "examples": [
              {
                "code": "const parseJsonOrFetch = tryOrAsyncOn(() => JSON.parse(input))\nconst data = await parseJsonOrFetch(async () => fetchDefault())",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 273
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrAsyncWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fallback"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fallback",
                      "type": "LazyMaybe<fallback>",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<success>(fn: () => success) => Promise<Awaited<success> | Awaited<fallback>>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of tryOrAsync that takes the fallback first. Always returns a Promise regardless of input types.",
            "examples": [
              {
                "code": "const orFetchDefault = tryOrAsyncWith(async () => fetchDefault())\nconst data1 = await orFetchDefault(() => localData())\nconst data2 = await orFetchDefault(() => cachedData())",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 292
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "success"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => success",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<fallback>(fallback: LazyMaybe<fallback>) => TryOrReturn<success, fallback>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of tryOr that takes the function first. Useful for creating reusable error handlers.  \n\n**Note:** Same type constraints as tryOr apply - sync functions require sync fallbacks.",
            "examples": [
              {
                "code": "const parseJsonOr = tryOrOn(() => JSON.parse(input))\nconst data = parseJsonOr({ error: 'Invalid JSON' })",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 312
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fallback"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fallback",
                      "type": "LazyMaybe<fallback>",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<success>(fn: () => success) => TryOrReturn<success, fallback>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of tryOr that takes the fallback first. Useful for creating reusable fallback patterns.  \n\n**Note:** Same type constraints as tryOr apply - sync functions require sync fallbacks.",
            "examples": [
              {
                "code": "const orDefault = tryOrWith({ status: 'unknown', data: null })\n\nconst result1 = orDefault(() => fetchStatus())\nconst result2 = orDefault(() => getLatestData())",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 334
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tryOrUndefined",
            "signature": {
              "type": "<success>(fn: () => success) => TryOrReturn<success, undefined>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Try to execute a function and return undefined if it throws. Shorthand for `tryOrWith(undefined)`.",
            "examples": [
              {
                "code": "const data = tryOrUndefined(() => localStorage.getItem('key'))\n// data is string | undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 351
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "tryOrNull",
            "signature": {
              "type": "<success>(fn: () => success) => TryOrReturn<success, null>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Try to execute a function and return null if it throws. Shorthand for `tryOrWith(null)`.",
            "examples": [
              {
                "code": "const user = await tryOrNull(async () => fetchUser(id))\n// user is User | null",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Try-Or",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "try",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 365
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "is",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The value to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value is an Error instance",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type predicate to check if a value is an Error instance.",
            "examples": [
              {
                "code": "is(new Error('test')) // true\nis('not an error') // false\nis(null) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isAggregateError",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a value is an AggregateError instance.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isAbortError",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "error",
                      "type": "any",
                      "optional": false,
                      "rest": false,
                      "description": "The error to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the error is an AbortError",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if an error is an AbortError (from AbortController/AbortSignal).",
            "examples": [
              {
                "code": "const controller = new AbortController()\ncontroller.abort()\n\ntry {\n  await fetch(url, { signal: controller.signal })\n} catch (error) {\n  if (isAbortError(error)) {\n    console.log('Request was aborted')\n  }\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensure",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Error",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Ensure that the given value is an error and return it. If it is not an error than wrap it in one, passing the given value as the error message.",
            "examples": [],
            "category": "Conversion",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Context",
            "signature": {
              "text": "type Context = object",
              "_tag": "TypeSignatureModel"
            },
            "description": "Context information that can be attached to errors. Must be an object to ensure it can be properly serialized and inspected.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "types",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ErrorWithContext",
            "signature": {
              "text": "interface ErrorWithContext extends Error {\n  /**\n   * Additional context information about the error.\n   */\n  context?: Context\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "An error that includes additional context information.",
            "examples": [],
            "deprecated": "Use ContextualError instead for better type safety.",
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "types",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 15
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "WrapOptions",
            "signature": {
              "text": "interface WrapOptions {\n  /**\n   * The error message for the wrapper error.\n   */\n  message: string\n  /**\n   * Additional context to attach to the error.\n   */\n  context?: Context\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Options for wrapping errors with additional context.",
            "examples": [],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "wrap",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "cause",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The error to wrap (will be set as the cause)"
                    },
                    {
                      "name": "messageOrOptions",
                      "type": "string | WrapOptions",
                      "optional": false,
                      "rest": false,
                      "description": "Either a string message or options with message and context"
                    }
                  ],
                  "returnType": "Error",
                  "returnDoc": "A new Error with the given message and the original error as cause",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Wrap an error with a higher-level error message. If the input is not an Error, it will be converted to one using ensure.",
            "examples": [
              {
                "code": "try {\n  await fetchData()\n} catch (error) {\n  throw wrap(error, 'Failed to fetch data')\n}\n\n// With context\ntry {\n  await fetchUser(userId)\n} catch (error) {\n  throw wrap(error, {\n    message: 'Failed to fetch user',\n    context: { userId }\n  })\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 51
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrapOn",
            "signature": {
              "type": "(cause: unknown) => (messageOrOptions: string | WrapOptions) => Error",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of wrap that takes the error first. Useful for error handling pipelines.",
            "examples": [
              {
                "code": "const wrapFetchError = wrapOn(networkError)\nthrow wrapFetchError('Failed to fetch data')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 83
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "wrapWith",
            "signature": {
              "type": "(messageOrOptions: string | WrapOptions) => (cause: unknown) => Error",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of wrap that takes the message/options first. Useful for creating reusable error wrappers.",
            "examples": [
              {
                "code": "const wrapAsFetchError = wrapWith('Failed to fetch data')\n\ntry {\n  await fetchData()\n} catch (error) {\n  throw wrapAsFetchError(error)\n}\n\n// With context\nconst wrapAsUserError = wrapWith({\n  message: 'Failed to process user',\n  context: { operation: 'update' }\n})",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Wrapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "err"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "wrap",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 108
            },
            "_tag": "value",
            "type": "const"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./fn",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "fn"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Function utilities for functional programming patterns.  \n\nProvides utilities for function composition, currying, partial application, piping, and common functional patterns like identity and constant functions. Includes function analysis tools and endomorphism utilities.",
        "category": "Core Data Structures",
        "exports": [
          {
            "name": "Parameter",
            "signature": {
              "text": "type Parameter = { type: 'name'; value: string } | { type: 'destructured'; names: string[] }",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Introspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "analyze",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 6
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "analyzeFunction",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "(...args: any[]) => unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The function to analyze"
                    }
                  ],
                  "returnType": "{ body: string; parameters: Parameter[]; }",
                  "returnDoc": "An object containing the function's cleaned body and parameters",
                  "throws": [
                    "Error If the function cannot be parsed or has invalid structure"
                  ]
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Analyze a function to extract its parameter information and body.  \n\nParses a function's string representation to extract: - Parameter names (both regular and destructured parameters) - Function body (both statement and expression forms, trimmed and dedented)  \n\nThe returned body is already cleaned: leading/trailing whitespace removed and common indentation stripped away for clean display in its isolated form.",
            "examples": [
              {
                "code": "const fn = (a, { b, c }) => a + b + c\nconst info = analyzeFunction(fn)\n// info.parameters: [{ type: 'name', value: 'a' }, { type: 'destructured', names: ['b', 'c'] }]\n// info.body: \"a + b + c\" (already trimmed and dedented)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Introspection",
            "tags": {
              "throws": "Error If the function cannot be parsed or has invalid structure"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "analyze",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isUnary",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "(...args: any[]) => unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The function to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the function has exactly one parameter, false otherwise",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a function is unary (has exactly one parameter).",
            "examples": [
              {
                "code": "const unary = (x: number) => x * 2\nconst binary = (a: number, b: number) => a + b\nconst nullary = () => 42\n\nisUnary(unary)   // true\nisUnary(binary)  // false\nisUnary(nullary) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Introspection",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "analyze",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 110
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "constant",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "() => value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "constant",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AnyAny",
            "signature": {
              "text": "type AnyAny = (...args: any[]) => any",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 8
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParameters2",
            "signature": {
              "text": "type AnyAnyParameters2 = (arg1: any, arg2: any) => any",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin1",
            "signature": {
              "text": "type AnyAnyParametersMin1 = (...args: [any, ...any[]]) => any",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin2",
            "signature": {
              "text": "type AnyAnyParametersMin2 = (...args: [any, any, ...any[]]) => any",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 23
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAnyParametersMin3",
            "signature": {
              "text": "type AnyAnyParametersMin3 = (...args: [any, any, any, ...any[]]) => any",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 28
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "is",
            "signature": {
              "type": "TypeGuard<AnyAny>",
              "_tag": "ValueSignatureModel"
            },
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 33
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "AnyAnyAsync",
            "signature": {
              "text": "type AnyAnyAsync = (...args: any[]) => Prom.AnyAny",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 38
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GuardedType",
            "signature": {
              "text": "type GuardedType<$T> = $T extends (x: any) => x is infer __u__ ? __u__ : never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Extract the guarded type from a type guard function.",
            "examples": [
              {
                "code": "const isString = (x: any): x is string => typeof x === 'string'\ntype T = GuardedType<typeof isString>  // string",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExtract",
            "signature": {
              "text": "type ReturnExtract<$Type, $Fn extends AnyAny> =\n\t$Fn extends (...args: infer __args__) => infer __return__\n\t\t\t? (...args: __args__) =>\n        __return__ extends Prom.AnyAny\n          ? Promise<Extract<Awaited<__return__>, $Type>>\n          : Extract<__return__, $Type>\n\t\t\t: never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Modify function such that it only returns the given type.  \n\nAutomatically handles async functions by unwrapping the Promise, extracting the type, and rewrapping in a Promise. For sync functions, the type is extracted directly.  \n\nAssumes that the given type is among the possible return types of the function.",
            "examples": [
              {
                "code": "// Sync function\ntype Fn1 = (x: number) => string | number\ntype Result1 = ReturnExtract<string, Fn1>  // (x: number) => string\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string | number>\ntype Result2 = ReturnExtract<string, Fn2>  // (x: number) => Promise<string>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 73
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnReplace",
            "signature": {
              "text": "type ReturnReplace<$Fn extends AnyAny, $Type> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => $Type\n    : never",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 85
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExclude",
            "signature": {
              "text": "type ReturnExclude<$Type, $Fn extends AnyAny> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => (\n        __return__ extends Prom.AnyAny\n          ? Promise<Exclude<Awaited<__return__>, $Type>>\n          : Exclude<__return__, $Type>\n    )\n    : never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Modify function such that it does not return the given type.  \n\nAutomatically handles async functions by unwrapping the Promise, excluding the type, and rewrapping in a Promise. For sync functions, the type is excluded directly.  \n\nIf function does not return the given the type, then this is effectively an identity function.",
            "examples": [
              {
                "code": "// Sync function\ntype Fn1 = (x: number) => string | null\ntype Result1 = ReturnExclude<null, Fn1>  // (x: number) => string\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string | null>\ntype Result2 = ReturnExclude<null, Fn2>  // (x: number) => Promise<string>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 111
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnExcludeNull",
            "signature": {
              "text": "type ReturnExcludeNull<$Fn extends AnyAny> = ReturnExclude<null, $Fn>",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 123
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReturnInclude",
            "signature": {
              "text": "type ReturnInclude<$Type, $Fn extends AnyAny> =\n  $Fn extends (...args: infer __args__) => infer __return__\n    ? (...args: __args__) => (\n        __return__ extends Prom.AnyAny\n          ? Promise<$Type | Awaited<__return__>>\n          : $Type | __return__\n    )\n    : never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Modify function such that it can return an additional type along with its original return types.  \n\nAutomatically handles async functions by unwrapping the Promise, adding the type to the union, and rewrapping in a Promise. For sync functions, the type is added directly to the return type union.  \n\nThis is useful for functions that may return early with a specific type (like void).",
            "examples": [
              {
                "code": "// Sync function\ntype Fn1 = (x: number) => string\ntype Result1 = ReturnInclude<null, Fn1>  // (x: number) => string | null\n\n// Async function - automatically unwraps and rewraps Promise\ntype Fn2 = (x: number) => Promise<string>\ntype Result2 = ReturnInclude<null, Fn2>  // (x: number) => Promise<string | null>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 146
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "bind",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fn",
                      "constraint": "AnyAny"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "AnyAnyParametersMin1 extends fn ? fn : { Error: \"Given function must have at least one parameter\"; }",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "arg",
                      "type": "Parameters<fn>[0]",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "bind<fn>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 160
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "noop",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [],
                  "returnType": "void",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 183
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "$identityPartial",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "PartialDeep<value>",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 188
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "applySecond",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fn",
                      "constraint": "(...args: any[]) => (arg: any) => any"
                    },
                    {
                      "name": "arg"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "fn",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "arg",
                      "type": "arg",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "applySecond<fn, arg>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Apply the second parameter of a curried function. For a function (a) = (b) = c and a value b, returns (a) = c Useful for creating service interfaces from curried operations.",
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "base",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 199
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AnyAny2Curried",
            "signature": {
              "text": "type AnyAny2Curried = (arg1: any) => (arg2: any) => any",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "curry",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fn",
                      "constraint": "AnyAny"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "AnyAnyParametersMin1 extends fn ? fn : { Error: \"Given function must have at least one parameter\"; }",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "curry<fn>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 12
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "uncurry",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fn",
                      "constraint": "AnyAny2Curried"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "fn",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "uncurry<fn>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 66
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "flipCurried",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "fn",
                      "constraint": "AnyAny2Curried"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "fn",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "flipCurried<fn>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Currying & Binding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "core"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "curry",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 84
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "endo",
            "signature": {
              "text": "type endo<$T = any> = ($value: $T) => $T",
              "_tag": "TypeSignatureModel"
            },
            "description": "Endomorphism - a function from a type to itself.  \n\nUnlike identity, this doesn't preserve the exact value, just ensures the output type matches the input type.",
            "examples": [
              {
                "code": "// Builder pattern\ntype BuilderOp = Fn.endo<StringBuilder>\nconst addText: BuilderOp = sb => sb.append('text')\n\n// Transformations\ntype StringTransform = Fn.endo<string>\nconst uppercase: StringTransform = s => s.toUpperCase()\nconst trim: StringTransform = s => s.trim()\n\n// Chainable operations\ntype ChainOp = Fn.endo<ChainableAPI>\nconst configure: ChainOp = api => api.setOption('key', 'value')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Endomorphisms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "endo",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 24
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "identity",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "$value",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "$value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "examples": [],
            "category": "Basic Functions",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "identity",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "_",
            "signature": {
              "type": "typeof _",
              "_tag": "ValueSignatureModel"
            },
            "description": "Symbol used to represent a hole in partial application. When used as an argument, indicates that the parameter should be deferred.",
            "examples": [
              {
                "code": "const add = (a: number, b: number) => a + b\nconst addOne = partial(add, _, 1) // (a: number) => number\naddOne(5) // 6",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 15
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isHole",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type guard to check if a value is a hole.",
            "examples": [],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "partial",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Fn",
                      "constraint": "Fn.AnyAny"
                    },
                    {
                      "name": "$Args",
                      "constraint": "readonly unknown[]"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "$Fn",
                      "optional": false,
                      "rest": false,
                      "description": "The function to partially apply"
                    },
                    {
                      "name": "args",
                      "type": "$Args",
                      "optional": true,
                      "rest": true,
                      "description": "Arguments with holes (_) for deferred parameters"
                    }
                  ],
                  "returnType": "any",
                  "returnDoc": "A new function accepting the remaining arguments, or the result if all arguments are provided",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a partially applied function by providing some arguments upfront. Use the hole symbol (_) to defer parameters.",
            "examples": [
              {
                "code": "// Basic usage\nconst add = (a: number, b: number) => a + b\nconst addOne = partial(add, _, 1)\naddOne(5) // 6\n\n// Multiple holes\nconst greet = (greeting: string, name: string, punctuation: string) =>\n  `${greeting}, ${name}${punctuation}`\nconst casualGreet = partial(greet, 'Hey', _, '!')\ncasualGreet('Alice') // 'Hey, Alice!'\n\n// All arguments provided - executes immediately\nconst result = partial(add, 1, 2) // 3",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 55
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "apply",
            "signature": {
              "type": "<$Fn extends Fn.AnyAny, const $Args extends readonly unknown[]>(fn: $Fn, ...args: $Args) => any",
              "_tag": "ValueSignatureModel"
            },
            "description": "Type-safe partial application with automatic type inference. This is an alias for `partial` with a more explicit name.",
            "examples": [
              {
                "code": "const multiply = (a: number, b: number, c: number) => a * b * c\nconst double = apply(multiply, 2, _, 1)\ndouble(5) // 10",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 97
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "defer",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Fn",
                      "constraint": "Fn.AnyAny"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "$Fn",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "args",
                      "type": "Parameters<$Fn>",
                      "optional": true,
                      "rest": true
                    }
                  ],
                  "returnType": "() => ReturnType<$Fn>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Helper to create a deferred computation using partial application. Useful for creating thunks or delayed evaluations.",
            "examples": [
              {
                "code": "const expensiveComputation = (a: number, b: number) => {\n  console.log('Computing...')\n  return a * b\n}\n\nconst deferred = defer(expensiveComputation, 5, 10)\n// Nothing logged yet\n\nconst result = deferred() // Logs: 'Computing...'\n// result: 50",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 118
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isPartialArg",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "_value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a value is potentially a partially applicable argument (either a hole or a regular value).",
            "examples": [],
            "category": "Partial Application",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn",
                    "partial"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "runtime",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 131
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "pipe",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false,
                      "description": "The initial value to pipe through the functions"
                    }
                  ],
                  "returnType": "value",
                  "returnDoc": "The final transformed value",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f1>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f2>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f3>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    },
                    {
                      "name": "f4",
                      "constraint": "(value: ReturnType<f3>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f4",
                      "type": "f4",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f4>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    },
                    {
                      "name": "f4",
                      "constraint": "(value: ReturnType<f3>) => any"
                    },
                    {
                      "name": "f5",
                      "constraint": "(value: ReturnType<f4>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f4",
                      "type": "f4",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f5",
                      "type": "f5",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f5>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    },
                    {
                      "name": "f4",
                      "constraint": "(value: ReturnType<f3>) => any"
                    },
                    {
                      "name": "f5",
                      "constraint": "(value: ReturnType<f4>) => any"
                    },
                    {
                      "name": "f6",
                      "constraint": "(value: ReturnType<f5>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f4",
                      "type": "f4",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f5",
                      "type": "f5",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f6",
                      "type": "f6",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f6>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    },
                    {
                      "name": "f4",
                      "constraint": "(value: ReturnType<f3>) => any"
                    },
                    {
                      "name": "f5",
                      "constraint": "(value: ReturnType<f4>) => any"
                    },
                    {
                      "name": "f6",
                      "constraint": "(value: ReturnType<f5>) => any"
                    },
                    {
                      "name": "f7",
                      "constraint": "(value: ReturnType<f6>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f4",
                      "type": "f4",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f5",
                      "type": "f5",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f6",
                      "type": "f6",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f7",
                      "type": "f7",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f7>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    },
                    {
                      "name": "f4",
                      "constraint": "(value: ReturnType<f3>) => any"
                    },
                    {
                      "name": "f5",
                      "constraint": "(value: ReturnType<f4>) => any"
                    },
                    {
                      "name": "f6",
                      "constraint": "(value: ReturnType<f5>) => any"
                    },
                    {
                      "name": "f7",
                      "constraint": "(value: ReturnType<f6>) => any"
                    },
                    {
                      "name": "f8",
                      "constraint": "(value: ReturnType<f7>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f4",
                      "type": "f4",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f5",
                      "type": "f5",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f6",
                      "type": "f6",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f7",
                      "type": "f7",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f8",
                      "type": "f8",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f8>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    },
                    {
                      "name": "f4",
                      "constraint": "(value: ReturnType<f3>) => any"
                    },
                    {
                      "name": "f5",
                      "constraint": "(value: ReturnType<f4>) => any"
                    },
                    {
                      "name": "f6",
                      "constraint": "(value: ReturnType<f5>) => any"
                    },
                    {
                      "name": "f7",
                      "constraint": "(value: ReturnType<f6>) => any"
                    },
                    {
                      "name": "f8",
                      "constraint": "(value: ReturnType<f7>) => any"
                    },
                    {
                      "name": "f9",
                      "constraint": "(value: ReturnType<f8>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f4",
                      "type": "f4",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f5",
                      "type": "f5",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f6",
                      "type": "f6",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f7",
                      "type": "f7",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f8",
                      "type": "f8",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f9",
                      "type": "f9",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f9>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "f1",
                      "constraint": "(value: value) => any"
                    },
                    {
                      "name": "f2",
                      "constraint": "(value: ReturnType<f1>) => any"
                    },
                    {
                      "name": "f3",
                      "constraint": "(value: ReturnType<f2>) => any"
                    },
                    {
                      "name": "f4",
                      "constraint": "(value: ReturnType<f3>) => any"
                    },
                    {
                      "name": "f5",
                      "constraint": "(value: ReturnType<f4>) => any"
                    },
                    {
                      "name": "f6",
                      "constraint": "(value: ReturnType<f5>) => any"
                    },
                    {
                      "name": "f7",
                      "constraint": "(value: ReturnType<f6>) => any"
                    },
                    {
                      "name": "f8",
                      "constraint": "(value: ReturnType<f7>) => any"
                    },
                    {
                      "name": "f9",
                      "constraint": "(value: ReturnType<f8>) => any"
                    },
                    {
                      "name": "f10",
                      "constraint": "(value: ReturnType<f9>) => any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f1",
                      "type": "f1",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f2",
                      "type": "f2",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f3",
                      "type": "f3",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f4",
                      "type": "f4",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f5",
                      "type": "f5",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f6",
                      "type": "f6",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f7",
                      "type": "f7",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f8",
                      "type": "f8",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f9",
                      "type": "f9",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "f10",
                      "type": "f10",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "ReturnType<f10>",
                  "throws": []
                },
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "any",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "fns",
                      "type": "(value: any) => any)[]",
                      "optional": true,
                      "rest": true
                    }
                  ],
                  "returnType": "any",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Pipe a value through a series of unary functions.",
            "examples": [
              {
                "code": "const add1 = (x: number) => x + 1\nconst double = (x: number) => x * 2\nconst toString = (x: number) => x.toString()\n\npipe(5, add1, double) // 12\npipe(5, add1, double, toString) // \"12\"",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Composition",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "fn"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "pipe",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 26
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./html",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "html"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "HTML utility functions for escaping and working with HTML content.",
        "exports": [
          {
            "name": "escape",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "string",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The string to escape (will be coerced to string if not already)"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The escaped string safe for use in HTML",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Escape HTML special characters to prevent XSS vulnerabilities.  \n\nConverts the following characters to their HTML entity equivalents: - `\"`  `&quot;` - `'`  `&#39;` - `&`  `&amp;` - `<`  `&lt;` - `>`  `&gt;`",
            "examples": [
              {
                "code": "escape('Use Array<T> or Record<K, V>')\n// => 'Use Array&lt;T&gt; or Record&lt;K, V&gt;'\n\nescape('<script>alert(\"xss\")</script>')\n// => '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "html"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "html",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 37
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./json",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "json"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "JSON utilities with Effect Schema integration.  \n\nProvides type-safe JSON operations including type guards, parsing, encoding, and validation using Effect Schema. Supports JSON primitives, objects, and recursive value structures with comprehensive error handling.",
        "category": "Serialization & Network",
        "exports": [
          {
            "name": "Primitive",
            "signature": {
              "text": "type Primitive = string | number | boolean | null",
              "_tag": "TypeSignatureModel"
            },
            "description": "JSON primitive type. Matches: string, number, boolean, or null.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "Obj",
            "signature": {
              "text": "type Obj = { [key in string]?: Value }",
              "_tag": "TypeSignatureModel"
            },
            "description": "JSON object type.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Value",
            "signature": {
              "text": "type Value = Primitive | Obj | Value[]",
              "_tag": "TypeSignatureModel"
            },
            "description": "JSON value type. Matches any valid JSON value: primitives, objects, or arrays (recursively).",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 33
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "Object",
            "signature": {
              "text": "type Obj = { [key in string]?: Value }",
              "_tag": "TypeSignatureModel"
            },
            "description": "JSON object type.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isPrimitive",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type guard to check if a value is a JSON primitive.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 51
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isValue",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type guard to check if a value is a valid JSON value.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isObject",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type guard to check if a value is a JSON object.",
            "examples": [],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 87
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PrimitiveSchema",
            "signature": {
              "type": "Union<[typeof String, typeof Number, typeof Boolean, typeof Null]>",
              "_tag": "ValueSignatureModel"
            },
            "description": "JSON primitive value schema. Matches: string, number, boolean, or null.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 110
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ValueSchema",
            "signature": {
              "type": "Schema<Value, Value, never>",
              "_tag": "ValueSignatureModel"
            },
            "description": "JSON value schema. Matches any valid JSON value: primitives, objects, or arrays (recursively).",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 124
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ObjectSchema",
            "signature": {
              "type": "Record$<typeof String, Schema<Value, Value, never>>",
              "_tag": "ValueSignatureModel"
            },
            "description": "JSON object schema. Matches objects with string keys and JSON values.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 138
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parseJsonSchema",
            "signature": {
              "type": "SchemaClass<unknown, string, never>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Schema for parsing JSON strings to unknown values. Uses Effect's parseJson for better error handling.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 146
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parseJsonAs",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "A"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "schema",
                      "type": "Schema<A, A, never>",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "transform<SchemaClass<unknown, string, never>, Schema<A, A, never>>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Schema for parsing JSON with type validation.",
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 153
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "codec",
            "signature": {
              "type": "Codec<Value>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Codec for JSON values with pretty-printing. Uses Effect's parseJson for decoding.",
            "examples": [],
            "category": "Codec",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 169
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "encode",
            "signature": {
              "type": "Encode<Value>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Encode a JSON value to a pretty-printed string.",
            "examples": [],
            "category": "Codec",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 187
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "decode",
            "signature": {
              "type": "Decode<Value>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Parse a JSON string to a typed value. Uses Effect's parseJson for better error messages.",
            "examples": [],
            "category": "Codec",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 195
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ObjectParser",
            "signature": {
              "type": "{ parse: (value: unknown) => { readonly [x: string]: Value; }; }",
              "_tag": "ValueSignatureModel"
            },
            "examples": [],
            "category": "Schemas",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "json"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "json.effect",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 225
            },
            "_tag": "value",
            "type": "const"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./num",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "num"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Numeric types and utilities with branded types for mathematical constraints.  \n\nProvides branded number types (Positive, Negative, Even, Odd, etc.) with runtime validation, mathematical operations, range types, and specialized numeric domains like Complex, Ratio, and BigInt. Includes type guards, ordering, and equivalence utilities.",
        "category": "Core Data Structures",
        "exports": [
          {
            "name": "Degrees",
            "signature": {
              "text": "export * as Degrees",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "degrees"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "degrees"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Degrees",
                  "signature": {
                    "text": "type Degrees = number & { [DegreesBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Angle in degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 14
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a valid degree angle. Note: Any finite number can represent an angle in degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 20
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Degrees angle. Throws if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 28
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "(number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }) | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Degrees angle. Returns null if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 39
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromRadians",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "radians",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert radians to degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toRadians",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "deg",
                            "type": "Degrees",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert degrees to radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 53
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "normalize",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "deg",
                            "type": "Degrees",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [DegreesBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Normalize degrees to the range [0, 360).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "degrees"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "degrees",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Even",
            "signature": {
              "text": "export * as Even",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "even"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "even"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Even",
                  "signature": {
                    "text": "type Even = number & { [EvenBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Even integer.  \n\nEven integers are whole numbers that are divisible by 2. They include zero and alternate with odd numbers on the number line. Note: This type combines with Int brand for maximum type safety.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 27
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is an even integer",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is even. Returns Even & Int when the value is an even integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 44
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to convert to Even"
                          }
                        ],
                        "returnType": "number & { [EvenBrand]: true; } & { [IntBrand]: true; }",
                        "returnDoc": "The value as an Even & Int",
                        "throws": [
                          "Error if value is not an even integer"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct an Even integer. Throws if the value is not an even integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not an even integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 65
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to try converting"
                          }
                        ],
                        "returnType": "(number & { [EvenBrand]: true; } & { [IntBrand]: true; }) | null",
                        "returnDoc": "The Even & Int or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct an Even integer. Returns null if the value is not an even integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 88
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to get the next even from"
                          }
                        ],
                        "returnType": "number & { [EvenBrand]: true; } & { [IntBrand]: true; }",
                        "returnDoc": "The next even integer",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the next even number (rounds up if odd). For any number, returns the smallest even integer greater than or equal to it.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 106
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to get the previous even from"
                          }
                        ],
                        "returnType": "number & { [EvenBrand]: true; } & { [IntBrand]: true; }",
                        "returnDoc": "The previous even integer",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the previous even number (rounds down if odd). For any number, returns the largest even integer less than or equal to it.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "even"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "even",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 125
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Finite",
            "signature": {
              "text": "export * as Finite",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "finite"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "finite"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Finite",
                  "signature": {
                    "text": "type Finite = number & { [FiniteBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Finite number (excludes NaN, Infinity, -Infinity).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a finite number. Excludes NaN, Infinity, and -Infinity.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 17
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Finite",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Finite number. Throws if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 25
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Finite | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Finite number. Returns null if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "finite"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "finite",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 36
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Float",
            "signature": {
              "text": "export * as Float",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "float"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "float"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Float",
                  "signature": {
                    "text": "type Float = number & { [FloatBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Float (non-integer finite number).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 13
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a float (non-integer number).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [FloatBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Float. Throws if the value is not a float.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 26
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "(number & { [FloatBrand]: true; } & { [FiniteBrand]: true; }) | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Float. Returns null if the value is not a float.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 40
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toFloat",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [FloatBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert an integer to a float by adding a small decimal.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "float"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "float",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "InRange",
            "signature": {
              "text": "export * as InRange",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "in-range"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "in-range"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "InRange",
                  "signature": {
                    "text": "type InRange<Min extends number, Max extends number> = number & {\n  [InRangeBrand]: { min: Min; max: Max }\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Range-constrained number.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "Min",
                            "constraint": "number"
                          },
                          {
                            "name": "Max",
                            "constraint": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "min",
                            "type": "Min",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "max",
                            "type": "Max",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is within a specific range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "Min",
                            "constraint": "number"
                          },
                          {
                            "name": "Max",
                            "constraint": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "min",
                            "type": "Min",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "max",
                            "type": "Max",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "InRange<Min, Max>",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct an InRange number. Throws if the value is outside the range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 30
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "Min",
                            "constraint": "number"
                          },
                          {
                            "name": "Max",
                            "constraint": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "min",
                            "type": "Min",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "max",
                            "type": "Max",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "InRange<Min, Max> | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct an InRange number. Returns null if the value is outside the range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 45
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "Clamp",
                  "signature": {
                    "text": "type Clamp<_T extends number, Min extends number, Max extends number> = InRange<Min, Max>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Type-level clamp transformation. Ensures the result type is within the specified range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 57
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "clamp",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "_T",
                            "constraint": "number"
                          },
                          {
                            "name": "Min",
                            "constraint": "number"
                          },
                          {
                            "name": "Max",
                            "constraint": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "_T",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "min",
                            "type": "Min",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "max",
                            "type": "Max",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Clamp<_T, Min, Max>",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Clamp a number to a range. Forces the value to be within the specified minimum and maximum bounds.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 63
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "clampOn",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "_T",
                            "constraint": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "_T",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "<Min extends number, Max extends number>(min: Min, max: Max) => Clamp<_T, Min, Max>",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 74
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "clampWith",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "Min",
                            "constraint": "number"
                          },
                          {
                            "name": "Max",
                            "constraint": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "min",
                            "type": "Min",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "max",
                            "type": "Max",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "<_T extends number>(value: _T) => Clamp<_T, Min, Max>",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 82
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isOn",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "<Min extends number, Max extends number>(min: Min, max: Max) => boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 90
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isWith",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "Min",
                            "constraint": "number"
                          },
                          {
                            "name": "Max",
                            "constraint": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "min",
                            "type": "Min",
                            "optional": false,
                            "rest": false
                          },
                          {
                            "name": "max",
                            "type": "Max",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "(value: unknown) => value is InRange<Min, Max>",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "in-range"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "in-range",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 98
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Int",
            "signature": {
              "text": "export * as Int",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Int",
                  "signature": {
                    "text": "type Int = number & { [IntBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Integer number.  \n\nIntegers are whole numbers without fractional parts. They can be positive, negative, or zero. In JavaScript, integers are represented as floating-point numbers but are guaranteed to have no decimal part.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 25
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is an integer",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is an integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to convert to Int"
                          }
                        ],
                        "returnType": "Int",
                        "returnDoc": "The value as an Int",
                        "throws": [
                          "Error if value is not an integer"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct an Int. Throws if the value is not an integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not an integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 64
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to try converting"
                          }
                        ],
                        "returnType": "Int | null",
                        "returnDoc": "The Int or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct an Int. Returns null if the value is not an integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 85
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "parse",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string to parse"
                          }
                        ],
                        "returnType": "Int | null",
                        "returnDoc": "The parsed Int or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Parse a string to an Int. Uses parseInt with base 10.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "round",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to round"
                          }
                        ],
                        "returnType": "Int",
                        "returnDoc": "The rounded integer",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Round a number to the nearest integer. Uses standard rounding rules (0.5 rounds up).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 127
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Natural",
            "signature": {
              "text": "export * as Natural",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "natural"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "natural"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Natural",
                  "signature": {
                    "text": "type Natural = number & { [NaturalBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Natural number (positive integer: 1, 2, 3, ...). These are the counting numbers used in everyday life.  \n\nNatural numbers are both integers and positive, so they combine both brands for maximum type safety.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 31
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a natural number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a natural number. Returns true for positive integers (1, 2, 3, ...).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to convert to Natural"
                          }
                        ],
                        "returnType": "number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }",
                        "returnDoc": "The value as a Natural number",
                        "throws": [
                          "Error if value is not a positive integer"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Natural number. Throws if the value is not a positive integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not a positive integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 68
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to try converting"
                          }
                        ],
                        "returnType": "(number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }) | null",
                        "returnDoc": "The Natural number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Natural number. Returns null if the value is not a positive integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 91
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "parseAsNatural",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string to parse"
                          }
                        ],
                        "returnType": "(number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }) | null",
                        "returnDoc": "The parsed natural number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Parse a string as a natural number. Returns null if the string doesn't represent a positive integer. Note: parseInt(\"1.5\") returns 1, but we check if the original string represents an integer by comparing with the parsed result.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 112
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to get the next natural from"
                          }
                        ],
                        "returnType": "number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }",
                        "returnDoc": "The next natural number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the next natural number. For any number, returns the smallest natural number greater than the input.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 135
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to get the previous natural from"
                          }
                        ],
                        "returnType": "(number & { [NaturalBrand]: true; } & { [IntBrand]: true; } & { [PositiveBrand]: true; }) | null",
                        "returnDoc": "The previous natural number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the previous natural number. Returns null if there is no previous natural (i.e., for values = 1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "natural"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "natural",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 154
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Negative",
            "signature": {
              "text": "export * as Negative",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Negative",
                  "signature": {
                    "text": "type Negative = number & { [NegativeBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Negative number ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is negative ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Negative",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Negative number. Throws if the value is not negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Negative | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Negative number. Returns null if the value is not negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "negate",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Negative",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Negate a positive number to make it negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "NonNegative",
            "signature": {
              "text": "export * as NonNegative",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-negative"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "NonNegative",
                  "signature": {
                    "text": "type NonNegative = number & { [NonNegativeBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Non-negative number (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is non-negative (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "NonNegative",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a NonNegative number. Throws if the value is negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "NonNegative | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a NonNegative number. Returns null if the value is negative.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-negative"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-negative",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "NonPositive",
            "signature": {
              "text": "export * as NonPositive",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "NonPositive",
                  "signature": {
                    "text": "type NonPositive = number & { [NonPositiveBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Non-positive number (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is non-positive (= 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "NonPositive",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a NonPositive number. Throws if the value is positive.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "NonPositive | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a NonPositive number. Returns null if the value is positive.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "NonZero",
            "signature": {
              "text": "export * as NonZero",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "non-zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "NonZero",
                  "signature": {
                    "text": "type NonZero = number & { [NonZeroBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Non-zero number ( 0).  \n\nNon-zero numbers are all numbers except zero. They are essential for safe division operations and other mathematical contexts where zero would cause errors or undefined behavior.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 25
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a non-zero number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is non-zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to convert to NonZero"
                          }
                        ],
                        "returnType": "NonZero",
                        "returnDoc": "The value as a NonZero number",
                        "throws": [
                          "Error if value is zero"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a NonZero number. Throws if the value is zero.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 63
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to try converting"
                          }
                        ],
                        "returnType": "NonZero | null",
                        "returnDoc": "The NonZero number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a NonZero number. Returns null if the value is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 83
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDivide",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "dividend",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to divide"
                          },
                          {
                            "name": "divisor",
                            "type": "NonZero",
                            "optional": false,
                            "rest": false,
                            "description": "The NonZero divisor"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The result of the division",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Safely divide a number by a NonZero divisor. This operation is guaranteed to never throw.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 100
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDiv",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "dividend",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to divide"
                          },
                          {
                            "name": "divisor",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The divisor (may be zero)"
                          }
                        ],
                        "returnType": "number | null",
                        "returnDoc": "The result of the division or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to divide two numbers safely. Returns null if the divisor is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 118
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDivOn",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "dividend",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The fixed dividend"
                          }
                        ],
                        "returnType": "(divisor: number) => number | null",
                        "returnDoc": "A function that divides the dividend by its input",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Create a function that safely divides a fixed dividend by any divisor.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 137
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "safeDivWith",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "divisor",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The fixed divisor"
                          }
                        ],
                        "returnType": "(dividend: number) => number | null",
                        "returnDoc": "A function that divides its input by the divisor",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Create a function that safely divides any dividend by a fixed divisor.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "non-zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "non-zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 155
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Odd",
            "signature": {
              "text": "export * as Odd",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "odd"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "odd"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Odd",
                  "signature": {
                    "text": "type Odd = number & { [OddBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Odd integer. Note: This stacks with Int brand to allow Int & Odd.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is odd. Returns Odd & Int when the value is an odd integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 21
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [OddBrand]: true; } & { [IntBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct an Odd integer. Throws if the value is not an odd integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 29
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "(number & { [OddBrand]: true; } & { [IntBrand]: true; }) | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct an Odd integer. Returns null if the value is not an odd integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 43
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [OddBrand]: true; } & { [IntBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the next odd number (rounds up if even).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 50
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [OddBrand]: true; } & { [IntBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the previous odd number (rounds down if even).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "odd"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "odd",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 58
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Percentage",
            "signature": {
              "text": "export * as Percentage",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "percentage"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "percentage"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Percentage",
                  "signature": {
                    "text": "type Percentage = InRange<0, 1> & { [PercentageBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Percentage (0-1). Represents a value between 0% (0.0) and 100% (1.0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 14
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate for percentage (0-1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 19
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Percentage",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Percentage. Throws if the value is not between 0 and 1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 27
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Percentage | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Percentage. Returns null if the value is not between 0 and 1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 38
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromPercent",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Percentage",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert a percentage value (0-100) to a decimal (0-1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 45
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toPercent",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "Percentage",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert a decimal (0-1) to a percentage value (0-100).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 52
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "clamp",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Percentage",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Clamp a value to percentage range (0-1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "percentage"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "percentage",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 59
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Positive",
            "signature": {
              "text": "export * as Positive",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "positive"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Positive",
                  "signature": {
                    "text": "type Positive = number & { [PositiveBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Positive number ( 0).  \n\nPositive numbers are all numbers greater than zero. They represent quantities, counts, and measurements in the real world.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a positive number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is positive ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 40
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to convert to Positive"
                          }
                        ],
                        "returnType": "Positive",
                        "returnDoc": "The value as a Positive number",
                        "throws": [
                          "Error if value is not positive ( 0)"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Positive number. Throws if the value is not positive.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not positive ( 0)"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to try converting"
                          }
                        ],
                        "returnType": "Positive | null",
                        "returnDoc": "The Positive number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Positive number. Returns null if the value is not positive.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "positive"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "positive",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 80
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Radians",
            "signature": {
              "text": "export * as Radians",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "radians"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "radians"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Radians",
                  "signature": {
                    "text": "type Radians = number & { [RadiansBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Angle in radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 14
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a valid radian angle. Note: Any finite number can represent an angle in radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 20
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Radians angle. Throws if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 28
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "(number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }) | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Radians angle. Returns null if the value is not finite.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 39
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromDegrees",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "degrees",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert degrees to radians.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toDegrees",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "rad",
                            "type": "Radians",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert radians to degrees.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 53
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "normalize",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "rad",
                            "type": "Radians",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [RadiansBrand]: true; } & { [FiniteBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Normalize radians to the range [0, 2).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "radians"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "radians",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "SafeInt",
            "signature": {
              "text": "export * as SafeInt",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "safe-int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "safe-int"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "SafeInt",
                  "signature": {
                    "text": "type SafeInt = number & { [SafeIntBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Safe integer (within Number.MAX_SAFE_INTEGER).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 13
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a safe integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a SafeInt. Throws if the value is not a safe integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 26
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "(number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }) | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a SafeInt. Returns null if the value is not a safe integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 37
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "MAX_SAFE_INT",
                  "signature": {
                    "type": "number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "The maximum safe integer constant.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 44
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "MIN_SAFE_INT",
                  "signature": {
                    "type": "number & { [SafeIntBrand]: true; } & { [IntBrand]: true; }",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "The minimum safe integer constant.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "safe-int"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "safe-int",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "name": "Whole",
            "signature": {
              "text": "export * as Whole",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "whole"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "whole"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Whole",
                  "signature": {
                    "text": "type Whole = number & { [WholeBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Whole number (non-negative integer: 0, 1, 2, 3, ...). These are the natural numbers plus zero.  \n\nWhole numbers are both integers and non-negative, so they combine both brands for maximum type safety.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 30
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a whole number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a whole number. Returns true for non-negative integers (0, 1, 2, 3, ...).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to convert to Whole"
                          }
                        ],
                        "returnType": "number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }",
                        "returnDoc": "The value as a Whole number",
                        "throws": [
                          "Error if value is not a non-negative integer"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Whole number. Throws if the value is not a non-negative integer.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not a non-negative integer"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 66
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to try converting"
                          }
                        ],
                        "returnType": "(number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }) | null",
                        "returnDoc": "The Whole number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Whole number. Returns null if the value is not a non-negative integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 89
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "parseAsWhole",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string to parse"
                          }
                        ],
                        "returnType": "(number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }) | null",
                        "returnDoc": "The parsed whole number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Parse a string as a whole number. Returns null if the string doesn't represent a non-negative integer.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to get the next whole from"
                          }
                        ],
                        "returnType": "number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }",
                        "returnDoc": "The next whole number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the next whole number. For any number, returns the smallest whole number greater than the input.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 127
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The number to get the previous whole from"
                          }
                        ],
                        "returnType": "(number & { [WholeBrand]: true; } & { [IntBrand]: true; } & { [NonNegativeBrand]: true; }) | null",
                        "returnDoc": "The previous whole number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the previous whole number. Returns null if there is no previous whole (i.e., for values = 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "whole"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "whole",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 146
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Zero",
            "signature": {
              "text": "export * as Zero",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "zero"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Zero",
                  "signature": {
                    "text": "type Zero = 0 & { [ZeroBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "boolean",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 16
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Zero",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Zero. Throws if the value is not zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 24
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false
                          }
                        ],
                        "returnType": "Zero | null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Zero. Returns null if the value is not zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 35
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "ZERO",
                  "signature": {
                    "type": "Zero",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "The zero constant.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "zero"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "zero",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 42
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "name": "Prime",
            "signature": {
              "text": "export * as Prime",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "prime"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "prime"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Prime",
                  "signature": {
                    "text": "type Prime = Natural & { [PrimeBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Prime number (natural number  1 with no divisors except 1 and itself).  \n\nPrime numbers are fundamental in mathematics and essential for: - Cryptography (RSA keys, Diffie-Hellman) - Hash table sizing (reduces collisions) - Random number generation - Number theory algorithms",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 26
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a prime number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a prime number. Uses trial division optimization up to sqrt(n).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 41
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "The number to convert to Prime"
                          }
                        ],
                        "returnType": "Prime",
                        "returnDoc": "The value as a Prime number",
                        "throws": [
                          "Error if value is not prime"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Prime number. Throws if the value is not prime.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not prime"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 74
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "The number to try converting"
                          }
                        ],
                        "returnType": "Prime | null",
                        "returnDoc": "The Prime number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Prime number. Returns null if the value is not prime.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 96
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "next",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Starting point (exclusive)"
                          }
                        ],
                        "returnType": "Prime",
                        "returnDoc": "The next prime number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Find the next prime number after the given value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 114
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "prev",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Starting point (exclusive)"
                          }
                        ],
                        "returnType": "Prime | null",
                        "returnDoc": "The previous prime number or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Find the previous prime number before the given value. Returns null if no prime exists before the value (i.e., value = 2).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 141
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "nth",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "n",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "Which prime to get (1 = first prime = 2)"
                          }
                        ],
                        "returnType": "Prime",
                        "returnDoc": "The nth prime number",
                        "throws": [
                          "Error if n  1"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the nth prime number (1-indexed). Uses a simple sieve for small n, trial division for larger.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if n  1"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 173
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "factorize",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "The number to factorize (must be = 2)"
                          }
                        ],
                        "returnType": "Map<Prime, Natural>",
                        "returnDoc": "Map of prime factors to exponents",
                        "throws": [
                          "Error if value  2"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Prime factorization of a number. Returns a map of prime factors to their exponents.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value  2"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "prime"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "prime",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 211
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Ratio",
            "signature": {
              "text": "export * as Ratio",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "ratio"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "ratio"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Ratio",
                  "signature": {
                    "text": "type Ratio = {\n  readonly numerator: Int\n  readonly denominator: NonZero\n} & { [RatioBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Ratio (rational number) - a number expressible as p/q where q  0.  \n\nRatios provide exact arithmetic without floating-point errors, making them ideal for: - Financial calculations (no lost pennies) - Music theory (frequency ratios like 3:2 for perfect fifth) - Aspect ratios and proportions - Probability calculations - Any domain requiring exact fractional values",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 30
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a Ratio",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a Ratio.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "numerator",
                            "type": "Int",
                            "optional": false,
                            "rest": false,
                            "description": "The top number"
                          },
                          {
                            "name": "denominator",
                            "type": "NonZero",
                            "optional": false,
                            "rest": false,
                            "description": "The bottom number (non-zero)"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The simplified ratio",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Ratio from numerator and denominator. Automatically simplifies to lowest terms and normalizes sign.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 79
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromWith",
                  "signature": {
                    "type": "(denominator: NonZero) => (numerator: Int) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that constructs ratios with a fixed numerator. Useful for creating unit fractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 110
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromOn",
                  "signature": {
                    "type": "(numerator: Int) => (denominator: NonZero) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that constructs ratios with a fixed denominator. Useful for working with common denominators.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 125
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromDecimal",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The decimal number"
                          },
                          {
                            "name": "maxDenominator",
                            "type": "number",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "10000",
                            "description": "Maximum denominator to use (default: 10000)"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The ratio approximation",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert a decimal number to a Ratio with specified precision. Useful for converting floats to exact ratios.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 145
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "simplify",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "ratio",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "The ratio to simplify"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The simplified ratio",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Simplify a ratio to lowest terms. Note: from() already does this, but this is useful for ratios from other sources.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 202
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toDecimal",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "ratio",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "The ratio to convert"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The decimal representation",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert ratio to decimal number. Note: This may lose precision for ratios like 1/3.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 219
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "add",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "First ratio"
                          },
                          {
                            "name": "b",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "Second ratio"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The sum as a simplified ratio",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 239
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": {
                    "type": "(a: Ratio) => (b: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that adds a specific ratio. Useful for repeated additions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 257
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": {
                    "type": "(b: Ratio) => (a: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that adds to a specific ratio. Useful for accumulating values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 271
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtract",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "First ratio"
                          },
                          {
                            "name": "b",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "Second ratio"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The difference as a simplified ratio",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Subtract two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 286
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subtractWith",
                  "signature": {
                    "type": "(a: Ratio) => (b: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that subtracts from a specific ratio. Useful for calculating remainders.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 304
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtractOn",
                  "signature": {
                    "type": "(a: Ratio) => (b: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that subtracts a specific ratio. Useful for repeated subtractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 318
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "First ratio"
                          },
                          {
                            "name": "b",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "Second ratio"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The product as a simplified ratio",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Multiply two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 337
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": {
                    "type": "(a: Ratio) => (b: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that multiplies by a specific ratio. Useful for scaling.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 355
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": {
                    "type": "(b: Ratio) => (a: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that multiplies a specific ratio. Useful for applying ratios to values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 369
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divide",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "First ratio (dividend)"
                          },
                          {
                            "name": "b",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "Second ratio (divisor, must be non-zero)"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The quotient as a simplified ratio",
                        "throws": [
                          "Error if b is zero"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Divide two ratios. Result is automatically simplified.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if b is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 387
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "divideWith",
                  "signature": {
                    "type": "(a: Ratio) => (b: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that divides from a specific ratio. Useful for finding proportions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 408
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divideOn",
                  "signature": {
                    "type": "(a: Ratio) => (b: Ratio) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that divides by a specific ratio. Useful for repeated divisions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 422
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compare",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "First ratio"
                          },
                          {
                            "name": "b",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "Second ratio"
                          }
                        ],
                        "returnType": "0 | 1 | -1",
                        "returnDoc": "-1, 0, or 1",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Compare two ratios. Returns -1 if a  b, 0 if a = b, 1 if a  b.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 437
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compareOn",
                  "signature": {
                    "type": "(a: Ratio) => (b: Ratio) => 0 | 1 | -1",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that compares against a specific ratio. Useful for filtering or sorting.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 459
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compareWith",
                  "signature": {
                    "type": "(b: Ratio) => (a: Ratio) => 0 | 1 | -1",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that compares a specific ratio. Useful for finding where a ratio fits in a range.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 473
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "reciprocal",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "ratio",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "The ratio to invert"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The reciprocal",
                        "throws": [
                          "Error if ratio is zero"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the reciprocal (inverse) of a ratio.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if ratio is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 487
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toMixedNumber",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "ratio",
                            "type": "Ratio",
                            "optional": false,
                            "rest": false,
                            "description": "The ratio to convert"
                          }
                        ],
                        "returnType": "{ whole: Int; fraction: Ratio; }",
                        "returnDoc": "Object with whole and fractional parts",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert ratio to mixed number representation. Returns whole part and fractional part.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "ratio"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "ratio",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 507
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Frac",
            "signature": {
              "text": "export * as Frac",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "frac"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "frac"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Frac",
                  "signature": {
                    "text": "type Frac = Ratio & { [FracBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Fraction (proper fraction) - a positive ratio where 0  numerator  denominator.  \n\nFractions represent parts of a whole, always between 0 and 1 (exclusive). They're ideal for: - Probabilities (1/6 for dice roll) - Portions and percentages (3/4 of a pizza) - UI measurements (2/3 width) - Musical note durations (1/4 note, 1/8 note)",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 32
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a proper fraction (0  n/d  1)",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a proper fraction.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 48
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "numerator",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "The top number (positive, less than denominator)"
                          },
                          {
                            "name": "denominator",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "The bottom number (positive, greater than numerator)"
                          }
                        ],
                        "returnType": "Frac",
                        "returnDoc": "The fraction",
                        "throws": [
                          "Error if not a proper fraction"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Fraction from numerator and denominator. Both must be positive and numerator must be less than denominator.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if not a proper fraction"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 76
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromWith",
                  "signature": {
                    "type": "(numerator: Natural) => (denominator: Natural) => Frac",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that constructs fractions with a fixed numerator. Useful for creating series of fractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 100
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromOn",
                  "signature": {
                    "type": "(denominator: Natural) => (numerator: Natural) => Frac",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that constructs fractions with a fixed denominator. Useful for working with common denominators.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 115
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "tryFrom",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "numerator",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "The top number"
                          },
                          {
                            "name": "denominator",
                            "type": "Natural",
                            "optional": false,
                            "rest": false,
                            "description": "The bottom number"
                          }
                        ],
                        "returnType": "Frac | null",
                        "returnDoc": "The fraction or null",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Try to construct a Fraction. Returns null if not a proper fraction.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 131
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromDecimal",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The decimal value (0  value  1)"
                          },
                          {
                            "name": "maxDenominator",
                            "type": "number",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "100",
                            "description": "Maximum denominator to use (default: 100)"
                          }
                        ],
                        "returnType": "Frac",
                        "returnDoc": "The fraction approximation",
                        "throws": [
                          "Error if value is not between 0 and 1"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert a decimal to a fraction. The decimal must be between 0 and 1 (exclusive).",
                  "examples": [],
                  "tags": {
                    "throws": "Error if value is not between 0 and 1"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 158
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toDecimal",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "frac",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "The fraction to convert"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The decimal value (between 0 and 1)",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert fraction to decimal.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 183
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toPercentage",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "frac",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "The fraction to convert"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The percentage value (0-100)",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert fraction to percentage.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 199
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "complement",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "frac",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "The fraction"
                          }
                        ],
                        "returnType": "Frac",
                        "returnDoc": "The complement as a fraction",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the complement of a fraction (1 - fraction).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 218
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "add",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "First fraction"
                          },
                          {
                            "name": "b",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "Second fraction"
                          }
                        ],
                        "returnType": "Ratio",
                        "returnDoc": "The sum as a Ratio (might be = 1)",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add two fractions. Note: The result might not be a fraction if the sum = 1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 244
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": {
                    "type": "(a: Frac) => (b: Frac) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that adds to a specific fraction. Data-first pattern: fix the first argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 260
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": {
                    "type": "(b: Frac) => (a: Frac) => Ratio",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that adds with a specific fraction. Data-second pattern: fix the second argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 274
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "First fraction"
                          },
                          {
                            "name": "b",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "Second fraction"
                          }
                        ],
                        "returnType": "Frac",
                        "returnDoc": "The product as a fraction",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Multiply two fractions. The result is always a fraction (product of two numbers  1 is  1).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 294
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": {
                    "type": "(a: Frac) => (b: Frac) => Frac",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that multiplies a specific fraction. Data-first pattern: fix the first argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 311
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": {
                    "type": "(b: Frac) => (a: Frac) => Frac",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that multiplies with a specific fraction. Data-second pattern: fix the second argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 325
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compare",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "First fraction"
                          },
                          {
                            "name": "b",
                            "type": "Frac",
                            "optional": false,
                            "rest": false,
                            "description": "Second fraction"
                          }
                        ],
                        "returnType": "0 | 1 | -1",
                        "returnDoc": "-1 if a  b, 0 if a = b, 1 if a  b",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Compare two fractions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 339
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compareOn",
                  "signature": {
                    "type": "(a: Frac) => (b: Frac) => 0 | 1 | -1",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that compares a specific fraction. Data-first pattern: fix the first argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 355
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compareWith",
                  "signature": {
                    "type": "(b: Frac) => (a: Frac) => 0 | 1 | -1",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that compares with a specific fraction. Data-second pattern: fix the second argument.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "frac"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "frac",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 369
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "name": "Complex",
            "signature": {
              "text": "export * as Complex",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "complex"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "complex"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Complex",
                  "signature": {
                    "text": "type Complex = {\n  readonly real: number\n  readonly imaginary: number\n} & { [ComplexBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Complex number - a number with both real and imaginary parts, written as a + bi.  \n\nThe 'i' represents the imaginary unit, which is the square root of -1. Complex numbers extend regular numbers to solve problems that regular numbers can't, like finding the square root of negative numbers.  \n\nCommon uses: - **Signal processing**: Analyzing sound waves and digital signals - **Electrical engineering**: Calculating power in AC circuits - **Physics**: Describing quantum states and wave behavior - **Computer graphics**: Rotating points and creating fractals - **Control systems**: Analyzing system stability",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 34
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a Complex number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a Complex number.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 52
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "real",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The real part"
                          },
                          {
                            "name": "imaginary",
                            "type": "number",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "0",
                            "description": "The imaginary part (default: 0)"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "The complex number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a Complex number from real and imaginary parts.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 83
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromWith",
                  "signature": {
                    "type": "(real: number) => (imaginary?: number | undefined) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that constructs complex numbers with a fixed real part. Useful for creating pure imaginary numbers or series.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fromOn",
                  "signature": {
                    "type": "(imaginary?: number | undefined) => (real: number) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that constructs complex numbers with a fixed imaginary part. Useful for creating real numbers or series with constant imaginary component.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 122
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "real",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "real",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The real value"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "Complex number with zero imaginary part",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Create a real complex number (imaginary part = 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 135
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "imaginary",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "imaginary",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The imaginary value"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "Complex number with zero real part",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Create a pure imaginary complex number (real part = 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 148
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "I",
                  "signature": {
                    "type": "Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "The imaginary unit i (0 + 1i). Satisfies i = -1.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 158
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "ZERO",
                  "signature": {
                    "type": "Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Zero complex number (0 + 0i).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 163
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "ONE",
                  "signature": {
                    "type": "Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "One complex number (1 + 0i).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 168
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "add",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "First complex number to add"
                          },
                          {
                            "name": "b",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "Second complex number to add"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "A new complex number that is the sum of a and b",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add two complex numbers together.  \n\nWhen adding complex numbers, you add the real parts together and the imaginary parts together. Formula: (a + bi) + (c + di) = (a + c) + (b + d)i",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 193
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": {
                    "type": "(a: Complex) => (b: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that adds its input to a specific complex number.  \n\nThis is the data-first curried version where the input becomes the first parameter. Useful for operations where you want to add various numbers to a fixed base value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 217
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": {
                    "type": "(b: Complex) => (a: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that adds a specific complex number to other complex numbers.  \n\nThis is the data-second curried version where the fixed value is added to various inputs. Useful when you want to add the same complex number to many different values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 242
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtract",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "First complex number (minuend)"
                          },
                          {
                            "name": "b",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "Second complex number (subtrahend)"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "The difference",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Subtract two complex numbers. (a + bi) - (c + di) = (a - c) + (b - d)i",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 256
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subtractWith",
                  "signature": {
                    "type": "(a: Complex) => (b: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that subtracts from a specific complex number.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 270
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtractOn",
                  "signature": {
                    "type": "(a: Complex) => (b: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that subtracts from a specific complex number.  \n\nThis is the data-first curried version where the input becomes the subtrahend. Useful for operations where you want to subtract various numbers from a fixed value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 286
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "First complex number"
                          },
                          {
                            "name": "b",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "Second complex number"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "The product",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Multiply two complex numbers. (a + bi)(c + di) = (ac - bd) + (ad + bc)i",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 306
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": {
                    "type": "(a: Complex) => (b: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that multiplies a specific complex number by others.  \n\nThis is the data-first curried version where the input becomes the second factor. Useful for operations where you want to multiply a fixed base by various values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 332
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": {
                    "type": "(b: Complex) => (a: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that multiplies with a specific complex number.  \n\nThis is the data-second curried version where the fixed multiplier is applied to various inputs. Useful when you want to scale or rotate many complex numbers by the same amount. In 2D graphics, multiplying by a complex number rotates and scales points around the origin.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 359
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divide",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "First complex number (dividend)"
                          },
                          {
                            "name": "b",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "Second complex number (divisor)"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "The quotient",
                        "throws": [
                          "Error if divisor is zero"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Divide two complex numbers. (a + bi) / (c + di) = [(a + bi)(c - di)] / (c + d)",
                  "examples": [],
                  "tags": {
                    "throws": "Error if divisor is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 375
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "divideWith",
                  "signature": {
                    "type": "(a: Complex) => (b: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that divides from a specific complex number.  \n\nThis creates a function where the provided complex number is the dividend (numerator) and the function's input becomes the divisor (denominator).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 408
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divideOn",
                  "signature": {
                    "type": "(a: Complex) => (b: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that divides a specific complex number by others.  \n\nThis is the data-first curried version where the input becomes the divisor. Useful for operations where you want to divide a fixed dividend by various values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 430
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "conjugate",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex number"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "The complex conjugate with imaginary part sign flipped",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the complex conjugate by flipping the sign of the imaginary part.  \n\nThe complex conjugate is useful for: - Converting division into multiplication (z/w = z*w/|w|) - Finding the magnitude squared (z*z = |z|) - Extracting real parts from complex expressions  \n\nIf z = a + bi, then z* = a - bi",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 462
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "abs",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex number"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The magnitude as a non-negative real number",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the absolute value (magnitude/modulus) of a complex number.  \n\nThe magnitude represents the distance from the origin to the point in the complex plane. This is always a non-negative real number, calculated using the Pythagorean theorem.  \n\nFormula: |a + bi| = (a + b)",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 496
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "arg",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex number"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The argument in radians, ranging from - to ",
                        "throws": [
                          "Error if z is zero (argument is undefined for zero)"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the argument (phase/angle) of a complex number in radians.  \n\nThe argument is the angle from the positive real axis to the line connecting the origin to the complex number, measured counterclockwise. This is essential for polar form representation and rotation operations.  \n\nFormula: arg(a + bi) = atan2(b, a)",
                  "examples": [],
                  "tags": {
                    "throws": "Error if z is zero (argument is undefined for zero)"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 534
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toPolar",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex number to convert"
                          }
                        ],
                        "returnType": "{ magnitude: number; angle: number; }",
                        "returnDoc": "Object with magnitude (distance from origin) and angle (in radians)",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert complex number to polar form (magnitude, angle).  \n\nPolar form represents a complex number as r*e^(i) where r is the magnitude and  is the angle. This form is especially useful for multiplication and power operations, as it turns them into simple arithmetic on the components.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 566
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fromPolar",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "magnitude",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The magnitude (r) - distance from origin, must be non-negative"
                          },
                          {
                            "name": "angle",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The angle in radians () - measured counterclockwise from positive real axis"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "Complex number r * e^(i) = r(cos  + i sin )",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Create complex number from polar form (magnitude, angle).  \n\nThis converts from polar coordinates (r, ) to rectangular coordinates (a, bi) using Euler's formula: r*e^(i) = r(cos  + i sin )",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 600
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "power",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex base number"
                          },
                          {
                            "name": "n",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "The real exponent (can be fractional for roots)"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "z raised to the power n",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Raise a complex number to a real power using De Moivre's theorem.  \n\nThis uses the polar form to compute powers efficiently: If z = r*e^(i), then z^n = r^n * e^(in) This avoids the complexity of repeated multiplication for integer powers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 646
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "powerOn",
                  "signature": {
                    "type": "(z: Complex) => (n: number) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that raises a specific complex number to various powers.  \n\nThis is the data-first curried version where the input becomes the exponent. Useful for operations where you want to raise a fixed base to different powers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 684
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "powerWith",
                  "signature": {
                    "type": "(n: number) => (z: Complex) => Complex",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that raises complex numbers to a specific power.  \n\nThis is the data-second curried version where the fixed exponent is applied to various bases. Useful for applying the same power operation to multiple complex numbers, such as when processing arrays or in mathematical transformations.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 719
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "sqrt",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex number to find the square root of"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "The principal square root",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the square root of a complex number.  \n\nReturns the principal (primary) square root using the power function. The principal root is the one with argument in the range (-/2, /2]. Note that every non-zero complex number has exactly two square roots.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 749
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "exp",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex exponent"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "e raised to the complex power z",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Natural exponential function for complex numbers.  \n\nUses Euler's formula: e^(a + bi) = e^a * (cos b + i sin b) This fundamental function connects exponentials with trigonometry and is essential for signal processing, quantum mechanics, and many areas of mathematics.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 785
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "log",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex number (must be non-zero)"
                          }
                        ],
                        "returnType": "Complex",
                        "returnDoc": "The principal natural logarithm",
                        "throws": [
                          "Error if z is zero (logarithm undefined)"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Natural logarithm for complex numbers.  \n\nUses the formula: log(z) = log|z| + i*arg(z) This gives the principal branch of the complex logarithm. Note that complex logarithms are multi-valued; this returns the principal value.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if z is zero (logarithm undefined)"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 823
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "equals",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "First complex number"
                          },
                          {
                            "name": "b",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "Second complex number"
                          },
                          {
                            "name": "tolerance",
                            "type": "number",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "1e-9",
                            "description": "Maximum allowed difference for each component (default: 1e-9)"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if both real and imaginary parts are within tolerance",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Check if two complex numbers are equal within a tolerance.  \n\nDue to floating-point arithmetic limitations, exact equality is rarely achievable for computed complex numbers. This function allows for small differences that arise from numerical precision issues.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 865
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "equalsOn",
                  "signature": {
                    "type": "(a: Complex) => (b: Complex) => (tolerance?: number | undefined) => boolean",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that checks if its input equals a specific complex number.  \n\nThis is the data-first curried version where the reference value is the first parameter. Useful for checking if various numbers equal a fixed reference value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 898
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "equalsWith",
                  "signature": {
                    "type": "(b: Complex) => (a: Complex) => (tolerance?: number | undefined) => boolean",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that checks equality with a specific complex number.  \n\nThis is the data-second curried version where the comparison value is fixed. Useful for filtering, validation, or when you need to check many numbers against the same reference value.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 932
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "toString",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "z",
                            "type": "Complex",
                            "optional": false,
                            "rest": false,
                            "description": "The complex number to convert"
                          },
                          {
                            "name": "precision",
                            "type": "number",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "6",
                            "description": "Number of decimal places to display (default: 6)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "String representation in mathematical notation",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert complex number to string representation.  \n\nCreates a human-readable string in standard mathematical notation (a + bi). Handles special cases like pure real numbers, pure imaginary numbers, and the imaginary unit to provide clean, readable output.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "complex"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "complex",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 973
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "BigInteger",
            "signature": {
              "text": "export * as BigInteger",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "big-integer"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "big-integer"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "BigInteger",
                  "signature": {
                    "text": "type BigInteger = bigint & { [BigIntegerBrand]: true }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "BigInteger - arbitrary precision integer with branded type safety.  \n\nProvides exact arithmetic for integers of any size, without the limitations of JavaScript's Number type (which loses precision beyond 2^53-1).  \n\nCommon uses: - **Cryptography**: Large prime numbers, key generation, modular arithmetic - **Financial systems**: Precise monetary calculations without rounding errors - **Mathematical computing**: Factorials, combinatorics, number theory - **Blockchain**: Transaction values, block numbers, hash computations - **Scientific computing**: Large dataset indexing, ID generation",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 34
                  },
                  "_tag": "type",
                  "type": "intersection"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "The value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a BigInteger",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type predicate to check if value is a BigInteger.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 48
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "from",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "string | number | bigint",
                            "optional": false,
                            "rest": false,
                            "description": "The value to convert (number, string, or bigint)"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "The BigInteger representation",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Construct a BigInteger from various input types.  \n\nAccepts numbers, strings, and existing bigints, providing a safe way to create arbitrary precision integers from different sources.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 73
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "ZERO",
                  "signature": {
                    "type": "BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "BigInteger constants for common values.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 84
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "ONE",
                  "signature": {
                    "type": "BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 85
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "TWO",
                  "signature": {
                    "type": "BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 86
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "add",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "First BigInteger to add"
                          },
                          {
                            "name": "b",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "Second BigInteger to add"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "The exact sum as a BigInteger",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add two BigIntegers together.  \n\nPerforms exact addition without precision loss, regardless of the size of the numbers involved.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 108
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "addOn",
                  "signature": {
                    "type": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that operates on a specific BigInteger by adding to it. Data-first pattern: the fixed value is the first parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 129
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "addWith",
                  "signature": {
                    "type": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that adds with a specific BigInteger value. Data-second pattern: the fixed value is the second parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 147
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtract",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "First BigInteger (minuend)"
                          },
                          {
                            "name": "b",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "Second BigInteger (subtrahend)"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "The exact difference as a BigInteger",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Subtract two BigIntegers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 161
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "subtractWith",
                  "signature": {
                    "type": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that subtracts with a specific BigInteger. Data-second pattern: the fixed value is the second parameter (subtrahend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 177
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "subtractOn",
                  "signature": {
                    "type": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that operates on a specific BigInteger by subtracting from it. Data-first pattern: the fixed value is the first parameter (minuend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 191
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiply",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "First BigInteger"
                          },
                          {
                            "name": "b",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "Second BigInteger"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "The exact product as a BigInteger",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Multiply two BigIntegers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 210
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "multiplyOn",
                  "signature": {
                    "type": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that operates on a specific BigInteger by multiplying it. Data-first pattern: the fixed value is the first parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 227
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplyWith",
                  "signature": {
                    "type": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that multiplies with a specific BigInteger. Data-second pattern: the fixed value is the second parameter (multiplier).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 244
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divide",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "First BigInteger (dividend)"
                          },
                          {
                            "name": "b",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "Second BigInteger (divisor, must be non-zero)"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "The quotient as a BigInteger (truncated)",
                        "throws": [
                          "Error if divisor is zero"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Divide two BigIntegers using integer division (truncates toward zero).",
                  "examples": [],
                  "tags": {
                    "throws": "Error if divisor is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 262
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "divideOn",
                  "signature": {
                    "type": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that operates on a specific BigInteger by dividing it. Data-first pattern: the fixed value is the first parameter (dividend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 281
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "divideWith",
                  "signature": {
                    "type": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that divides by a specific BigInteger. Data-second pattern: the fixed value is the second parameter (divisor).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 298
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "remainder",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "First BigInteger (dividend)"
                          },
                          {
                            "name": "b",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "Second BigInteger (divisor, must be non-zero)"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "The remainder as a BigInteger",
                        "throws": [
                          "Error if divisor is zero"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the remainder of BigInteger division.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if divisor is zero"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 315
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "remainderOn",
                  "signature": {
                    "type": "(a: BigInteger) => (b: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that operates on a specific BigInteger to get its remainder. Data-first pattern: the fixed value is the first parameter (dividend).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 335
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "remainderWith",
                  "signature": {
                    "type": "(b: BigInteger) => (a: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that gets remainder with a specific divisor. Data-second pattern: the fixed value is the second parameter (divisor).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 351
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "power",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "base",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger base"
                          },
                          {
                            "name": "exponent",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger exponent (must be non-negative)"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "base raised to the power of exponent",
                        "throws": [
                          "Error if exponent is negative"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Raise a BigInteger to a power.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if exponent is negative"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 368
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "powerOn",
                  "signature": {
                    "type": "(base: BigInteger) => (exponent: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that operates on a specific BigInteger base by raising it to powers. Data-first pattern: the fixed value is the first parameter (base).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 388
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "powerWith",
                  "signature": {
                    "type": "(exponent: BigInteger) => (base: BigInteger) => BigInteger",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that raises to a specific power. Data-second pattern: the fixed value is the second parameter (exponent).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 406
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "abs",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger"
                          }
                        ],
                        "returnType": "BigInteger",
                        "returnDoc": "The absolute value as a BigInteger",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the absolute value of a BigInteger.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 419
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compare",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "a",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "First BigInteger"
                          },
                          {
                            "name": "b",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "Second BigInteger"
                          }
                        ],
                        "returnType": "0 | 1 | -1",
                        "returnDoc": "-1 if a  b, 0 if a = b, 1 if a  b",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Compare two BigIntegers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 437
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "compareOn",
                  "signature": {
                    "type": "(a: BigInteger) => (b: BigInteger) => 0 | 1 | -1",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that operates on a specific BigInteger by comparing it. Data-first pattern: the fixed value is the first parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 456
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "compareWith",
                  "signature": {
                    "type": "(b: BigInteger) => (a: BigInteger) => 0 | 1 | -1",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Create a function that compares with a specific BigInteger. Data-second pattern: the fixed value is the second parameter.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 474
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "isEven",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if the BigInteger is even",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Check if a BigInteger is even.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 487
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isOdd",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if the BigInteger is odd",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Check if a BigInteger is odd.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 502
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isPositive",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if the BigInteger is positive",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Check if a BigInteger is positive ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 517
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isNegative",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if the BigInteger is negative",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Check if a BigInteger is negative ( 0).",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 532
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "isZero",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if the BigInteger is zero",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Check if a BigInteger is zero.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 546
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toNumber",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger to convert"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The number representation",
                        "throws": [
                          "Error if the BigInteger is too large for safe conversion"
                        ]
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert BigInteger to regular number.  \n\nWARNING: May lose precision if the BigInteger is larger than Number.MAX_SAFE_INTEGER.",
                  "examples": [],
                  "tags": {
                    "throws": "Error if the BigInteger is too large for safe conversion"
                  },
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 564
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "toString",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "BigInteger",
                            "optional": false,
                            "rest": false,
                            "description": "The BigInteger to convert"
                          },
                          {
                            "name": "radix",
                            "type": "number",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "10",
                            "description": "The base to use (default: 10)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "String representation",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert BigInteger to string representation.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "num",
                          "big-integer"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "big-integer",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 588
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Arb",
            "signature": {
              "type": "Arb<number>",
              "_tag": "ValueSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arb",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 34
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Eq",
            "signature": {
              "type": "Eq<number>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Eq trait implementation for numbers.  \n\nProvides number equality comparison using strict equality (===). Handles special cases like NaN, which is never equal to itself.",
            "examples": [
              {
                "code": "import { Num } from '@wollybeard/kit'\n\nNum.Eq.is(42, 42)           // true\nNum.Eq.is(3.14, 3.14)       // true\nNum.Eq.is(0, -0)            // true (positive and negative zero are equal)\nNum.Eq.is(NaN, NaN)         // false (NaN is never equal to itself)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 21
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": {
              "type": "Type<number>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Type trait implementation for numbers.  \n\nProvides type checking for number values using typeof.",
            "examples": [
              {
                "code": "import { Num } from '@wollybeard/kit'\n\nNum.Type.is(42)            // true\nNum.Type.is(3.14)          // true\nNum.Type.is(NaN)           // true (NaN is a number)\nNum.Type.is('42')          // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "add",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "a",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The first number to add"
                    },
                    {
                      "name": "b",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The second number to add"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The sum of a and b",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Add two numbers together.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "addWith",
            "signature": {
              "type": "(a: number) => (b: number) => number",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that adds a specific number to any other number. This is useful when you want to add the same number multiple times.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 48
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "subtract",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "a",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number to subtract from (minuend)"
                    },
                    {
                      "name": "b",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number to subtract (subtrahend)"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The difference between a and b",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Subtract one number from another. Takes the second number away from the first number.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "subtractWith",
            "signature": {
              "type": "(a: number) => (b: number) => number",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that subtracts other numbers from a specific number. This is useful when you have a starting value and want to subtract various amounts from it.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 88
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "multiply",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "a",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The first number (multiplicand)"
                    },
                    {
                      "name": "b",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The second number (multiplier)"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The product of a and b",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Multiply two numbers together. This gives you the result of adding a number to itself b times.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 106
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "multiplyWith",
            "signature": {
              "type": "(b: number) => (a: number) => number",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that multiplies any number by a specific factor. This is useful for scaling values or converting units.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 132
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "divide",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "dividend",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number to be divided (what you're splitting up)"
                    },
                    {
                      "name": "divisor",
                      "type": "NonZero",
                      "optional": false,
                      "rest": false,
                      "description": "The non-zero number to divide by (how many parts to split into)"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The quotient (result of division)",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Divide one number by another. This splits the first number into equal parts based on the second number. The divisor must be non-zero.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 151
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "divideWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "divisor",
                      "type": "NonZero",
                      "optional": false,
                      "rest": false,
                      "description": "The non-zero number to divide by"
                    }
                  ],
                  "returnType": "(dividend: number) => number",
                  "returnDoc": "A function that divides its input by the divisor",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that divides any number by a specific divisor. This is useful for splitting values into fixed portions.",
            "examples": [],
            "category": "Arithmetic",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 177
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "power",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "base",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number to be multiplied by itself"
                    },
                    {
                      "name": "exponent",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "How many times to multiply the base by itself"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The result of base raised to the exponent power",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Raise a number to a power (exponentiation). This multiplies the base number by itself 'exponent' times. For best results, use finite numbers to avoid NaN/Infinity.",
            "examples": [],
            "category": "Exponentiation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 204
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "powerWith",
            "signature": {
              "type": "(exponent: number) => (base: number) => number",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that raises any number to a specific power. This is useful for repeated exponentiations.",
            "examples": [],
            "category": "Exponentiation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 230
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "round",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number to round"
                    },
                    {
                      "name": "precision",
                      "type": "number",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "0",
                      "description": "Number of decimal places to keep (default: 0 for whole numbers)"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The rounded number",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Round a number to the nearest integer or to a specific number of decimal places. Rounding follows standard rules: 0.5 and above rounds up, below 0.5 rounds down.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 258
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "roundWith",
            "signature": {
              "type": "(precision?: number | undefined) => (value: number) => number",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that rounds numbers to a specific number of decimal places. This is useful when you need consistent precision across multiple values.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 286
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Floor",
            "signature": {
              "text": "type Floor<_T extends number> = Int",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level floor transformation. Floor always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 292
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "floor",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "Finite"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The finite number to round down"
                    }
                  ],
                  "returnType": "Int",
                  "returnDoc": "The largest integer less than or equal to the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Round a number down to the nearest integer. This always rounds towards negative infinity, removing any decimal part. The input must be finite to ensure a valid integer result.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 319
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Ceil",
            "signature": {
              "text": "type Ceil<_T extends number> = Int",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level ceil transformation. Ceil always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 327
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ceil",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "Finite"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The finite number to round up"
                    }
                  ],
                  "returnType": "Int",
                  "returnDoc": "The smallest integer greater than or equal to the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Round a number up to the nearest integer. This always rounds towards positive infinity. The input must be finite to ensure a valid integer result.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 355
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Trunc",
            "signature": {
              "text": "type Trunc<_T extends number> = Int",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level trunc transformation. Trunc always returns an integer.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 363
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "trunc",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "Finite"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The finite number to truncate"
                    }
                  ],
                  "returnType": "Int",
                  "returnDoc": "The integer part of the number",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Remove the decimal part of a number (truncate). This simply cuts off the decimal portion, always rounding towards zero. The input must be finite to ensure a valid integer result.",
            "examples": [],
            "category": "Rounding",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 390
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sqrt",
            "signature": {
              "text": "type Sqrt<T extends number> = T extends Positive ? Positive\n  : T extends NonNegative ? NonNegative\n  : number",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level sqrt transformation. Square root of non-negative returns non-negative. Square root of positive returns positive (except for 0).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 399
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sqrt",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "NonNegative"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The non-negative number to find the square root of"
                    }
                  ],
                  "returnType": "Sqrt<T>",
                  "returnDoc": "The square root of the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the square root of a non-negative number. The square root is a number that, when multiplied by itself, gives the original number. For type safety, this requires a non-negative input to avoid NaN results.",
            "examples": [],
            "category": "Roots",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 429
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "cbrt",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number to find the cube root of"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The cube root of the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the cube root of a number. The cube root is a number that, when multiplied by itself three times, gives the original number.",
            "examples": [],
            "category": "Roots",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 451
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "Positive",
                      "optional": false,
                      "rest": false,
                      "description": "The positive number to find the natural logarithm of"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The natural logarithm of the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the natural logarithm (base e) of a number. The logarithm tells you what power you need to raise e (2.718) to get your number. It's the inverse operation of exponential (e^x).",
            "examples": [],
            "category": "Logarithms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 475
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log10",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "Positive",
                      "optional": false,
                      "rest": false,
                      "description": "The positive number to find the base-10 logarithm of"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The base-10 logarithm of the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the base-10 logarithm of a number. This tells you what power you need to raise 10 to get your number. It's commonly used for measuring orders of magnitude.",
            "examples": [],
            "category": "Logarithms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 502
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "log2",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "Positive",
                      "optional": false,
                      "rest": false,
                      "description": "The positive number to find the base-2 logarithm of"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The base-2 logarithm of the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the base-2 logarithm of a number. This tells you what power you need to raise 2 to get your number. It's commonly used in computer science for binary operations.",
            "examples": [],
            "category": "Logarithms",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 530
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sin",
            "signature": {
              "text": "type Sin<_T extends number> = InRange<-1, 1>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level sine transformation. Sine always returns a value in the range [-1, 1].",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 538
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sin",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "Finite"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "radians",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The angle in radians (must be finite)"
                    }
                  ],
                  "returnType": "Sin<_T>",
                  "returnDoc": "The sine of the angle, always between -1 and 1",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the sine of an angle. Sine is a trigonometric function that represents the ratio of the opposite side to the hypotenuse in a right triangle. The angle must be in radians and finite.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 565
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Cos",
            "signature": {
              "text": "type Cos<_T extends number> = InRange<-1, 1>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level cosine transformation. Cosine always returns a value in the range [-1, 1].",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 573
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "cos",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "Finite"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "radians",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The angle in radians (must be finite)"
                    }
                  ],
                  "returnType": "Cos<_T>",
                  "returnDoc": "The cosine of the angle, always between -1 and 1",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the cosine of an angle. Cosine is a trigonometric function that represents the ratio of the adjacent side to the hypotenuse in a right triangle. The angle must be in radians and finite.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 600
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "tan",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "radians",
                      "type": "Finite",
                      "optional": false,
                      "rest": false,
                      "description": "The angle in radians (must be finite)"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The tangent of the angle",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the tangent of an angle. Tangent is the ratio of sine to cosine, or the ratio of the opposite side to the adjacent side in a right triangle. The angle must be in radians and finite.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 628
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "asin",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "InRange<-1, 1>",
                      "optional": false,
                      "rest": false,
                      "description": "A number between -1 and 1 (inclusive)"
                    }
                  ],
                  "returnType": "Radians",
                  "returnDoc": "The angle in radians, between -PI/2 and PI/2",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the arcsine (inverse sine) of a value. This gives you the angle whose sine is the input value. The input must be in the range [-1, 1] to get a valid result. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 658
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "acos",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "InRange<-1, 1>",
                      "optional": false,
                      "rest": false,
                      "description": "A number between -1 and 1 (inclusive)"
                    }
                  ],
                  "returnType": "Radians",
                  "returnDoc": "The angle in radians, between 0 and PI",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the arccosine (inverse cosine) of a value. This gives you the angle whose cosine is the input value. The input must be in the range [-1, 1] to get a valid result. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 689
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "Finite",
                      "optional": false,
                      "rest": false,
                      "description": "Any finite number (the tangent of the angle)"
                    }
                  ],
                  "returnType": "Radians",
                  "returnDoc": "The angle in radians, between -PI/2 and PI/2",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the arctangent (inverse tangent) of a value. This gives you the angle whose tangent is the input value. The input must be finite to get a meaningful angle. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 718
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan2",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "y",
                      "type": "Finite",
                      "optional": false,
                      "rest": false,
                      "description": "The y-coordinate of the point (must be finite)"
                    },
                    {
                      "name": "x",
                      "type": "Finite",
                      "optional": false,
                      "rest": false,
                      "description": "The x-coordinate of the point (must be finite)"
                    }
                  ],
                  "returnType": "Radians",
                  "returnDoc": "The angle in radians, between -PI and PI",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Calculate the angle from the positive x-axis to a point (x, y). This is like atan(y/x) but handles all quadrants correctly and avoids division by zero. Both coordinates must be finite to get a meaningful angle. The result is in radians.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 749
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "atan2With",
            "signature": {
              "type": "(y: Finite) => (x: Finite) => Radians",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that calculates atan2 with a fixed y value. Useful for repeated calculations with the same y offset.",
            "examples": [],
            "category": "Trigonometry",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 762
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "degToRad",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "degrees",
                      "type": "Degrees",
                      "optional": false,
                      "rest": false,
                      "description": "The angle in degrees"
                    }
                  ],
                  "returnType": "Radians",
                  "returnDoc": "The angle in radians",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Convert degrees to radians. Most JavaScript math functions expect angles in radians, but humans often think in degrees. This converts from the familiar degree system (0-360) to radians (0-2).",
            "examples": [],
            "category": "Angle Conversion",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 790
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "radToDeg",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "radians",
                      "type": "Radians",
                      "optional": false,
                      "rest": false,
                      "description": "The angle in radians"
                    }
                  ],
                  "returnType": "Degrees",
                  "returnDoc": "The angle in degrees",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Convert radians to degrees. Math functions return angles in radians, but you might want to display them in degrees. This converts from radians (0-2) to the familiar degree system (0-360).",
            "examples": [],
            "category": "Angle Conversion",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 820
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Min",
            "signature": {
              "text": "type Min<A extends number, B extends number> = A | B",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level min transformation. Returns the union of both input types (the more general type).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 828
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "min",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "A",
                      "constraint": "number"
                    },
                    {
                      "name": "B",
                      "constraint": "number"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "a",
                      "type": "A",
                      "optional": false,
                      "rest": false,
                      "description": "The first number to compare"
                    },
                    {
                      "name": "b",
                      "type": "B",
                      "optional": false,
                      "rest": false,
                      "description": "The second number to compare"
                    }
                  ],
                  "returnType": "Min<A, B>",
                  "returnDoc": "The smaller of the two numbers",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Find the smaller of two numbers. Returns whichever number is less.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 853
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "minWith",
            "signature": {
              "type": "(a: number) => (b: number) => number",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that finds the minimum with a fixed first value. Useful for clamping or limiting values.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 866
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Max",
            "signature": {
              "text": "type Max<A extends number, B extends number> = A | B",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level max transformation. Returns the union of both input types (the more general type).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 872
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "max",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "A",
                      "constraint": "number"
                    },
                    {
                      "name": "B",
                      "constraint": "number"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "a",
                      "type": "A",
                      "optional": false,
                      "rest": false,
                      "description": "The first number to compare"
                    },
                    {
                      "name": "b",
                      "type": "B",
                      "optional": false,
                      "rest": false,
                      "description": "The second number to compare"
                    }
                  ],
                  "returnType": "Max<A, B>",
                  "returnDoc": "The larger of the two numbers",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Find the larger of two numbers. Returns whichever number is greater.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 897
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "maxWith",
            "signature": {
              "type": "(a: number) => (b: number) => number",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that finds the maximum with a fixed first value. Useful for ensuring minimum values.",
            "examples": [],
            "category": "Comparison",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 910
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "gcd",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "a",
                      "type": "Int",
                      "optional": false,
                      "rest": false,
                      "description": "The first integer"
                    },
                    {
                      "name": "b",
                      "type": "Int",
                      "optional": false,
                      "rest": false,
                      "description": "The second integer"
                    }
                  ],
                  "returnType": "Natural",
                  "returnDoc": "The greatest common divisor as a positive integer",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Find the greatest common divisor (GCD) of two integers. The GCD is the largest positive integer that divides both numbers evenly. Also known as the greatest common factor (GCF).",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 941
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "gcdWith",
            "signature": {
              "type": "(a: Int) => (b: Int) => Natural",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that finds the GCD with a fixed first value. Useful for finding common factors with a specific number.",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 971
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "lcm",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "a",
                      "type": "Int",
                      "optional": false,
                      "rest": false,
                      "description": "The first integer"
                    },
                    {
                      "name": "b",
                      "type": "Int",
                      "optional": false,
                      "rest": false,
                      "description": "The second integer"
                    }
                  ],
                  "returnType": "Whole",
                  "returnDoc": "The least common multiple as a non-negative integer",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Find the least common multiple (LCM) of two integers. The LCM is the smallest positive integer that is divisible by both numbers. Returns 0 if either input is 0.",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1002
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lcmWith",
            "signature": {
              "type": "(a: Int) => (b: Int) => Whole",
              "_tag": "ValueSignatureModel"
            },
            "description": "Create a function that finds the LCM with a fixed first value. Useful for finding common multiples with a specific number.",
            "examples": [],
            "category": "Number Theory",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1020
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "PI",
            "signature": {
              "type": "number",
              "_tag": "ValueSignatureModel"
            },
            "description": "The mathematical constant pi (). Pi is the ratio of a circle's circumference to its diameter. Approximately 3.14159...",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1039
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "E",
            "signature": {
              "type": "number",
              "_tag": "ValueSignatureModel"
            },
            "description": "The mathematical constant e (Euler's number). The base of natural logarithms, approximately 2.71828... It appears naturally in exponential growth and compound interest.",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1059
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "TAU",
            "signature": {
              "type": "number",
              "_tag": "ValueSignatureModel"
            },
            "description": "The mathematical constant tau (). Tau is 2, representing a full circle in radians. Some mathematicians prefer tau over pi for circular calculations. Approximately 6.28318...",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1081
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "GOLDEN_RATIO",
            "signature": {
              "type": "number",
              "_tag": "ValueSignatureModel"
            },
            "description": "The golden ratio (, phi). A special number appearing in nature, art, and architecture. When a line is divided so that the whole length divided by the long part equals the long part divided by the short part. Approximately 1.61803...",
            "examples": [],
            "category": "Constants",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "math",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1105
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "is",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type predicate to check if value is a number. Excludes NaN by default.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 16
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isNaN",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "boolean",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type predicate to check if value is NaN.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 23
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Abs",
            "signature": {
              "text": "type Abs<T extends number> = T extends Positive ? Positive\n  : T extends Negative ? Positive\n  : T extends NonPositive ? NonNegative\n  : T extends Zero ? Zero\n  : NonNegative",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level absolute value transformation. Maps number types to their absolute value types.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "abs",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "number"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The number to get absolute value of"
                    }
                  ],
                  "returnType": "Abs<T>",
                  "returnDoc": "The absolute value with appropriate branded type",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get absolute value. Returns the non-negative magnitude of a number.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Sign",
            "signature": {
              "text": "type Sign<T extends number> = T extends Positive ? 1\n  : T extends Negative ? -1\n  : T extends Zero ? 0\n  : -1 | 0 | 1",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level sign transformation. Maps number types to their sign (-1, 0, 1).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 58
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "sign",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "number"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The number to get the sign of"
                    }
                  ],
                  "returnType": "Sign<T>",
                  "returnDoc": "-1, 0, or 1 with precise type",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get sign of number (-1, 0, 1). Returns -1 for negative numbers, 0 for zero, and 1 for positive numbers.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 78
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "inc",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "number",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "number",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Increment by 1.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 85
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "dec",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "number",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "number",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Decrement by 1.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 92
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Mod",
            "signature": {
              "text": "type Mod<_T extends number, _U extends NonZero> = NonNegative",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level modulo transformation. Modulo always returns a non-negative result.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 100
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mod",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "number"
                    },
                    {
                      "name": "U",
                      "constraint": "NonZero"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "dividend",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The number to divide"
                    },
                    {
                      "name": "divisor",
                      "type": "U",
                      "optional": false,
                      "rest": false,
                      "description": "The non-zero number to divide by"
                    }
                  ],
                  "returnType": "NonNegative",
                  "returnDoc": "The positive remainder",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Modulo operation that always returns positive result. Unlike the % operator, this always returns a non-negative result. The divisor must be non-zero for a valid result.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 123
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "modOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "number"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "dividend",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The fixed dividend"
                    }
                  ],
                  "returnType": "<U extends NonZero>(divisor: U) => NonNegative",
                  "returnDoc": "A function that takes a divisor and returns the modulo",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that calculates modulo with a fixed dividend.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 141
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "modWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "U",
                      "constraint": "NonZero"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "divisor",
                      "type": "U",
                      "optional": false,
                      "rest": false,
                      "description": "The fixed non-zero divisor"
                    }
                  ],
                  "returnType": "<T extends number>(dividend: T) => NonNegative",
                  "returnDoc": "A function that takes a dividend and returns the modulo",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that calculates modulo with a fixed divisor. Useful for wrapping values in a fixed range.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 162
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "NumberLiteral",
            "signature": {
              "text": "type NumberLiteral = number",
              "_tag": "TypeSignatureModel"
            },
            "description": "Number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 169
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PlusOne",
            "signature": {
              "text": "type PlusOne<$n extends NumberLiteral> = [\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n  20,\n  21,\n][\n  $n\n]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Add one to a number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 174
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MinusOne",
            "signature": {
              "text": "type MinusOne<$n extends NumberLiteral> = [\n  -1,\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n][\n  $n\n]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Subtract one from a number literal type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "operations",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 203
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RangeOptions",
            "signature": {
              "text": "interface RangeOptions {\n  /**\n   * The step between each number in the range.\n   * @default 1\n   */\n  step?: number\n  /**\n   * Whether to include the end value in the range.\n   * @default false\n   */\n  inclusive?: boolean\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Options for generating numeric ranges.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "range",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "start",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The starting value (inclusive)"
                    },
                    {
                      "name": "end",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The ending value (exclusive by default)"
                    },
                    {
                      "name": "options",
                      "type": "RangeOptions | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Configuration options"
                    }
                  ],
                  "returnType": "number[]",
                  "returnDoc": "An array of numbers in the range",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Generate an array of numbers in a range. By default, the range is exclusive of the end value and uses a step of 1.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeFrom",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "start",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The starting value"
                    }
                  ],
                  "returnType": "(end: number, options?: RangeOptions | undefined) => number[]",
                  "returnDoc": "A function that takes end and options and returns the range",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that generates a range from a specific start value. Useful for creating ranges with a fixed starting point.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 96
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeTo",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "end",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The ending value"
                    }
                  ],
                  "returnType": "(start: number, options?: RangeOptions | undefined) => number[]",
                  "returnDoc": "A function that takes start and options and returns the range",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that generates a range to a specific end value. Useful for creating ranges with a fixed ending point.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 117
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeStep",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "start",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The starting value"
                    },
                    {
                      "name": "end",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The ending value"
                    },
                    {
                      "name": "step",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The step between values"
                    }
                  ],
                  "returnType": "number[]",
                  "returnDoc": "An array of numbers in the range",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Generate a range with a specific step. A convenience function that makes the step explicit.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 136
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeStepWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "step",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The step between values"
                    }
                  ],
                  "returnType": "(start: number, end: number) => number[]",
                  "returnDoc": "A function that takes start and end and returns the range",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that generates ranges with a specific step. Useful for creating consistent stepped ranges.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 157
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "rangeInclusive",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "start",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The starting value"
                    },
                    {
                      "name": "end",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The ending value (inclusive)"
                    }
                  ],
                  "returnType": "number[]",
                  "returnDoc": "An array of numbers from start to end (inclusive)",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create an inclusive range. A convenience function that always includes the end value.",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 175
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "times",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "n",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number of times to execute the function"
                    },
                    {
                      "name": "fn",
                      "type": "(index: number) => T",
                      "optional": false,
                      "rest": false,
                      "description": "The function to execute, receives the current index"
                    }
                  ],
                  "returnType": "T[]",
                  "returnDoc": "An array of the function results",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Execute a function n times and collect the results. The function receives the current index (0-based) as its argument.",
            "examples": [],
            "category": "Iteration",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 200
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "timesWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "(index: number) => T",
                      "optional": false,
                      "rest": false,
                      "description": "The function to execute"
                    }
                  ],
                  "returnType": "(n: number) => T[]",
                  "returnDoc": "A function that takes n and returns the results array",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that executes another function n times. Useful for partial application of the times function.",
            "examples": [],
            "category": "Iteration",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 229
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lerp",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "start",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The starting value (when t = 0)"
                    },
                    {
                      "name": "end",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The ending value (when t = 1)"
                    },
                    {
                      "name": "t",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The interpolation factor (typically between 0 and 1)"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The interpolated value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Linear interpolation between two values. Calculates a value between start and end based on the interpolation factor t.",
            "examples": [],
            "category": "Interpolation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 259
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "lerpBetween",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "start",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The starting value"
                    },
                    {
                      "name": "end",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The ending value"
                    }
                  ],
                  "returnType": "(t: number) => number",
                  "returnDoc": "A function that takes t and returns the interpolated value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that linearly interpolates between two fixed values. Useful for creating reusable interpolation functions.",
            "examples": [],
            "category": "Interpolation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 309
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mapRange",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The value to map"
                    },
                    {
                      "name": "fromMin",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The minimum of the source range"
                    },
                    {
                      "name": "fromMax",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The maximum of the source range"
                    },
                    {
                      "name": "toMin",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The minimum of the target range"
                    },
                    {
                      "name": "toMax",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The maximum of the target range"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The mapped value in the target range",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Map a value from one range to another. Converts a value from the source range [fromMin, fromMax] to the target range [toMin, toMax].",
            "examples": [],
            "category": "Range Mapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 339
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mapRangeFrom",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "fromMin",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The minimum of the source range"
                    },
                    {
                      "name": "fromMax",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The maximum of the source range"
                    },
                    {
                      "name": "toMin",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The minimum of the target range"
                    },
                    {
                      "name": "toMax",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The maximum of the target range"
                    }
                  ],
                  "returnType": "(value: number) => number",
                  "returnDoc": "A function that takes a value and returns the mapped value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that maps values from one range to another. Useful for creating reusable range mapping functions.",
            "examples": [],
            "category": "Range Mapping",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 414
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "sequence",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "n",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number of integers to generate"
                    }
                  ],
                  "returnType": "number[]",
                  "returnDoc": "An array of integers from 0 to n-1",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Generate a sequence of integers starting from 0. A convenience function equivalent to range(0, n).",
            "examples": [],
            "category": "Range Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 440
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrap",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The value to wrap"
                    },
                    {
                      "name": "min",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The minimum of the range"
                    },
                    {
                      "name": "max",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The maximum of the range"
                    }
                  ],
                  "returnType": "number",
                  "returnDoc": "The wrapped value within [min, max)",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Constrain a value to be within a range, wrapping around if necessary. Unlike clamp which stops at boundaries, wrap continues from the other side.",
            "examples": [],
            "category": "Range Operations",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 471
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "wrapWithin",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "min",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The minimum of the range"
                    },
                    {
                      "name": "max",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The maximum of the range"
                    }
                  ],
                  "returnType": "(value: number) => number",
                  "returnDoc": "A function that takes a value and returns the wrapped value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a function that wraps values within a specific range.",
            "examples": [],
            "category": "Range Operations",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "num"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "range",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 534
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./obj",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "obj"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Object utilities for working with plain JavaScript objects.  \n\nProvides type-safe utilities for object operations including property access, manipulation, merging, filtering, and transformations. Supports both value-level and type-level operations with strong type inference.",
        "category": "Core Data Structures",
        "exports": [
          {
            "name": "Union",
            "signature": {
              "text": "export * as Union",
              "_tag": "TypeSignatureModel"
            },
            "description": "Union operations on objects.  \n\nThis module provides utilities for working with unions of object types, solving common TypeScript limitations when dealing with union types:  \n\n- `keyof (A | B)` returns only common keys (intersection), not all keys (union) - `(A | B)['key']` returns `any` for keys not in all members - No built-in way to merge union members while preserving value unions per key  \n\nThese utilities use distributive conditional types to properly handle each union member separately, then combine the results.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 12
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "union",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Union operations on objects.  \n\nThis module provides utilities for working with unions of object types, solving common TypeScript limitations when dealing with union types:  \n\n- `keyof (A | B)` returns only common keys (intersection), not all keys (union) - `(A | B)['key']` returns `any` for keys not in all members - No built-in way to merge union members while preserving value unions per key  \n\nThese utilities use distributive conditional types to properly handle each union member separately, then combine the results.",
              "exports": [
                {
                  "name": "Merge",
                  "signature": {
                    "text": "type Merge<$Union extends object> = {\n  [k in Keys<$Union>]: ValueAt<$Union, k>\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Union operations on objects.  \n\nThis module provides utilities for working with unions of object types, solving common TypeScript limitations when dealing with union types:  \n\n- `keyof (A | B)` returns only common keys (intersection), not all keys (union) - `(A | B)['key']` returns `any` for keys not in all members - No built-in way to merge union members while preserving value unions per key  \n\nThese utilities use distributive conditional types to properly handle each union member separately, then combine the results.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "obj"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 67
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Keys",
                  "signature": {
                    "text": "type Keys<\n  $Union extends object,\n> =\n$Union extends __FORCE_DISTRIBUTION__ ?\n\n  keyof $Union\n\n: never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Collects all keys from all members of a union of objects into a single union of keys.  \n\n**Problem:** TypeScript's built-in `keyof` operator on a union type returns only the keys that are common to ALL union members (intersection behavior), not all possible keys (union behavior). This is often counterintuitive when working with union types.  \n\n**Solution:** This utility uses distributive conditional types to iterate over each union member separately, extract its keys, then union all the results together.  \n\nCommon use cases: - Type-safe property access across union members - Building generic utilities that work with any key from union types - Validating property names in discriminated unions",
                  "examples": [
                    {
                      "code": "// The problem with built-in keyof\ntype A = { x: string, y: number }\ntype B = { x: boolean, z: string }\n\ntype Problem = keyof (A | B)  // 'x' (only keys in BOTH types)\ntype Solution = Obj.Union.Keys<A | B>  // 'x' | 'y' | 'z' (all keys)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Real-world: Type-safe property picker for discriminated unions\ntype Circle = { kind: 'circle', radius: number }\ntype Square = { kind: 'square', size: number }\ntype Shape = Circle | Square\n\ntype AllShapeKeys = Obj.Union.Keys<Shape>\n// 'kind' | 'radius' | 'size'\n\nfunction getProperty<K extends AllShapeKeys>(\n  shape: Shape,\n  key: K\n): Obj.Union.ValueAt<Shape, K> {\n  return (shape as any)[key]\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Works with optional properties\ntype Partial1 = { a?: string }\ntype Partial2 = { b?: number }\n\ntype Keys = Obj.Union.Keys<Partial1 | Partial2>  // 'a' | 'b'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "obj"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 124
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "ValueAt",
                  "signature": {
                    "text": "type ValueAt<\n  $Union extends object,\n  $Key extends PropertyKey,\n> =\n$Union extends __FORCE_DISTRIBUTION__ ?\n\n  $Key extends keyof $Union\n    ? $Union[$Key]\n    : never\n\n: never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Gets the union of all possible value types for a specific key across all members of a union of objects.  \n\n**Problem:** TypeScript's indexed access `(A | B)['key']` has problematic behavior: - Returns `any` when the key doesn't exist in all union members - Loses type information in complex union scenarios - Doesn't handle optional properties correctly  \n\n**Solution:** This utility uses distributive conditional types to: 1. Check each union member separately for the key 2. Collect the value type if present 3. Return `never` for members without the key (which gets filtered from the union) 4. Union all the collected value types together  \n\nCommon use cases: - Type-safe property getters for union types - Building mapped types over discriminated unions - Creating type-safe validators for specific properties",
                  "examples": [
                    {
                      "code": "// The problem with built-in indexed access\ntype A = { x: string, y: number }\ntype B = { x: boolean, z: string }\n\ntype Problem = (A | B)['y']  // any (unsafe - 'y' not in B!)\ntype Solution = Obj.Union.ValueAt<A | B, 'y'>  // number (correct!)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Keys in all members produce value union\ntype A = { x: string, y: number }\ntype B = { x: boolean, z: string }\n\ntype X = Obj.Union.ValueAt<A | B, 'x'>  // string | boolean",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Real-world: Type-safe discriminant extraction\ntype Success = { status: 'success', data: string }\ntype Error = { status: 'error', message: string }\ntype Result = Success | Error\n\ntype Status = Obj.Union.ValueAt<Result, 'status'>\n// 'success' | 'error'\n\ntype Data = Obj.Union.ValueAt<Result, 'data'>\n// string (only from Success, Error filtered as never)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Keys not in any member return never\ntype A = { x: string }\ntype B = { y: number }\n\ntype Missing = Obj.Union.ValueAt<A | B, 'z'>  // never",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Works with optional properties\ntype Config1 = { port?: number }\ntype Config2 = { port?: string }\n\ntype Port = Obj.Union.ValueAt<Config1 | Config2, 'port'>\n// number | string | undefined",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "obj"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 206
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "name": "Eq",
            "signature": {
              "type": "Eq<object>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Eq trait implementation for objects.  \n\nProvides deep structural equality for objects by recursively comparing properties using their appropriate Eq implementations.",
            "examples": [
              {
                "code": "import { Obj } from '@wollybeard/kit'\n\n// Basic object equality\nObj.Eq.is({ a: 1, b: 2 }, { a: 1, b: 2 }) // true\nObj.Eq.is({ a: 1, b: 2 }, { a: 1, b: 3 }) // false\nObj.Eq.is({ a: 1 }, { a: 1, b: 2 }) // false (different keys)\n\n// Nested objects\nObj.Eq.is(\n  { a: 1, b: { c: 2 } },\n  { a: 1, b: { c: 2 } }\n) // true\n\n// Mixed types in properties\nObj.Eq.is(\n  { a: 1, b: 'hello', c: true },\n  { a: 1, b: 'hello', c: true }\n) // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": {
              "type": "Type<object>",
              "_tag": "ValueSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 5
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "pick",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "object"
                    },
                    {
                      "name": "K",
                      "constraint": "keyof T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to pick properties from"
                    },
                    {
                      "name": "keys",
                      "type": "readonly K[]",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Pick<T, K>",
                  "returnDoc": "A new object containing only the specified properties",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "$Object",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$Object",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "predicate",
                      "type": "(key: keyof $Object, value?: undefined, obj?: undefined) => boolean",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Partial<$Object>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "$Object",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$Object",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "predicate",
                      "type": "(key: keyof $Object, value: $Object[keyof $Object], obj?: $Object | undefined) => boolean",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Partial<$Object>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "object"
                    },
                    {
                      "name": "K",
                      "constraint": "keyof T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "T",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "keysOrPredicate",
                      "type": "readonly K[] | ((key: keyof T, value?: any, obj?: any) => boolean)",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Pick<T, K> | Partial<T>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a new object with only the specified properties.",
            "examples": [
              {
                "code": "// Using array of keys\nconst user = { name: 'Alice', age: 30, email: 'alice@example.com' }\nconst publicInfo = pick(user, ['name', 'email'])\n// Result: { name: 'Alice', email: 'alice@example.com' }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe property selection\ninterface User {\n  id: number\n  name: string\n  password: string\n  email: string\n}\n\nfunction getPublicUser(user: User) {\n  return pick(user, ['id', 'name', 'email'])\n  // Type: Pick<User, 'id' | 'name' | 'email'>\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using a predicate function (key only)\nconst obj = { a: 1, b: 2, c: 3 }\npick(obj, k => k !== 'b') // { a: 1, c: 3 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using a filter function (key, value, obj)\nconst obj = { a: 1, b: 2, c: 3 }\npick(obj, (k, v) => v > 1) // { b: 2, c: 3 }\npick(obj, (k, v, o) => v > average(o)) // picks above-average values",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 62
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "omit",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "object"
                    },
                    {
                      "name": "K",
                      "constraint": "keyof T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to omit properties from"
                    },
                    {
                      "name": "keys",
                      "type": "readonly K[]",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Omit<T, K>",
                  "returnDoc": "A new object without the specified properties",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "$Object",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$Object",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "predicate",
                      "type": "(key: keyof $Object, value?: undefined, obj?: undefined) => boolean",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Partial<$Object>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "$Object",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$Object",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "predicate",
                      "type": "(key: keyof $Object, value: $Object[keyof $Object], obj?: $Object | undefined) => boolean",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Partial<$Object>",
                  "throws": []
                },
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "object"
                    },
                    {
                      "name": "K",
                      "constraint": "keyof T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "T",
                      "optional": false,
                      "rest": false
                    },
                    {
                      "name": "keysOrPredicate",
                      "type": "readonly K[] | ((key: keyof T, value?: any, obj?: any) => boolean)",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "Omit<T, K> | Partial<T>",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a new object with the specified properties removed.",
            "examples": [
              {
                "code": "// Using array of keys\nconst user = { name: 'Alice', age: 30, password: 'secret' }\nconst safeUser = omit(user, ['password'])\n// Result: { name: 'Alice', age: 30 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Remove sensitive fields\ninterface User {\n  id: number\n  name: string\n  password: string\n  apiKey: string\n}\n\nfunction sanitizeUser(user: User) {\n  return omit(user, ['password', 'apiKey'])\n  // Type: Omit<User, 'password' | 'apiKey'>\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using a predicate function (key only)\nconst obj = { a: 1, b: 2, c: 3 }\nomit(obj, k => k === 'b') // { a: 1, c: 3 } (excludes b)",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using a filter function (key, value, obj)\nconst obj = { a: 1, b: 2, c: 3 }\nomit(obj, (k, v) => v > 1) // { a: 1 } (excludes b and c where value > 1)\nomit(obj, (k, v, o) => v > average(o)) // excludes above-average values",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 162
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "pickWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "K",
                      "constraint": "PropertyKey"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "keysOrPredicate",
                      "type": "readonly K[] | ((key: PropertyKey, value?: any, obj?: any) => boolean)",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<T extends object>(obj: T) => any",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of pick - takes keys/predicate first, then object.",
            "examples": [],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 91
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "pickOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "T",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<K extends keyof T>(keysOrPredicate: readonly K[] | ((key: keyof T, value?: any, obj?: any) => boolean)) => any",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of pick - takes object first, then keys/predicate.",
            "examples": [],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 105
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "omitWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "K",
                      "constraint": "PropertyKey"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "keysOrPredicate",
                      "type": "readonly K[] | ((key: PropertyKey, value?: any, obj?: any) => boolean)",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<T extends object>(obj: T) => any",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of omit - takes keys/predicate first, then object.",
            "examples": [],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 192
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "omitOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "T",
                      "optional": false,
                      "rest": false
                    }
                  ],
                  "returnType": "<K extends keyof T>(keysOrPredicate: readonly K[] | ((key: keyof T, value?: any, obj?: any) => boolean)) => any",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of omit - takes object first, then keys/predicate.",
            "examples": [],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 206
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "policyFilter",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Object",
                      "constraint": "object"
                    },
                    {
                      "name": "$Key",
                      "constraint": "Keyof<$Object>"
                    },
                    {
                      "name": "$Mode",
                      "constraint": "'allow' | 'deny'"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "mode",
                      "type": "$Mode",
                      "optional": false,
                      "rest": false,
                      "description": "'allow' to keep only specified keys, 'deny' to remove specified keys"
                    },
                    {
                      "name": "obj",
                      "type": "$Object",
                      "optional": false,
                      "rest": false,
                      "description": "The object to filter"
                    },
                    {
                      "name": "keys",
                      "type": "readonly $Key[]",
                      "optional": false,
                      "rest": false,
                      "description": "The keys to process"
                    }
                  ],
                  "returnType": "PolicyFilter<$Object, $Key, $Mode>",
                  "returnDoc": "A filtered object with proper type inference",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Filter object properties based on a policy mode and set of keys.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2, c: 3 }\n\n// Allow mode: keep only 'a' and 'c'\npolicyFilter('allow', obj, ['a', 'c']) // { a: 1, c: 3 }\n\n// Deny mode: remove 'a' and 'c'\npolicyFilter('deny', obj, ['a', 'c']) // { b: 2 }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 236
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "omitUndefined",
            "signature": {
              "type": "<T>(obj: T) => any",
              "_tag": "ValueSignatureModel"
            },
            "description": "Remove all properties with `undefined` values from an object.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: undefined, c: 'hello', d: undefined }\nomitUndefined(obj) // { a: 1, c: 'hello' }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for cleaning up optional parameters\nconst config = {\n  host: 'localhost',\n  port: options.port,      // might be undefined\n  timeout: options.timeout  // might be undefined\n}\nconst cleanConfig = omitUndefined(config)\n// Only includes properties that have actual values",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 291
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "partition",
            "signature": {
              "text": "interface partition extends\n  Ts.SimpleSignature.SimpleSignature<[\n    (obj: object, pickedKeys: readonly string[]) => { picked: object; omitted: object },\n  ]>\n{\n  <$Object extends object, $Key extends keyof $Object>(\n    obj: $Object,\n    pickedKeys: readonly $Key[],\n  ): { omitted: Omit<$Object, $Key>; picked: Pick<$Object, $Key> }\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 293
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "pickMatching",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to filter"
                    },
                    {
                      "name": "predicate",
                      "type": "(key: string) => boolean",
                      "optional": false,
                      "rest": false,
                      "description": "Function that returns true to keep a key"
                    }
                  ],
                  "returnType": "Partial<T>",
                  "returnDoc": "A new object with only the key/value pairs where key predicate returned true",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Filter object properties by key pattern matching. Useful for extracting properties that match a pattern like data attributes.",
            "examples": [
              {
                "code": "const props = {\n  'data-type': 'button',\n  'data-current': true,\n  onClick: fn,\n  className: 'btn'\n}\nconst dataAttrs = pickMatching(props, key => key.startsWith('data-'))\n// Result: { 'data-type': 'button', 'data-current': true }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Filtering",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 357
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Keyof",
            "signature": {
              "text": "type Keyof<$Object extends object> = object extends $Object ? PropertyKey : (keyof $Object)",
              "_tag": "TypeSignatureModel"
            },
            "description": "Like keyof but returns PropertyKey for object type. Helper type for generic object key operations.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 380
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PolicyFilter",
            "signature": {
              "text": "type PolicyFilter<\n  $Object extends object,\n  $Key extends Keyof<$Object>,\n  $Mode extends 'allow' | 'deny',\n> = $Mode extends 'allow'\n      ? Pick<$Object, Extract<$Key, keyof $Object>>\n      : Omit<$Object, Extract<$Key, keyof $Object>>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Filter object properties based on a policy mode and set of keys.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; email: string; password: string }\n// Allow mode: keep only specified keys\ntype PublicUser = PolicyFilter<User, 'id' | 'name', 'allow'>\n// Result: { id: number; name: string }\n\n// Deny mode: remove specified keys\ntype SafeUser = PolicyFilter<User, 'password', 'deny'>\n// Result: { id: number; name: string; email: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 400
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickWhereValueExtends",
            "signature": {
              "text": "type PickWhereValueExtends<$Obj extends object, $Constraint> = {\n  [k in keyof $Obj as $Obj[k] extends $Constraint ? k : never]: $Obj[k]\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Pick properties from an object where the values extend a given constraint.",
            "examples": [
              {
                "code": "type User = { name: string; age: number; isActive: boolean; flag: boolean }\ntype BooleanProps = PickWhereValueExtends<User, boolean>\n// Result: { isActive: boolean; flag: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 420
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "SuffixKeyNames",
            "signature": {
              "text": "type SuffixKeyNames<$Suffix extends string, $Object extends object> = {\n  [k in keyof $Object as k extends string ? `${k}${$Suffix}` : k]: $Object[k]\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Add a suffix to all property names in an object.",
            "examples": [
              {
                "code": "type T = SuffixKeyNames<'_old', { a: string; b: number }>\n// { a_old: string; b_old: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 435
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OmitKeysWithPrefix",
            "signature": {
              "text": "type OmitKeysWithPrefix<$Object extends object, $Prefix extends string> = {\n  [k in keyof $Object as k extends `${$Prefix}${string}` ? never : k]: $Object[k]\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Omit all keys that start with a specific prefix.",
            "examples": [
              {
                "code": "type T = OmitKeysWithPrefix<{ _a: string; _b: number; c: boolean }, '_'>\n// { c: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 450
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickRequiredProperties",
            "signature": {
              "text": "type PickRequiredProperties<$T extends object> = {\n  [k in keyof $T as {} extends Pick<$T, k> ? never : k]: $T[k]\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Pick only the required (non-optional) properties from an object.",
            "examples": [
              {
                "code": "type T = PickRequiredProperties<{ a: string; b?: number }>  // { a: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 464
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RequireProperties",
            "signature": {
              "text": "type RequireProperties<$O extends object, $K extends keyof $O> = Ts.Simplify<$O & { [k in $K]-?: $O[k] }>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Make specific properties required in an object.",
            "examples": [
              {
                "code": "type T = RequireProperties<{ a?: string; b?: number }, 'a'>\n// { a: string; b?: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 479
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PartialOrUndefined",
            "signature": {
              "text": "type PartialOrUndefined<$T> = {\n  [k in keyof $T]?: $T[k] | undefined\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Make all properties optional and allow undefined values.",
            "examples": [
              {
                "code": "type T = PartialOrUndefined<{ a: string; b: number }>\n// { a?: string | undefined; b?: number | undefined }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 492
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PickOptionalPropertyOrFallback",
            "signature": {
              "text": "type PickOptionalPropertyOrFallback<$Object extends object, $Property extends keyof $Object, $Fallback> =\n  {} extends Pick<$Object, $Property> ? $Object[$Property] : $Fallback",
              "_tag": "TypeSignatureModel"
            },
            "description": "Pick an optional property or use fallback if required.",
            "examples": [
              {
                "code": "type T1 = PickOptionalPropertyOrFallback<{ a?: string }, 'a', never>  // string\ntype T2 = PickOptionalPropertyOrFallback<{ a: string }, 'a', never>  // never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 507
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OnlyKeysInArray",
            "signature": {
              "text": "type OnlyKeysInArray<$Obj extends object, $KeysArray extends readonly string[]> = {\n  [k in keyof $Obj as k extends $KeysArray[number] ? k : never]: $Obj[k]\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Pick only the properties from an object that exist in a provided array of keys.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; age: number; email: string }\ntype PublicUser = OnlyKeysInArray<User, ['name', 'email']>\n// Result: { name: string; email: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "filter",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 522
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "getWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "pathInput",
                      "constraint": "PropertyPathInput"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "pathInput",
                      "type": "pathInput",
                      "optional": false,
                      "rest": false,
                      "description": "A dot-notation string or array of property names"
                    }
                  ],
                  "returnType": "<obj extends InferShapeFromPropertyPath<normalizePropertyPathInput<pathInput>>>(obj: obj) => getWith<normalizePropertyPathInput<pathInput>, obj>",
                  "returnDoc": "A function that extracts the value at the specified path",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a getter function for a specific property path. Returns a function that extracts the value at that path from any compatible object.",
            "examples": [
              {
                "code": "const getCityName = getWith('address.city')\ngetCityName({ address: { city: 'NYC' } }) // 'NYC'\ngetCityName({ address: { city: 'LA' } }) // 'LA'",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe property access\nconst getAge = getWith(['user', 'profile', 'age'])\nconst data = { user: { profile: { age: 30 } } }\nconst age = getAge(data) // number",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for mapping over arrays\nconst users = [\n  { name: 'Alice', score: 95 },\n  { name: 'Bob', score: 87 }\n]\nusers.map(getWith('score')) // [95, 87]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 63
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "object",
                      "optional": false,
                      "rest": false,
                      "description": "The object to extract values from"
                    }
                  ],
                  "returnType": "(pathInput: PropertyPathInput) => unknown",
                  "returnDoc": "A function that accepts a property path and returns the value at that path",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a getter function bound to a specific object. Returns a function that can extract values from that object using any property path. Inverse parameter order of getWith.",
            "examples": [
              {
                "code": "const user = {\n  name: 'Alice',\n  address: { city: 'NYC', zip: '10001' }\n}\n\nconst getUserProp = getOn(user)\ngetUserProp('name') // 'Alice'\ngetUserProp('address.city') // 'NYC'\ngetUserProp(['address', 'zip']) // '10001'",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for extracting multiple properties\nconst config = { api: { url: 'https://api.com', key: 'secret' } }\nconst getConfig = getOn(config)\n\nconst apiUrl = getConfig('api.url')\nconst apiKey = getConfig('api.key')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 122
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "entries",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "obj",
                      "constraint": "Any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "obj",
                      "optional": false,
                      "rest": false,
                      "description": "The object to extract entries from"
                    }
                  ],
                  "returnType": "{ [K in keyof obj]-?: undefined extends obj[K] ? {} extends Pick<obj, K> ? [K, Exclude<obj[K]>] : [K, obj[K]] : [K, obj[K]]; }[keyof obj][]",
                  "returnDoc": "An array of tuples containing [key, value] pairs",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get an array of key-value pairs from an object. Preserves exact types including optional properties and undefined values.",
            "examples": [
              {
                "code": "entries({ a: 1, b: 'hello', c: true })\n// Returns: [['a', 1], ['b', 'hello'], ['c', true]]",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Handles optional properties and undefined values\nentries({ a: 1, b?: 2, c: undefined })\n// Returns proper types preserving optionality",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 156
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "stringKeyEntries",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to extract entries from"
                    }
                  ],
                  "returnType": "[string & keyof $T, $T[keyof $T]][]",
                  "returnDoc": "An array of [key, value] tuples where keys are strings",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get entries from an object with string keys only.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2 }\nstringKeyEntries(obj)  // [['a', 1], ['b', 2]]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 183
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "entriesStrict",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to extract entries from"
                    }
                  ],
                  "returnType": "{ [k in keyof $T]: [k, Exclude<$T[k], undefined>]; }[keyof $T][]",
                  "returnDoc": "An array of [key, value] tuples excluding undefined values",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get entries from an object excluding undefined values.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: undefined, c: 2 }\nentriesStrict(obj)  // [['a', 1], ['c', 2]]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 200
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "keysStrict",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to extract keys from"
                    }
                  ],
                  "returnType": "(keyof $T)[]",
                  "returnDoc": "An array of keys",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get keys from an object with proper type inference. Type-safe version of Object.keys.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 2 }\nkeysStrict(obj)  // ['a', 'b'] with type ('a' | 'b')[]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 222
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getRandomly",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "obj",
                      "constraint": "Any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "obj",
                      "optional": false,
                      "rest": false,
                      "description": "The object to get a random value from"
                    }
                  ],
                  "returnType": "keyof obj extends never ? undefined : obj[keyof obj]",
                  "returnDoc": "A random value from the object, or undefined for empty objects",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get a random property value from an object",
            "examples": [
              {
                "code": "getRandomly({ a: 1, b: 2, c: 3 }) // Could return 1, 2, or 3\ngetRandomly({ a: 1, b: undefined }) // Could return 1 or undefined\ngetRandomly({}) // Returns undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 241
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getValueAtPath",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T"
                    },
                    {
                      "name": "___Path",
                      "constraint": "readonly string[]"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to traverse"
                    },
                    {
                      "name": "path",
                      "type": "___Path",
                      "optional": false,
                      "rest": false,
                      "description": "Array of property names representing the path"
                    }
                  ],
                  "returnType": "any",
                  "returnDoc": "The value at the path, or undefined if not found",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get a value at a path in an object.",
            "examples": [
              {
                "code": "const obj = { a: { b: { c: 42 } } }\ngetValueAtPath(obj, ['a', 'b', 'c'])  // 42\ngetValueAtPath(obj, ['a', 'x'])  // undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 270
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "values",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to extract values from"
                    }
                  ],
                  "returnType": "values<$T>",
                  "returnDoc": "An array of values",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Get an array of values from an object. Type-safe version of Object.values.",
            "examples": [
              {
                "code": "const obj = { a: 1, b: 'hello', c: true }\nvalues(obj)  // [1, 'hello', true] with type (string | number | boolean)[]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Access",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 300
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "GetKeyOr",
            "signature": {
              "text": "type GetKeyOr<$T, $Key, $Or> = $Key extends keyof $T ? $T[$Key] : $Or",
              "_tag": "TypeSignatureModel"
            },
            "description": "Get value at key, or return fallback if key doesn't exist.",
            "examples": [
              {
                "code": "type T1 = GetKeyOr<{ a: string }, 'a', never>  // string\ntype T2 = GetKeyOr<{ a: string }, 'b', never>  // never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 317
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GetOrNever",
            "signature": {
              "text": "type GetOrNever<$O extends object, $P extends string> = $P extends keyof $O ? $O[$P]\n  : $P extends `${infer __head__}.${infer __tail__}`\n    ? __head__ extends keyof $O ? GetOrNever<$O[__head__] & object, __tail__>\n    : never\n  : never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Get value at key or return never.",
            "examples": [
              {
                "code": "type T1 = GetOrNever<{ a: string }, 'a'>  // string\ntype T2 = GetOrNever<{ a: string }, 'b'>  // never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 330
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "keyofOr",
            "signature": {
              "text": "type keyofOr<$Obj extends object, $Or> = [keyof $Obj] extends [never] ? $Or : $Obj[keyof $Obj]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Get the union of all value types from an object, or return fallback if no keys.",
            "examples": [
              {
                "code": "type T1 = keyofOr<{ a: string; b: number }, never>  // string | number\ntype T2 = keyofOr<{}, 'fallback'>  // 'fallback'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 347
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "KeysArray",
            "signature": {
              "text": "type KeysArray<$Obj extends object> = Array<keyof $Obj>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Create an array type containing the keys of an object.",
            "examples": [
              {
                "code": "type User = { name: string; age: number; email: string }\ntype UserKeys = KeysArray<User>\n// Result: Array<'name' | 'age' | 'email'>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 361
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "KeysReadonlyArray",
            "signature": {
              "text": "type KeysReadonlyArray<$Obj extends object> = ReadonlyArray<keyof $Obj>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Create a readonly array type containing the keys of an object.",
            "examples": [
              {
                "code": "type User = { name: string; age: number; email: string }\ntype UserKeys = KeysReadonlyArray<User>\n// Result: ReadonlyArray<'name' | 'age' | 'email'>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 375
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StringKeyof",
            "signature": {
              "text": "type StringKeyof<$T> = keyof $T & string",
              "_tag": "TypeSignatureModel"
            },
            "description": "Extract only string keys from an object.",
            "examples": [
              {
                "code": "type T = StringKeyof<{ a: 1; [x: number]: 2 }>  // 'a'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 387
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "PrimitiveFieldKeys",
            "signature": {
              "text": "type PrimitiveFieldKeys<$T> = {\n  [K in keyof $T]: $T[K] extends string | number | boolean | bigint | null | undefined ? K\n    : $T[K] extends Date ? K\n    : never\n}[keyof $T]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Extract keys from an object type that have primitive values. Useful for serialization scenarios where only primitive values can be safely transferred.",
            "examples": [
              {
                "code": "type User = {\n  id: number\n  name: string\n  createdAt: Date\n  metadata: { tags: string[] }\n  isActive: boolean\n}\ntype SerializableKeys = PrimitiveFieldKeys<User>\n// Result: 'id' | 'name' | 'createdAt' | 'isActive'\n// Note: Date is considered primitive for serialization purposes",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "get",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 409
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "DeepObjectValue",
            "signature": {
              "text": "type DeepObjectValue = string | boolean | null | number | DeepObject | DeepObjectValue[]",
              "_tag": "TypeSignatureModel"
            },
            "description": "A deep object value can be any JSON-serializable value including nested objects and arrays.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "map-entries-deep",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "DeepObject",
            "signature": {
              "text": "type DeepObject = { [key: string]: DeepObjectValue }",
              "_tag": "TypeSignatureModel"
            },
            "description": "A deep object is a plain object with string keys and deep object values.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "map-entries-deep",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mapEntriesDeep",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$value",
                      "constraint": "DeepObjectValue"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "$value",
                      "optional": false,
                      "rest": false,
                      "description": "The value to traverse (can be primitive, object, or array)"
                    },
                    {
                      "name": "visitor",
                      "type": "(key: string, value: DeepObjectValue) => { key: string; value: DeepObjectValue; } | undefined",
                      "optional": false,
                      "rest": false,
                      "description": "Function called for each object entry.                  Return `undefined` to keep unchanged, or `{key, value}` to transform."
                    }
                  ],
                  "returnType": "$value",
                  "returnDoc": "A new structure with entry transformations applied",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Recursively traverse nested object structures and transform key-value pairs (entries).  \n\nPerforms **top-down traversal**: The visitor function is called for each object entry BEFORE recursing into the value's children. This allows transforming both keys and values while maintaining consistent traversal semantics with mapValuesDeep.  \n\n## Visitor Pattern  \n\nThe visitor receives both the key and value for each object entry: - **Return `undefined`**: Keep the entry unchanged and recurse into the value's children - **Return `{key, value}`**: Replace the entry and recurse into the NEW value's children  \n\n**Note**: Unlike mapValuesDeep, this function does NOT support early exit. The visitor result is always recursed into, whether it's the original or transformed value.  \n\n## Features  \n\n- **Key transformations**: Rename object keys throughout nested structures - **Value transformations**: Transform values based on their keys - **Combined transformations**: Change both key and value simultaneously - **Circular reference safe**: Automatically detects and marks circular references as `'[Circular]'` - **Type preservation**: Maintains array and object structures during traversal  \n\n## Common Use Cases  \n\n- Normalizing key naming conventions (e.g., stripping prefixes, camelCase conversion) - Transforming values based on key patterns - Sanitizing or filtering object properties recursively - Renaming keys while preserving nested structure  \n\n## Comparison with mapValuesDeep  \n\nUse **mapEntriesDeep** when you need to: - Transform object keys - Access both key and value in the visitor - Transform entries at the object level  \n\nUse **mapValuesDeep** when you need to: - Only transform values (keys unchanged) - Early exit optimization (stop recursing after match) - Transform any value type (not just object entries)",
            "examples": [
              {
                "code": "const data = {\n  $name: 'Alice',\n  $age: 30,\n  $address: {\n    $city: 'NYC',\n    $zip: '10001'\n  }\n}\n\nmapEntriesDeep(data, (key, value) =>\n  key.startsWith('$') ? { key: key.slice(1), value } : undefined\n)\n// { name: 'Alice', age: 30, address: { city: 'NYC', zip: '10001' } }",
                "title": "**Key normalization** - Strip prefix from keys:",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "const data = {\n  name: 'alice',\n  location: {\n    city: 'nyc',\n    country: 'usa'\n  }\n}\n\nmapEntriesDeep(data, (key, value) =>\n  typeof value === 'string' ? { key, value: value.toUpperCase() } : undefined\n)\n// { name: 'ALICE', location: { city: 'NYC', country: 'USA' } }",
                "title": "**Value transformation** - Uppercase all string values:",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "mapEntriesDeep(data, (key, value) => {\n  if (key.startsWith('$')) {\n    const newKey = key.slice(1)\n    const newValue = typeof value === 'string' ? value.toUpperCase() : value\n    return { key: newKey, value: newValue }\n  }\n})",
                "title": "**Combined transformation** - Strip prefix AND uppercase string values:",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "mapEntriesDeep(data, (key, value) => {\n  if (key === 'password' || key === 'apiKey') {\n    return { key, value: '[REDACTED]' }\n  }\n})",
                "title": "**Selective transformation** - Only transform specific keys:",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "const users = [\n  { $id: 1, $name: 'Alice' },\n  { $id: 2, $name: 'Bob' }\n]\n\nmapEntriesDeep(users, (key, value) =>\n  key.startsWith('$') ? { key: key.slice(1), value } : undefined\n)\n// [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]",
                "title": "**Works with arrays** - Transforms entries in nested arrays:",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "map-entries-deep",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 132
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mapValuesDeep",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "any",
                      "optional": false,
                      "rest": false,
                      "description": "Any value to traverse (primitive, object, or array)"
                    },
                    {
                      "name": "visitor",
                      "type": "(value: any) => any",
                      "optional": false,
                      "rest": false,
                      "description": "Transformation function called for each value.                  Return `undefined` to continue recursing, or any other value to replace and stop."
                    },
                    {
                      "name": "visited",
                      "type": "WeakSet<WeakKey>",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "new WeakSet()"
                    }
                  ],
                  "returnType": "any",
                  "returnDoc": "Transformed structure with visitor transformations applied",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Recursively traverse and transform values in nested data structures with early exit optimization.  \n\nPerforms **top-down traversal**: The visitor function is called for each value BEFORE recursing into its children. This enables the visitor to transform a value and prevent further recursion, which is useful for replacing complex objects with primitives or handling special types.  \n\n## Early Exit Pattern  \n\nThe visitor function controls recursion through its return value: - **Return `undefined`**: Continue recursing into the original value's children - **Return any other value**: Use as replacement and STOP recursing into that branch  \n\n## Features  \n\n- **Handles all structures**: Works with primitives, objects, arrays, and nested combinations - **Circular reference safe**: Automatically detects and marks circular references as `'[Circular]'` - **Type preservation**: Maintains array and object structures during traversal - **Performance**: Early exit allows stopping recursion when a match is found  \n\n## Common Use Cases  \n\n- Encoding schema instances to primitives (e.g., for snapshots) - Replacing Error objects with error messages - Sanitizing sensitive data in nested structures - Truncating or formatting string values deeply - Converting special objects to JSON-serializable forms",
            "examples": [
              {
                "code": "import { Schema as S } from 'effect'\n\nmapValuesDeep(testData, (v) => {\n  for (const schema of [FsLoc.FsLoc, User.User]) {\n    if (S.is(schema)(v)) {\n      return S.encodeSync(schema)(v)  // Replace and stop recursing\n    }\n  }\n  // Return undefined to continue into children\n})\n// Before: { location: FsLocInstance { ... } }\n// After:  { location: './src/index.ts' }",
                "title": "**Schema encoding** - Transform schema instances to encoded primitives:",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "const data = {\n  result: 'success',\n  errors: [new Error('Failed'), new Error('Timeout')],\n  nested: { err: new Error('Deep error') }\n}\n\nmapValuesDeep(data, (v) => {\n  if (v instanceof Error) return v.message\n})\n// { result: 'success', errors: ['Failed', 'Timeout'], nested: { err: 'Deep error' } }",
                "title": "**Error sanitization** - Replace Error objects with messages:",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "mapValuesDeep(data, (v) => {\n  if (typeof v === 'string' && v.length > 100) {\n    return v.slice(0, 100) + '...'\n  }\n})",
                "title": "**String truncation** - Limit string lengths throughout a structure:",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "mapValuesDeep(data, (v) => {\n  // Replace Buffer objects with their base64 representation\n  if (Buffer.isBuffer(v)) {\n    return v.toString('base64')\n  }\n})",
                "title": "**Conditional replacement** - Replace specific objects entirely:",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "map-values-deep",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 89
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mergeWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "mergers",
                      "type": "MergeOptions | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Options to customize merge behavior"
                    }
                  ],
                  "returnType": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
                  "returnDoc": "A merge function with the specified behavior",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a customized merge function with specific merge behavior options. Allows control over how undefined values, defaults, and arrays are handled.",
            "examples": [
              {
                "code": "// Create a merger that ignores undefined values\nconst mergeIgnoreUndefined = mergeWith({ undefined: false })\nmergeIgnoreUndefined({ a: 1 }, { a: undefined, b: 2 })\n// Returns: { a: 1, b: 2 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Create a merger that concatenates arrays\nconst mergeArrays = mergeWith({\n  array: (a, b) => { a.push(...b) }\n})\nmergeArrays({ items: [1, 2] }, { items: [3, 4] })\n// Returns: { items: [1, 2, 3, 4] }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 43
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "merge",
            "signature": {
              "type": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
              "_tag": "ValueSignatureModel"
            },
            "description": "Deep merge two objects, with properties from the second object overwriting the first. Recursively merges nested objects, but arrays and other non-object values are replaced.",
            "examples": [
              {
                "code": "merge({ a: 1, b: 2 }, { b: 3, c: 4 })\n// Returns: { a: 1, b: 3, c: 4 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Deep merging of nested objects\nmerge(\n  { user: { name: 'Alice', age: 30 } },\n  { user: { age: 31, city: 'NYC' } }\n)\n// Returns: { user: { name: 'Alice', age: 31, city: 'NYC' } }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Arrays are replaced, not merged\nmerge({ tags: ['a', 'b'] }, { tags: ['c', 'd'] })\n// Returns: { tags: ['c', 'd'] }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 81
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeWithArrayPush",
            "signature": {
              "type": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
              "_tag": "ValueSignatureModel"
            },
            "description": "Deep merge two objects with special handling for arrays. When both objects have an array at the same path, concatenates them instead of replacing.",
            "examples": [
              {
                "code": "mergeWithArrayPush(\n  { tags: ['react', 'typescript'] },\n  { tags: ['nodejs', 'express'] }\n)\n// Returns: { tags: ['react', 'typescript', 'nodejs', 'express'] }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Works with nested arrays\nmergeWithArrayPush(\n  { user: { skills: ['js'] } },\n  { user: { skills: ['ts'] } }\n)\n// Returns: { user: { skills: ['js', 'ts'] } }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 108
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeWithArrayPushDedupe",
            "signature": {
              "type": "<obj1 extends Any, obj2 extends Any>(obj1: obj1, obj2: obj2) => obj1 & obj2",
              "_tag": "ValueSignatureModel"
            },
            "description": "Deep merge two objects with array concatenation and deduplication. When both objects have an array at the same path, concatenates and removes duplicates.",
            "examples": [
              {
                "code": "mergeWithArrayPushDedupe(\n  { tags: ['react', 'vue', 'react'] },\n  { tags: ['react', 'angular'] }\n)\n// Returns: { tags: ['react', 'vue', 'angular'] }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Preserves order with first occurrence kept\nmergeWithArrayPushDedupe(\n  { ids: [1, 2, 3] },\n  { ids: [3, 4, 2, 5] }\n)\n// Returns: { ids: [1, 2, 3, 4, 5] }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 139
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "mergeDefaults",
            "signature": {
              "type": "<obj1 extends Any, obj1Defaults extends Partial<obj1>>(obj1: obj1, obj1Defaults: obj1Defaults) => { [_ in keyof (obj1 & obj1Defaults)]: (obj1 & obj1Defaults)[_]; }",
              "_tag": "ValueSignatureModel"
            },
            "description": "Merge default values into an object, only filling in missing properties. Existing properties in the base object are preserved, even if undefined.",
            "examples": [
              {
                "code": "mergeDefaults(\n  { name: 'Alice', age: undefined },\n  { name: 'Unknown', age: 0, city: 'NYC' }\n)\n// Returns: { name: 'Alice', age: undefined, city: 'NYC' }\n// Note: existing properties (even undefined) are not overwritten",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for configuration objects\nconst config = { port: 3000 }\nconst defaults = { port: 8080, host: 'localhost', debug: false }\nmergeDefaults(config, defaults)\n// Returns: { port: 3000, host: 'localhost', debug: false }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 175
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "shallowMergeDefaults",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Defaults",
                      "constraint": "object"
                    },
                    {
                      "name": "$Input",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "defaults",
                      "type": "$Defaults",
                      "optional": false,
                      "rest": false,
                      "description": "The default values"
                    },
                    {
                      "name": "input",
                      "type": "$Input",
                      "optional": false,
                      "rest": false,
                      "description": "The input values that override defaults"
                    }
                  ],
                  "returnType": "$Defaults & $Input",
                  "returnDoc": "Merged object",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Shallow merge two objects with later values overriding earlier ones. Useful for providing defaults that can be overridden.",
            "examples": [
              {
                "code": "const defaults = { a: 1, b: 2, c: 3 }\nconst input = { b: 20 }\nshallowMergeDefaults(defaults, input)  // { a: 1, b: 20, c: 3 }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 199
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "spreadShallow",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$Objects",
                      "constraint": "readonly (object | undefined)[]"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "objects",
                      "type": "$Objects",
                      "optional": true,
                      "rest": true,
                      "description": "Objects to merge (later objects override earlier ones). Undefined objects are ignored."
                    }
                  ],
                  "returnType": "{}",
                  "returnDoc": "Merged object with undefined values omitted",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Shallow merge objects while omitting undefined values. Simplifies the common pattern of conditionally spreading objects to avoid including undefined values that would override existing values.",
            "examples": [
              {
                "code": "// Instead of:\nconst config = {\n  ...defaultConfig,\n  ...(userConfig ? userConfig : {}),\n  ...(debug ? { debug: true } : {}),\n}\n\n// Use:\nconst config = spreadShallow(\n  defaultConfig,\n  userConfig,\n  { debug: debug ? true : undefined }\n)\n// undefined values won't override earlier values",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Merging",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 234
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "MergeShallow",
            "signature": {
              "text": "type MergeShallow<\n  $Object1 extends Any,\n  $Object2 extends Any,\n  __ =\n    {} extends $Object1\n      ? $Object2\n      : & $Object2\n        // Keys from $Object1 that are NOT in $Object2\n        & {\n            [__k__ in keyof $Object1 as __k__ extends keyof $Object2 ? never : __k__]: $Object1[__k__]\n          }\n> = __",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 261
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MergeAllShallow",
            "signature": {
              "text": "type MergeAllShallow<$Objects extends readonly object[]> =\n  $Objects extends readonly [infer $First extends object, ...infer $Rest extends object[]]\n    ? $Rest extends readonly []\n      ? $First\n      : MergeShallow<$First, MergeAllShallow<$Rest>>\n    : {}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Recursively merge an array of objects using shallow merge semantics. Each object in the array overrides properties from previous objects.",
            "examples": [
              {
                "code": "type T = MergeAllShallow<[{ a: string }, { b: number }, { c: boolean }]>\n// Result: { a: string; b: number; c: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 287
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MergeAll",
            "signature": {
              "text": "type MergeAll<$Objects extends object[]> = $Objects extends\n  [infer __first__ extends object, ...infer __rest__ extends object[]] ? __first__ & MergeAll<__rest__>\n  : {}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Merge an array of object types into a single type using deep merge semantics. Uses TypeScript's intersection type (`&`) for merging.",
            "examples": [
              {
                "code": "type T = MergeAll<[{ a: string }, { b: number }]>\n// Result: { a: string; b: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 306
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ReplaceProperty",
            "signature": {
              "text": "type ReplaceProperty<$Obj extends object, $Key extends keyof $Obj, $NewType> =\n  & Omit<$Obj, $Key>\n  & {\n    [_ in $Key]: $NewType\n  }",
              "_tag": "TypeSignatureModel"
            },
            "description": "Replace the type of a specific property in an object.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; age: number }\ntype UpdatedUser = ReplaceProperty<User, 'id', string>\n// Result: { id: string; name: string; age: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 322
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "Replace",
            "signature": {
              "text": "type Replace<$Object1, $Object2> = Omit<$Object1, keyof $Object2> & $Object2",
              "_tag": "TypeSignatureModel"
            },
            "description": "Replace properties in an object type with new types. Useful for overriding specific property types.",
            "examples": [
              {
                "code": "type User = { id: number; name: string; createdAt: Date }\ntype SerializedUser = Replace<User, { createdAt: string }>\n// Result: { id: number; name: string; createdAt: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "merge",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 341
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "assert",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The value to check"
                    }
                  ],
                  "returnType": "void",
                  "throws": [
                    "TypeError If the value is not an object"
                  ]
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Assert that a value is an object. Throws a TypeError if the value is not an object (including null).",
            "examples": [
              {
                "code": "function process(value: unknown) {\n  Obj.assert(value)\n  // value is now typed as object\n  console.log(Object.keys(value))\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Shape & Validation",
            "tags": {
              "throws": "TypeError If the value is not an object"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 34
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isShape",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "type"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "spec",
                      "type": "Record<PropertyKey, \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\">",
                      "optional": false,
                      "rest": false,
                      "description": "An object mapping property names to their expected typeof results"
                    }
                  ],
                  "returnType": "(value: unknown) => value is type",
                  "returnDoc": "A type predicate function that checks if a value matches the shape",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a type predicate function that checks if a value matches a shape specification. Uses JavaScript's `typeof` operator to validate property types.",
            "examples": [
              {
                "code": "const isUser = isShape<{ name: string; age: number }>({\n  name: 'string',\n  age: 'number'\n})\n\nisUser({ name: 'Alice', age: 30 }) // true\nisUser({ name: 'Bob' }) // false - missing age\nisUser({ name: 'Charlie', age: '30' }) // false - age is string",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Can check for functions and other typeof types\nconst isCallback = isShape<{ fn: Function }>({\n  fn: 'function'\n})",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Shape & Validation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 73
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "setPrivateState",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "obj",
                      "constraint": "Any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "obj",
                      "optional": false,
                      "rest": false,
                      "description": "The object to attach private state to"
                    },
                    {
                      "name": "value",
                      "type": "object",
                      "optional": false,
                      "rest": false,
                      "description": "The state object to attach"
                    }
                  ],
                  "returnType": "obj",
                  "returnDoc": "The original object with private state attached",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Attach private state to an object using a non-enumerable Symbol property. The state is immutable once set and cannot be discovered through enumeration.",
            "examples": [
              {
                "code": "const user = { name: 'Alice' }\nconst privateData = { password: 'secret123' }\n\nsetPrivateState(user, privateData)\n// user still appears as { name: 'Alice' } when logged\n// but has hidden private state accessible via getPrivateState",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful for attaching metadata without polluting the object\nconst config = { timeout: 5000 }\nsetPrivateState(config, {\n  source: 'environment',\n  timestamp: Date.now()\n})",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "State Management",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 116
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "getPrivateState",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "state",
                      "constraint": "Any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "object",
                      "optional": false,
                      "rest": false,
                      "description": "The object to retrieve private state from"
                    }
                  ],
                  "returnType": "state",
                  "returnDoc": "The private state object",
                  "throws": [
                    "Error if no private state is found on the object"
                  ]
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Retrieve private state previously attached to an object with setPrivateState.",
            "examples": [
              {
                "code": "const user = { name: 'Alice' }\nsetPrivateState(user, { role: 'admin' })\n\nconst privateData = getPrivateState<{ role: string }>(user)\nconsole.log(privateData.role) // 'admin'",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe private state retrieval\ninterface Metadata {\n  createdAt: number\n  createdBy: string\n}\n\nconst doc = { title: 'Report' }\nsetPrivateState(doc, { createdAt: Date.now(), createdBy: 'system' })\n\nconst meta = getPrivateState<Metadata>(doc)\n// meta is typed as Metadata",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "State Management",
            "tags": {
              "throws": "Error if no private state is found on the object"
            },
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 159
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "hasNonUndefinedKeys",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "object",
                      "type": "object",
                      "optional": false,
                      "rest": false,
                      "description": "The object to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if at least one value is not undefined",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if an object has any non-undefined values.",
            "examples": [
              {
                "code": "hasNonUndefinedKeys({ a: undefined, b: undefined })  // false\nhasNonUndefinedKeys({ a: undefined, b: 1 })  // true\nhasNonUndefinedKeys({})  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 179
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PartialDeep",
            "signature": {
              "text": "type PartialDeep<$Type> =\n  $Type extends Array<infer __inner__>                  ? Array<PartialDeep<__inner__>> :\n  $Type extends ReadonlyArray<infer __inner__>          ? ReadonlyArray<PartialDeep<__inner__>> :\n  $Type extends Promise<infer __inner__>                ? Promise<PartialDeep<__inner__>> :\n  $Type extends Function                                ? $Type :\n  $Type extends object                                  ? {\n                                                            [key in keyof $Type]?: PartialDeep<$Type[key]>\n                                                          } :\n                                                        // else\n                                                          $Type",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 186
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Writeable",
            "signature": {
              "text": "type Writeable<$Obj extends object> = Writable<$Obj>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Make all properties of an object writable (remove readonly modifiers).",
            "examples": [
              {
                "code": "type ReadonlyUser = { readonly id: number; readonly name: string }\ntype WritableUser = Writeable<ReadonlyUser>\n// Result: { id: number; name: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 224
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ToParameters",
            "signature": {
              "text": "type ToParameters<$Params extends object | undefined> =\n  undefined extends $Params ? [params?: $Params] :\n  $Params extends undefined ? [params?: $Params] :\n                              [params: $Params]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Convert an object to a parameters tuple.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 232
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ToParametersExact",
            "signature": {
              "text": "type ToParametersExact<\n  $Input extends object,\n  $Params extends object | undefined,\n> = IsEmpty<$Input> extends true ? []\n  : ToParameters<$Params>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Convert an object to parameters tuple with exact matching.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 242
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyKeyToString",
            "signature": {
              "text": "type PropertyKeyToString<$Key extends PropertyKey> = $Key extends string ? $Key\n  : $Key extends number ? `${$Key}`\n  : never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Convert PropertyKey to string if possible.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "obj",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 253
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPathExpression",
            "signature": {
              "text": "type PropertyPathExpression = string",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPath",
            "signature": {
              "text": "type PropertyPath = readonly string[]",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 6
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertyPathInput",
            "signature": {
              "text": "type PropertyPathInput = PropertyPathExpression | PropertyPath",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 8
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "normalizePropertyPathInput",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "pathInput",
                      "constraint": "PropertyPathInput"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "pathInput",
                      "type": "pathInput",
                      "optional": false,
                      "rest": false,
                      "description": "Either a dot-notation string or array of property names"
                    }
                  ],
                  "returnType": "normalizePropertyPathInput<pathInput>",
                  "returnDoc": "An array of property names representing the path",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Normalize a property path input to a consistent array format. Accepts either a dot-notation string or an array of property names.",
            "examples": [
              {
                "code": "normalizePropertyPathInput('user.address.city')\n// Returns: ['user', 'address', 'city']",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "normalizePropertyPathInput(['user', 'address', 'city'])\n// Returns: ['user', 'address', 'city'] (unchanged)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Path Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PropertyPathSeparator",
            "signature": {
              "type": "\".\"",
              "_tag": "ValueSignatureModel"
            },
            "description": "The separator character used in property path expressions. Used to split dot-notation paths like 'user.address.city'.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 52
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "parsePropertyPathExpression",
            "signature": {
              "type": "<expression extends string>(expression: expression) => parsePropertyPathExpression<expression>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Parse a dot-notation property path expression into an array of property names.",
            "examples": [
              {
                "code": "parsePropertyPathExpression('user.name')\n// Returns: ['user', 'name']",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "parsePropertyPathExpression('config.server.port')\n// Returns: ['config', 'server', 'port']",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "parsePropertyPathExpression('singleProperty')\n// Returns: ['singleProperty']",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Path Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 81
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "InferShapeFromPropertyPath",
            "signature": {
              "text": "type InferShapeFromPropertyPath<$PropertyPath extends PropertyPath> =\n\t$PropertyPath extends readonly []\n\t\t? {}\n\t\t: _InferShapeFromPropertyPath<$PropertyPath>",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "path",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 92
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Any",
            "signature": {
              "text": "type Any = object",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 4
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsEmpty",
            "signature": {
              "text": "type IsEmpty<$Obj extends object> = keyof $Obj extends never ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level check to determine if an object type has no keys.",
            "examples": [
              {
                "code": "type Empty = IsEmpty<{}> // true\ntype NotEmpty = IsEmpty<{ a: 1 }> // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Empty",
            "signature": {
              "text": "type Empty = Record<string, never>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type for an empty object.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 34
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "SubtractShallow",
            "signature": {
              "text": "type SubtractShallow<$A, $B> = Omit<$A, keyof $B>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Subtract properties present in $B from $A (shallow operation).  \n\nReturns a new object type containing only properties that exist in $A but not in $B. This is equivalent to `Omit<$A, keyof $B>` but expresses the operation as subtraction.",
            "examples": [
              {
                "code": "type User = { name: string; age: number; email: string }\ntype Public = { name: string; age: number }\n\ntype Private = Obj.SubtractShallow<User, Public>  // { email: string }\ntype Same = Obj.SubtractShallow<User, User>        // {}",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Finding what's different between two object types\ntype Config = { id: string; debug?: boolean }\ntype Provided = { id: string; invalid: true; typo: string }\n\ntype Extra = Obj.SubtractShallow<Provided, Config>  // { invalid: true; typo: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities  \n\n $A - The object type to subtract from  $B - The object type whose properties to remove",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "empty",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [],
                  "returnType": "Empty",
                  "returnDoc": "An empty object with type `Record<string, never>`",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create an empty object with proper type. Returns a frozen empty object typed as Empty.",
            "examples": [
              {
                "code": "const opts = options ?? Obj.empty()",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type is properly inferred as Empty\nconst emptyObj = Obj.empty()\ntype T = typeof emptyObj  // Record<string, never>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 87
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "NoExcess",
            "signature": {
              "text": "type NoExcess<$Expected, $Actual> = $Actual & Record<Exclude<keyof $Actual, keyof $Expected>, never>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Enforces that a type has no excess properties beyond those defined in the expected type.  \n\nThis utility intersects the actual type with a record that marks all excess keys as `never`, causing TypeScript to reject values with properties not present in the expected type. Particularly useful in generic contexts where excess property checking is bypassed.",
            "examples": [
              {
                "code": "type User = { name: string; age: number }\n\n// Standard generic - allows excess properties\nfunction test1<T extends User>(input: T): void {}\ntest1({ name: 'Alice', age: 30, extra: true })  //  No error (excess allowed)\n\n// With NoExcess - rejects excess\nfunction test2<T extends User>(input: Obj.NoExcess<User, T>): void {}\ntest2({ name: 'Alice', age: 30, extra: true })  //  Error: 'extra' is never\ntest2({ name: 'Alice', age: 30 })  //  OK",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using with optional properties\ntype Config = { id: string; debug?: boolean }\n\nfunction configure<T extends Config>(config: Obj.NoExcess<Config, T>): void {}\n\nconfigure({ id: 'test' })  //  OK - optional omitted\nconfigure({ id: 'test', debug: true })  //  OK - optional included\nconfigure({ id: 'test', invalid: 'x' })  //  Error: 'invalid' is never",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities  \n\n $Expected - The type defining allowed properties  $Actual - The actual type to check for excess properties",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 140
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "NoExcessNonEmpty",
            "signature": {
              "text": "type NoExcessNonEmpty<$Value extends object, $Constraint> = IsEmpty<$Value> extends true ? never\n  : NoExcess<$Constraint, $Value>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Like NoExcess but also requires the object to be non-empty.  \n\nEnforces that: 1. Object has at least one property (not empty) 2. Object has no excess properties beyond the constraint",
            "examples": [
              {
                "code": "type User = { name: string }\n\ntype T1 = NoExcessNonEmpty<{ name: 'Alice' }, User>        //  Pass\ntype T2 = NoExcessNonEmpty<{}, User>                       //  Fail - empty\ntype T3 = NoExcessNonEmpty<{ name: 'Bob', age: 30 }, User> //  Fail - excess",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 160
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isEmpty",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "object",
                      "optional": false,
                      "rest": false,
                      "description": "The object to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the object has no enumerable properties",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if an object has no enumerable properties.",
            "examples": [
              {
                "code": "isEmpty({}) // true\nisEmpty({ a: 1 }) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Non-enumerable properties are ignored\nconst obj = {}\nObject.defineProperty(obj, 'hidden', { value: 1, enumerable: false })\nisEmpty(obj) // true - non-enumerable properties are ignored",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 195
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isEmpty$",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T",
                      "constraint": "object"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "$T",
                      "optional": false,
                      "rest": false,
                      "description": "The object to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the object has no enumerable properties, with type narrowing to Empty",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type predicate that checks if an object has no enumerable properties. Narrows the type to an empty object type.",
            "examples": [
              {
                "code": "const obj: { a?: number } = {}\nif (isEmpty$(obj)) {\n  // obj is now typed as Empty\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful in conditional type flows\nfunction processObject<T extends object>(obj: T) {\n  if (isEmpty$(obj)) {\n    // obj is Empty here\n    return 'empty'\n  }\n  // obj retains its original type here\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 228
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "HasOptionalKeys",
            "signature": {
              "text": "type HasOptionalKeys<$Obj extends object> = OptionalKeys<$Obj> extends never ? false : true",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if an interface has any optional properties.",
            "examples": [
              {
                "code": "type T1 = HasOptionalKeys<{ a?: string }>  // true\ntype T2 = HasOptionalKeys<{ a: string }>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "OptionalKeys",
            "signature": {
              "text": "type OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Extract keys that are optional in the interface.",
            "examples": [
              {
                "code": "type Obj = { a: string; b?: number; c?: boolean }\ntype Optional = OptionalKeys<Obj>  // 'b' | 'c'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RequiredKeys",
            "signature": {
              "text": "type RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Extract keys that are required in the interface.",
            "examples": [
              {
                "code": "type Obj = { a: string; b?: number; c?: boolean }\ntype Required = RequiredKeys<Obj>  // 'a'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 42
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasRequiredKeys",
            "signature": {
              "text": "type HasRequiredKeys<$Obj extends object> = RequiredKeys<$Obj> extends never ? false : true",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if an interface has any required properties.",
            "examples": [
              {
                "code": "type T1 = HasRequiredKeys<{ a: string }>  // true\ntype T2 = HasRequiredKeys<{ a?: string }>  // false\ntype T3 = HasRequiredKeys<{ a: string; b?: number }>  // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 56
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasOptionalKey",
            "signature": {
              "text": "type HasOptionalKey<$Object extends object, $Key extends keyof $Object> = undefined extends $Object[$Key] ? true\n  : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a key is optional in an object.",
            "examples": [
              {
                "code": "type T1 = HasOptionalKey<{ a?: string }, 'a'>  // true\ntype T2 = HasOptionalKey<{ a: string }, 'a'>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 69
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsKeyOptional",
            "signature": {
              "text": "type IsKeyOptional<$T extends Undefined.Maybe<object>, $K extends string> = $K extends keyof $T\n  ? ({} extends Pick<$T, $K> ? true : false)\n  : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a key is optional in an object.",
            "examples": [
              {
                "code": "type T1 = IsKeyOptional<{ a?: string }, 'a'>  // true\ntype T2 = IsKeyOptional<{ a: string }, 'a'>  // false\ntype T3 = IsKeyOptional<{ a: string }, 'b'>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 84
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "HasKey",
            "signature": {
              "text": "type HasKey<$T extends object, $K extends string> = $K extends keyof $T ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a key exists in an object.",
            "examples": [
              {
                "code": "type T1 = HasKey<{ a: string }, 'a'>  // true\ntype T2 = HasKey<{ a: string }, 'b'>  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "predicates",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 99
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PropertySignature",
            "signature": {
              "text": "type PropertySignature = {\n  name: string\n  type: any\n  optional: boolean\n  optionalUndefined: boolean\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "property-signature",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "mapValues",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "rec",
                      "constraint": "Record<PropertyKey, any>"
                    },
                    {
                      "name": "newValue"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "obj",
                      "type": "rec",
                      "optional": false,
                      "rest": false,
                      "description": "The object to map values from"
                    },
                    {
                      "name": "fn",
                      "type": "(value: rec[keyof rec], key: keyof rec) => newValue",
                      "optional": false,
                      "rest": false,
                      "description": "Function to transform each value, receives the value and key"
                    }
                  ],
                  "returnType": "Record<keyof rec, newValue>",
                  "returnDoc": "A new object with transformed values",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a new object with the same keys but with values transformed by a function.",
            "examples": [
              {
                "code": "const prices = { apple: 1.5, banana: 0.75, orange: 2 }\nconst doublePrices = mapValues(prices, (price) => price * 2)\n// Result: { apple: 3, banana: 1.5, orange: 4 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using the key parameter\nconst data = { a: 1, b: 2, c: 3 }\nconst withKeys = mapValues(data, (value, key) => `${key}: ${value}`)\n// Result: { a: 'a: 1', b: 'b: 2', c: 'c: 3' }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "obj"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "update",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./prom",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "prom"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Promise utilities for asynchronous operations.  \n\nProvides utilities for working with Promises including deferred promise creation, promise combinators, and async control flow patterns.",
        "category": "Error Handling & Values",
        "exports": [
          {
            "name": "Deferred",
            "signature": {
              "text": "interface Deferred<$Value> {\n  /**\n   * The promise that will be resolved or rejected.\n   */\n  promise: Promise<$Value>\n  /**\n   * Resolve the promise with a value.\n   */\n  resolve: (value: $Value) => void\n  /**\n   * Reject the promise with an error.\n   */\n  reject: (error: unknown) => void\n  /**\n   * Whether the promise has been resolved.\n   */\n  readonly isResolved: boolean\n  /**\n   * Whether the promise has been rejected.\n   */\n  readonly isRejected: boolean\n  /**\n   * Whether the promise has been settled (resolved or rejected).\n   */\n  readonly isSettled: boolean\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "A deferred promise with exposed resolve and reject functions.",
            "examples": [
              {
                "code": "const deferred = createDeferred<number>()\n\n// Later resolve it\ndeferred.resolve(42)\n\n// Or reject it\ndeferred.reject(new Error('failed'))\n\n// Use the promise\nawait deferred.promise  // 42",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Check resolution state\nconst deferred = createDeferred<number>()\nconsole.log(deferred.isResolved)  // false\ndeferred.resolve(42)\nconsole.log(deferred.isResolved)  // true\nconsole.log(deferred.isSettled)   // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Deferred",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "deferred",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 30
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "createDeferred",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$T"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "options",
                      "type": "{ strict?: boolean; } | undefined",
                      "optional": true,
                      "rest": false,
                      "description": "Configuration options"
                    }
                  ],
                  "returnType": "Deferred<$T>",
                  "returnDoc": "A deferred promise object",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a deferred promise with exposed resolve and reject functions.",
            "examples": [
              {
                "code": "const deferred = createDeferred<number>()\n\nsetTimeout(() => {\n  deferred.resolve(42)\n}, 1000)\n\nconst result = await deferred.promise  // 42",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Strict mode prevents multiple resolutions\nconst deferred = createDeferred<number>({ strict: true })\n\ndeferred.resolve(1)\ndeferred.resolve(2)  // Throws error",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Deferred",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "deferred",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 86
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "maybeAsync",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "T"
                    },
                    {
                      "name": "R",
                      "default": "T"
                    },
                    {
                      "name": "E",
                      "default": "unknown"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => T",
                      "optional": false,
                      "rest": false,
                      "description": "Function to execute that might return a promise"
                    },
                    {
                      "name": "handlers",
                      "type": "MaybeAsyncHandlers<T extends Promise<infer U> ? U : T, R, E>",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "{}",
                      "description": "Object with then/catch handlers"
                    }
                  ],
                  "returnType": "T extends Promise<infer U> ? Promise<R | E | U> : T | R | E",
                  "returnDoc": "The result, potentially wrapped in a Promise",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Handle a function that might return a promise or a regular value, with unified handlers for both sync and async cases.  \n\nImplemented using maybeAsyncEnvelope internally.",
            "examples": [
              {
                "code": "// Basic usage\nconst result = maybeAsync(\n  () => fetchData(),\n  {\n    then: (data) => processData(data),\n    catch: (error) => ({ success: false, error })\n  }\n)\n\n// Just error handling\nconst safeResult = maybeAsync(\n  () => riskyOperation(),\n  {\n    catch: (error, isAsync) => {\n      console.error(`Failed ${isAsync ? 'async' : 'sync'}:`, error)\n      return null\n    }\n  }\n)\n\n// Just success handling\nconst transformed = maybeAsync(\n  () => getValue(),\n  {\n    then: (value) => value.toUpperCase()\n  }\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 231
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Any",
            "signature": {
              "text": "type Any = Promise<unknown>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type representing a Promise of unknown type. Useful for generic promise handling where the resolved type is not important.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyAny",
            "signature": {
              "text": "type AnyAny = Promise<any>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type representing a Promise of any type. Less type-safe than Any, use with caution.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Maybe",
            "signature": {
              "text": "type Maybe<$Type> = $Type | Promise<$Type>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type representing a value that may or may not be wrapped in a Promise.",
            "examples": [
              {
                "code": "// function that accepts sync or async values\nfunction process<T>(value: Maybe<T>): Promise<T> {\n  return Promise.resolve(value)\n}\n\nprocess(42) // accepts number\nprocess(Promise.resolve(42)) // accepts Promise<number>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "isShape",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The value to test."
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value has Promise-like shape.",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a value has the shape of a Promise. Tests for the presence of then, catch, and finally methods.",
            "examples": [
              {
                "code": "// with a promise\nisShape(Promise.resolve(42)) // true\n\n// with a thenable object\nisShape({ then: () => {}, catch: () => {}, finally: () => {} }) // true\n\n// with non-promise values\nisShape(42) // false\nisShape({}) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 59
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "AwaitedUnion",
            "signature": {
              "text": "type AwaitedUnion<$MaybePromise, $Additional> =\n  $MaybePromise extends Promise<infer __promised__>\n    ? Promise<Awaited<__promised__ | $Additional>>\n    : $MaybePromise | $Additional",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type that adds an additional type to a potentially promised union. If the input is a Promise, the additional type is added to the promised value. If the input is not a Promise, creates a union with the additional type.",
            "examples": [
              {
                "code": "// with promise input\ntype Result1 = AwaitedUnion<Promise<string>, number> // Promise<string | number>\n\n// with non-promise input\ntype Result2 = AwaitedUnion<string, number> // string | number",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 86
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Envelope",
            "signature": {
              "text": "type Envelope<T = unknown> = {\n  fail: boolean\n  value: T\n  async: boolean\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Envelope containing execution metadata.",
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 96
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "maybeAsyncEnvelope",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$return"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "fn",
                      "type": "() => $return",
                      "optional": false,
                      "rest": false,
                      "description": "Function to execute"
                    }
                  ],
                  "returnType": "$return extends Promise<infer __awaited__> ? Promise<Envelope<__awaited__>> : Envelope<$return>",
                  "returnDoc": "Envelope (sync) or Promise of envelope (async) with execution metadata",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Execute a function and return an envelope with metadata about the execution.  \n\nReturns metadata indicating: - **channel**: Whether the function succeeded (`'succeed'`) or failed (`'fail'`) - **async**: Whether execution was asynchronous (promise) or synchronous - **value/error**: The result value or thrown/rejected error  \n\nNever throws or rejects - all errors are captured in the envelope. Preserves sync/async distinction in both return type and metadata.  \n\nUseful when you need to: - Distinguish `Promise.resolve(Error)` from `Promise.reject(Error)` - Know whether execution was sync or async - Handle errors without try/catch blocks",
            "examples": [
              {
                "code": "// Sync success\nconst result = maybeAsyncEnvelope(() => 42)\n// { channel: 'succeed', value: 42, async: false }\n\n// Sync failure\nconst result = maybeAsyncEnvelope(() => { throw new Error('fail') })\n// { channel: 'fail', error: Error('fail'), async: false }\n\n// Async success\nconst result = await maybeAsyncEnvelope(() => Promise.resolve('ok'))\n// { channel: 'succeed', value: 'ok', async: true }\n\n// Async failure\nconst result = await maybeAsyncEnvelope(() => Promise.reject('error'))\n// { channel: 'fail', error: 'error', async: true }\n\n// Promise resolving to Error (not a rejection!)\nconst result = await maybeAsyncEnvelope(() => Promise.resolve(new Error('value')))\n// { channel: 'succeed', value: Error('value'), async: true }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 147
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "MaybeAsyncHandlers",
            "signature": {
              "text": "interface MaybeAsyncHandlers<T, R = T, E = unknown> {\n  /**\n   * Handler for successful values (sync or async).\n   */\n  then?: (value: T) => R\n\n  /**\n   * Handler for errors (sync or async).\n   * @param error - The caught error\n   * @param isAsync - Whether the error occurred asynchronously\n   */\n  catch?: (error: unknown, isAsync: boolean) => E\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Options for handling values that might be promises.",
            "examples": [],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "prom"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "prom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 174
            },
            "_tag": "type",
            "type": "interface"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./rec",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "rec"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Record utilities for working with plain JavaScript objects as dictionaries.  \n\nProvides type-safe operations for records (objects with PropertyKey indexes) including type guards, merging, creation, and index signature manipulation. Strictly validates plain objects, rejecting arrays and class instances.",
        "category": "Collections",
        "exports": [
          {
            "name": "Any",
            "signature": {
              "text": "type Any = AnyKeyTo<unknown>",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 7
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyReadonly",
            "signature": {
              "text": "type AnyReadonly = AnyReadonlyKeyTo<unknown>",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 12
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyKeyTo",
            "signature": {
              "text": "type AnyKeyTo<$Value> = {\n  [key: PropertyKey]: $Value\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "AnyReadonlyKeyTo",
            "signature": {
              "text": "type AnyReadonlyKeyTo<$Value> = {\n  readonly [key: PropertyKey]: $Value\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 24
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Value",
            "signature": {
              "text": "type Value = {\n  [key: PropertyKey]: Lang.Value\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "is",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The value to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value is a plain record object",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a value is a record (plain object only, not class instances or arrays). This is a strict check that only accepts plain objects with Object.prototype.",
            "examples": [
              {
                "code": "is({ a: 1, b: 2 }) // true\nis({}) // true\nis([1, 2, 3]) // false - arrays are not records\nis(null) // false\nis(new Date()) // false - class instances are not plain records\nis(Object.create(null)) // false - not plain Object.prototype",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type guard usage\nfunction processData(data: unknown) {\n  if (is(data)) {\n    // data is typed as Rec.Any\n    Object.keys(data).forEach(key => {\n      console.log(data[key])\n    })\n  }\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 67
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "merge",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "rec1",
                      "constraint": "Any"
                    },
                    {
                      "name": "rec2",
                      "constraint": "Any"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "rec1",
                      "type": "rec1",
                      "optional": false,
                      "rest": false,
                      "description": "The base record to merge into"
                    },
                    {
                      "name": "rec2",
                      "type": "rec2",
                      "optional": false,
                      "rest": false,
                      "description": "The record to merge from"
                    }
                  ],
                  "returnType": "rec1 & rec2",
                  "returnDoc": "A new record with properties from both records merged",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Deep merge two records, with properties from the second record overwriting the first. This is an alias for Obj.merge that works specifically with record types.",
            "examples": [
              {
                "code": "merge({ a: 1, b: 2 }, { b: 3, c: 4 })\n// Returns: { a: 1, b: 3, c: 4 }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Deep merging of nested records\nmerge(\n  { user: { name: 'Alice', settings: { theme: 'dark' } } },\n  { user: { settings: { fontSize: 16 } } }\n)\n// Returns: { user: { name: 'Alice', settings: { theme: 'dark', fontSize: 16 } } }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Type-safe merging\ntype Config = { api: { url: string }; timeout?: number }\ntype Overrides = { api: { key: string }; timeout: number }\n\nconst config: Config = { api: { url: 'https://api.com' } }\nconst overrides: Overrides = { api: { key: 'secret' }, timeout: 5000 }\nconst merged = merge(config, overrides)\n// merged is typed as Config & Overrides",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Operations",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 116
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Optional",
            "signature": {
              "text": "type Optional<$Key extends PropertyKey, $Value> = {\n  [K in $Key]?: $Value\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 123
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RemoveIndex",
            "signature": {
              "text": "type RemoveIndex<$T> = {\n  [k in keyof $T as string extends k ? never : number extends k ? never : k]: $T[k]\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Remove index signatures from an object type. Useful for converting Record types to object types with only known keys.",
            "examples": [
              {
                "code": "type WithIndex = { a: string; b: number; [key: string]: any }\ntype WithoutIndex = RemoveIndex<WithIndex>  // { a: string; b: number }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 139
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsHasIndex",
            "signature": {
              "text": "type IsHasIndex<$T, $Key extends PropertyKey = string> = $Key extends keyof $T ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a type has an index signature.",
            "examples": [
              {
                "code": "type T1 = IsHasIndex<{ [key: string]: any }>  // true\ntype T2 = IsHasIndex<{ a: string }>  // false\ntype T3 = IsHasIndex<{ [key: number]: any }, number>  // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 155
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "create",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    }
                  ],
                  "parameters": [],
                  "returnType": "Record<PropertyKey, value>",
                  "returnDoc": "An empty record typed to hold values of the specified type",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create an empty record with a specific value type. Useful for initializing typed record collections.",
            "examples": [
              {
                "code": "const scores = create<number>()\nscores['alice'] = 95\nscores['bob'] = 87\n// scores is typed as Record<PropertyKey, number>",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Creating typed lookups\ninterface User {\n  id: string\n  name: string\n}\n\nconst userLookup = create<User>()\nuserLookup['u123'] = { id: 'u123', name: 'Alice' }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Useful as accumulator in reduce operations\nconst grouped = items.reduce(\n  (acc, item) => {\n    acc[item.category] = item\n    return acc\n  },\n  create<Item>()\n)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Factories",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "rec"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "rec",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 197
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./str",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "domains",
              "str"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "String utilities for text manipulation and analysis.  \n\nProvides comprehensive string operations including case conversion, splitting, matching, replacement, templating, and character utilities. Features type-safe APIs with strong inference for string literals and patterns.",
        "category": "Core Data Structures",
        "exports": [
          {
            "name": "AxisHand",
            "signature": {
              "text": "export * as AxisHand",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box",
                    "axishand"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "AxisHand",
                  "signature": {
                    "text": "export * as AxisHand",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "AxisHand provides a logical, orientation-aware coordinate system for box model properties.  \n\nUnlike physical coordinates (top/left/etc), AxisHand uses logical properties relative to flow direction: - **main axis**: The primary flow direction (set by orientation) - **cross axis**: Perpendicular to the main axis  \n\nEach axis has **start** and **end** positions, creating a coordinate system that adapts to orientation.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "box",
                          "axishand"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 1
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "box",
                          "axishand"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "axishand",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "AxisHand provides a logical, orientation-aware coordinate system for box model properties.  \n\nUnlike physical coordinates (top/left/etc), AxisHand uses logical properties relative to flow direction: - **main axis**: The primary flow direction (set by orientation) - **cross axis**: Perpendicular to the main axis  \n\nEach axis has **start** and **end** positions, creating a coordinate system that adapts to orientation.",
                    "exports": [
                      {
                        "name": "Logical",
                        "signature": {
                          "text": "type Logical<$value = number> = {\n  mainStart?: $value\n  mainEnd?: $value\n  crossStart?: $value\n  crossEnd?: $value\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "AxisHand provides a logical, orientation-aware coordinate system for box model properties.  \n\nUnlike physical coordinates (top/left/etc), AxisHand uses logical properties relative to flow direction: - **main axis**: The primary flow direction (set by orientation) - **cross axis**: Perpendicular to the main axis  \n\nEach axis has **start** and **end** positions, creating a coordinate system that adapts to orientation.",
                        "examples": [
                          {
                            "code": "// Global number - all sides\nAxisHand.parse(2)\n//  { mainStart: 2, mainEnd: 2, crossStart: 2, crossEnd: 2 }\n\n// Axis shorthands\nAxisHand.parse([2, 4])\n//  { mainStart: 2, mainEnd: 2, crossStart: 4, crossEnd: 4 }\n\n// Binary axis - nested arrays\nAxisHand.parse([[1, 2], [3, 4]])\n//  { mainStart: 1, mainEnd: 2, crossStart: 3, crossEnd: 4 }\n\n// Per-axis array with shorthand\nAxisHand.parse([[1, 2], 4])\n//  { mainStart: 1, mainEnd: 2, crossStart: 4, crossEnd: 4 }\n\n// Object syntax\nAxisHand.parse({ main: [1, 2], cross: 4 })\n//  { mainStart: 1, mainEnd: 2, crossStart: 4, crossEnd: 4 }\n\n// Sparse values\nAxisHand.parse([[2], [, 4]])\n//  { mainStart: 2, crossEnd: 4 }",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "box",
                                "axishand"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "axishand",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 47
                        },
                        "_tag": "type",
                        "type": "type-alias"
                      },
                      {
                        "name": "AxisValue",
                        "signature": {
                          "text": "type AxisValue<$value = number> =\n  | $value // shorthand: both sides\n  | [$value] // [start]\n  | [$value, $value] // [start, end]\n  | [$value, undefined] // [start only]\n  | [undefined, $value] // [end only]\n  | { start?: $value; end?: $value }",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Value specification for a single axis.  \n\nCan be: - A value (shorthand for both start and end) - An array `[start, end]` or sparse `[start]`, `[, end]` - An object with explicit `start` and `end` properties",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "box",
                                "axishand"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "axishand",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 64
                        },
                        "_tag": "type",
                        "type": "union"
                      },
                      {
                        "name": "Input",
                        "signature": {
                          "text": "type Input<$value = number> =\n  | $value // all sides\n  | [$value, $value] // [main, cross] - axis shorthands\n  | [AxisValue<$value>, AxisValue<$value>] // [[main...], [cross...]] - binary axis\n  | [AxisValue<$value>] // [[main...]] - main axis only\n  | { main?: AxisValue<$value>; cross?: AxisValue<$value> } // object with axes\n  | Logical<$value>",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Input format for AxisHand.  \n\nSupports multiple syntaxes for progressive complexity: 1. Global value: `2`  all sides 2. Axis shorthands: `[2, 4]`  [main, cross] 3. Binary axis: `[[1, 2], [3, 4]]`  [[main], [cross]] 4. Sparse binary: `[[2]]`  main only 5. Object syntax: `{ main: [1, 2], cross: 4 }` 6. Explicit logical: `{ mainStart: 1, mainEnd: 2, ... }`",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "box",
                                "axishand"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "axishand",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 85
                        },
                        "_tag": "type",
                        "type": "union"
                      },
                      {
                        "name": "parse",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [
                                {
                                  "name": "$value",
                                  "default": "number"
                                }
                              ],
                              "parameters": [
                                {
                                  "name": "input",
                                  "type": "Input<$value>",
                                  "optional": false,
                                  "rest": false,
                                  "description": "AxisHand input in any supported format"
                                }
                              ],
                              "returnType": "Partial<Logical<$value>>",
                              "returnDoc": "Partial logical properties",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Parse AxisHand input into logical properties.  \n\nHandles all input formats and returns a partial Logical object with only the specified properties.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "box",
                                "axishand"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "axishand",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 102
                        },
                        "_tag": "value",
                        "type": "function"
                      }
                    ]
                  }
                },
                {
                  "name": "Logical",
                  "signature": {
                    "text": "type Logical<$value = number> = {\n  mainStart?: $value\n  mainEnd?: $value\n  crossStart?: $value\n  crossEnd?: $value\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "AxisHand provides a logical, orientation-aware coordinate system for box model properties.  \n\nUnlike physical coordinates (top/left/etc), AxisHand uses logical properties relative to flow direction: - **main axis**: The primary flow direction (set by orientation) - **cross axis**: Perpendicular to the main axis  \n\nEach axis has **start** and **end** positions, creating a coordinate system that adapts to orientation.",
                  "examples": [
                    {
                      "code": "// Global number - all sides\nAxisHand.parse(2)\n//  { mainStart: 2, mainEnd: 2, crossStart: 2, crossEnd: 2 }\n\n// Axis shorthands\nAxisHand.parse([2, 4])\n//  { mainStart: 2, mainEnd: 2, crossStart: 4, crossEnd: 4 }\n\n// Binary axis - nested arrays\nAxisHand.parse([[1, 2], [3, 4]])\n//  { mainStart: 1, mainEnd: 2, crossStart: 3, crossEnd: 4 }\n\n// Per-axis array with shorthand\nAxisHand.parse([[1, 2], 4])\n//  { mainStart: 1, mainEnd: 2, crossStart: 4, crossEnd: 4 }\n\n// Object syntax\nAxisHand.parse({ main: [1, 2], cross: 4 })\n//  { mainStart: 1, mainEnd: 2, crossStart: 4, crossEnd: 4 }\n\n// Sparse values\nAxisHand.parse([[2], [, 4]])\n//  { mainStart: 2, crossEnd: 4 }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "box",
                          "axishand"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "axishand",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "AxisValue",
                  "signature": {
                    "text": "type AxisValue<$value = number> =\n  | $value // shorthand: both sides\n  | [$value] // [start]\n  | [$value, $value] // [start, end]\n  | [$value, undefined] // [start only]\n  | [undefined, $value] // [end only]\n  | { start?: $value; end?: $value }",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Value specification for a single axis.  \n\nCan be: - A value (shorthand for both start and end) - An array `[start, end]` or sparse `[start]`, `[, end]` - An object with explicit `start` and `end` properties",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "box",
                          "axishand"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "axishand",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 64
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "Input",
                  "signature": {
                    "text": "type Input<$value = number> =\n  | $value // all sides\n  | [$value, $value] // [main, cross] - axis shorthands\n  | [AxisValue<$value>, AxisValue<$value>] // [[main...], [cross...]] - binary axis\n  | [AxisValue<$value>] // [[main...]] - main axis only\n  | { main?: AxisValue<$value>; cross?: AxisValue<$value> } // object with axes\n  | Logical<$value>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Input format for AxisHand.  \n\nSupports multiple syntaxes for progressive complexity: 1. Global value: `2`  all sides 2. Axis shorthands: `[2, 4]`  [main, cross] 3. Binary axis: `[[1, 2], [3, 4]]`  [[main], [cross]] 4. Sparse binary: `[[2]]`  main only 5. Object syntax: `{ main: [1, 2], cross: 4 }` 6. Explicit logical: `{ mainStart: 1, mainEnd: 2, ... }`",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "box",
                          "axishand"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "axishand",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 85
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "parse",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "$value",
                            "default": "number"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "input",
                            "type": "Input<$value>",
                            "optional": false,
                            "rest": false,
                            "description": "AxisHand input in any supported format"
                          }
                        ],
                        "returnType": "Partial<Logical<$value>>",
                        "returnDoc": "Partial logical properties",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Parse AxisHand input into logical properties.  \n\nHandles all input formats and returns a partial Logical object with only the specified properties.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "box",
                          "axishand"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "axishand",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 102
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Case",
            "signature": {
              "text": "export * as Case",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "case"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "case"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "case",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "camel",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to camel case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to camel case.",
                        "throws": []
                      },
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to camel case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to camel case.",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Converts a string to camel case.  \n\nCamel case is the naming convention in which the first word is written in lowercase and each subsequent word begins with a capital letter, concatenated without any separator characters.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "camelCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 17
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "kebab",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to kebab case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to kebab case.",
                        "throws": []
                      },
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to kebab case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to kebab case.",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Converts a string to kebab case.  \n\nKebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kebabCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "pascal",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to pascal case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to Pascal case.",
                        "throws": []
                      },
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to pascal case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to Pascal case.",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Converts a string to Pascal case.  \n\nPascal case is the naming convention in which each word is capitalized and concatenated without any separator characters.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "pascalCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "snake",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to snake case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to snake case.",
                        "throws": []
                      },
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string that is to be changed to snake case."
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "string - The converted string to snake case.",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Converts a string to snake case.  \n\nSnake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "node_modules",
                          ".pnpm",
                          "es-toolkit@1.39.10",
                          "node_modules",
                          "es-toolkit",
                          "dist",
                          "string"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "snakeCase.d",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 15
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "constant",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "name",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string to convert"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The constant cased string",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert string to CONSTANT_CASE (SCREAMING_SNAKE_CASE). Commonly used for environment variables and constants.",
                  "examples": [
                    {
                      "code": "constant('helloWorld') // 'HELLO_WORLD'\nconstant('foo-bar') // 'FOO_BAR'\nconstant('myEnvVar') // 'MY_ENV_VAR'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "title",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The string to convert"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The title cased string",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert string to Title Case. Replaces hyphens and underscores with spaces and capitalizes the first letter of each word.",
                  "examples": [
                    {
                      "code": "title('hello-world') // 'Hello World'\ntitle('foo_bar') // 'Foo Bar'\ntitle('the quick brown fox') // 'The Quick Brown Fox'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 75
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "capAll",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "$S",
                            "constraint": "string"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "str",
                            "type": "$S",
                            "optional": false,
                            "rest": false,
                            "description": "The string to convert"
                          }
                        ],
                        "returnType": "Uppercase<$S>",
                        "returnDoc": "The uppercase string with Uppercase type",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert string to UPPERCASE with type-level transformation. Preserves the uppercase type at the type level.",
                  "examples": [
                    {
                      "code": "uppercase('hello')  // Type: \"HELLO\" (not string)\nuppercase('world')  // Type: \"WORLD\"\n\n// Works with plain strings too\nuppercase('hello world') // 'HELLO WORLD'\nuppercase('FooBar') // 'FOOBAR'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 97
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "uncapFirst",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "$S",
                            "constraint": "string"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "s",
                            "type": "$S",
                            "optional": false,
                            "rest": false,
                            "description": "The string to convert"
                          }
                        ],
                        "returnType": "Uncapitalize<$S>",
                        "returnDoc": "The string with lowercase first letter and Uncapitalize type",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert the first letter of a string to lowercase with type-level transformation.",
                  "examples": [
                    {
                      "code": "lowerCaseFirst('Hello')  // Type: \"hello\"\nlowerCaseFirst('World')  // Type: \"world\"\nlowerCaseFirst('HELLO')  // Type: \"hELLO\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 113
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "capFirst",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "$S",
                            "constraint": "string"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "string",
                            "type": "$S",
                            "optional": false,
                            "rest": false,
                            "description": "The string to capitalize"
                          }
                        ],
                        "returnType": "Capitalize<$S>",
                        "returnDoc": "The string with capitalized first letter and Capitalize type",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Capitalize the first letter of a string with type-level transformation.",
                  "examples": [
                    {
                      "code": "capitalizeFirst('hello')  // Type: \"Hello\"\ncapitalizeFirst('world')  // Type: \"World\"\ncapitalizeFirst('foo bar')  // Type: \"Foo bar\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Case Conversion",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "case"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "case",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 129
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Char",
            "signature": {
              "text": "export * as Char",
              "_tag": "TypeSignatureModel"
            },
            "description": "Uppercase letter.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "char"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "char"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "char",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Uppercase letter.",
              "category": "Character Types",
              "exports": [
                {
                  "name": "LetterUpper",
                  "signature": {
                    "text": "type LetterUpper =\n  | 'A'\n  | 'B'\n  | 'C'\n  | 'D'\n  | 'E'\n  | 'F'\n  | 'G'\n  | 'H'\n  | 'I'\n  | 'J'\n  | 'K'\n  | 'L'\n  | 'M'\n  | 'N'\n  | 'O'\n  | 'P'\n  | 'Q'\n  | 'R'\n  | 'S'\n  | 'T'\n  | 'U'\n  | 'V'\n  | 'W'\n  | 'X'\n  | 'Y'\n  | 'Z'",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Uppercase letter.",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 13
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "LetterLower",
                  "signature": {
                    "text": "type LetterLower =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z'",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Lowercase letter.",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 45
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "Letter",
                  "signature": {
                    "text": "type Letter = LetterLower | LetterUpper",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Any letter (uppercase or lowercase).",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 77
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "Digit",
                  "signature": {
                    "text": "type Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Digit character.",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 83
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "HexLetterUpper",
                  "signature": {
                    "text": "type HexLetterUpper = 'A' | 'B' | 'C' | 'D' | 'E' | 'F'",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Hexadecimal letter (uppercase).  \n\nRepresents hex digits A-F in base-16 (values 10-15 in decimal).",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 94
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "HexLetterLower",
                  "signature": {
                    "text": "type HexLetterLower = 'a' | 'b' | 'c' | 'd' | 'e' | 'f'",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Hexadecimal letter (lowercase).  \n\nRepresents hex digits a-f in base-16 (values 10-15 in decimal).",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 105
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "HexLetter",
                  "signature": {
                    "text": "type HexLetter = HexLetterUpper | HexLetterLower",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Hexadecimal letter (uppercase or lowercase).  \n\nRepresents hex digits A-F or a-f in base-16 (values 10-15 in decimal).",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 115
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "HexDigit",
                  "signature": {
                    "text": "type HexDigit = Digit | HexLetter",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Hexadecimal digit (0-9, A-F, a-f).  \n\nRepresents a single character in base-16 (hexadecimal) number system. Used for colors (#FF5733), memory addresses, data encoding, etc.",
                  "examples": [],
                  "category": "Character Types",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 128
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "spaceNoBreak",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Non-breaking space character (U+00A0). A space character that prevents line breaks at its position.",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 144
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "spaceRegular",
                  "signature": {
                    "type": "\" \"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Regular space character (U+0020). The standard space character.",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 152
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "newline",
                  "signature": {
                    "type": "\"\\n\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Line feed (newline) character. Used to create line breaks in text.",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 159
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "bullet",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Bullet character (U+2022). Standard bullet point symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 167
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "middleDot",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Middle dot character (U+00B7). Centered dot symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 175
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "blackCircle",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 186
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "whiteBullet",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "White bullet character (U+25E6). Hollow circle symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 194
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "inverseBullet",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Inverse bullet character (U+25D8). Inverse white circle symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 202
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "squareWithLeftHalfBlack",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Square with left half black character (U+25E7). Half-filled square symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 210
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "rightwardsArrow",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Rightwards arrow character (U+2192). Right-pointing arrow symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 218
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "pipe",
                  "signature": {
                    "type": "\"|\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Vertical bar (pipe) character (U+007C). Vertical line symbol: |",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 226
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "boxDrawingHorizontal",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Box drawing horizontal line character (U+2500). Horizontal line symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 234
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "boxDrawingHorizontalHeavy",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Box drawing heavy horizontal line character (U+2501). Bold horizontal line symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 242
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "boxDrawingVertical",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Box drawing vertical line character (U+2502). Vertical line symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 250
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "boxDrawingDownRight",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Box drawing down and right character (U+250C). Top-left corner symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 258
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "boxDrawingDownLeft",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Box drawing down and left character (U+2510). Top-right corner symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 266
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "boxDrawingUpRight",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Box drawing up and right character (U+2514). Bottom-left corner symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 274
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "boxDrawingUpLeft",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Box drawing up and left character (U+2518). Bottom-right corner symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 282
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "ballotX",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Ballot X character (U+2717). X mark symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 290
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "multiplicationX",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Multiplication X character (U+2715). Multiplication X symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 298
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "checkMark",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Check mark character (U+2713). Check symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 306
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "blackSquare",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Black square character (U+25A0). Filled square symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 314
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "whiteCircle",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "White circle character (U+25CB). Hollow circle symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 322
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "blackUpPointingTriangle",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Black up-pointing triangle character (U+25B2). Filled upward triangle symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 330
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "emDash",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Em dash character (U+2014). Long dash symbol: ",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 338
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "exclamation",
                  "signature": {
                    "type": "\"!\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Exclamation mark character. Often used for negation or emphasis: !",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 345
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "colon",
                  "signature": {
                    "type": "\":\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Colon character. Often used as a separator or delimiter: :",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 352
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "comma",
                  "signature": {
                    "type": "\",\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Comma character. Often used as a list separator: ,",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 359
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "asterisk",
                  "signature": {
                    "type": "\"*\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Asterisk character. Often used as a wildcard or multiplication symbol: *",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 366
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "at",
                  "signature": {
                    "type": "\"@\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "At sign character. Often used in email addresses and mentions:",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 373
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "plus",
                  "signature": {
                    "type": "\"+\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Plus sign character. Used for addition or positive values: +",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 380
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "hyphen",
                  "signature": {
                    "type": "\"-\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Hyphen/minus character. Used for subtraction, ranges, or negative values: -",
                  "examples": [],
                  "category": "Character Constants",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "char"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "char",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 387
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "name": "Nat",
            "signature": {
              "text": "export * as Nat",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "nat"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "nat"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "nat",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "pluralize",
                  "signature": {
                    "type": "{ (word: string, count?: number | undefined, inclusive?: boolean | undefined): string; plural(word: string): string; singular(word: string): string; addPluralRule(rule: Rule, replacement: string): void; addSingularRule(rule: Rule, replacement: string): void; addIrregularRule(single: string, plural: string): void; addUncountableRule(rule: Rule): void; isPlural(word: string): boolean; isSingular(word: string): boolean; }",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 4
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "plural",
                  "signature": {
                    "type": "(word: string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 5
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "singular",
                  "signature": {
                    "type": "(word: string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 6
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "isPlural",
                  "signature": {
                    "type": "(word: string) => boolean",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 7
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "isSingular",
                  "signature": {
                    "type": "(word: string) => boolean",
                    "_tag": "ValueSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 8
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "list",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "items",
                            "type": "string[]",
                            "optional": false,
                            "rest": false,
                            "description": "Array of strings to format"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "Formatted list string",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Format an array as an English list with commas and \"or\".",
                  "examples": [
                    {
                      "code": "list([]) // ''\nlist(['a']) // 'a'\nlist(['a', 'b']) // 'a or b'\nlist(['a', 'b', 'c']) // 'a, b, or c'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Natural Language",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 23
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "ordinal",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "n",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Number to convert"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "Ordinal string (e.g., \"1st\", \"2nd\", \"3rd\", \"21st\")",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Convert a number to its ordinal string representation.",
                  "examples": [
                    {
                      "code": "ordinal(1) // '1st'\nordinal(2) // '2nd'\nordinal(3) // '3rd'\nordinal(11) // '11th'\nordinal(21) // '21st'\nordinal(42) // '42nd'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Natural Language",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 45
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "article",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "word",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "Word to get article for"
                          }
                        ],
                        "returnType": "\"a\" | \"an\"",
                        "returnDoc": "\"a\" or \"an\"",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Determine the correct indefinite article (\"a\" or \"an\") for a word.",
                  "examples": [
                    {
                      "code": "article('apple') // 'an'\narticle('banana') // 'a'\narticle('hour') // 'an' (irregular)\narticle('unicorn') // 'a' (irregular)\narticle('university') // 'a' (irregular)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Natural Language",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "nat"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "nat",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 209
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Tpl",
            "signature": {
              "text": "export * as Tpl",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "tpl"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "tpl"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "tpl",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Tpl",
                  "signature": {
                    "text": "type Tpl = TemplateStringsArray",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Convenience re-export of the built-in TemplateStringsArray type. Contains the string parts of a tagged template literal along with a `raw` property.",
                  "examples": [
                    {
                      "code": "function tag(strings: Tpl.Array, ...values: unknown[]) {\n  // strings is TemplateStringsArray\n  // strings[0] = \"Hello \"\n  // strings[1] = \"!\"\n  // strings.raw contains raw string values\n}\ntag`Hello ${name}!`",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 19
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "is",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "Value to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if value is a TemplateStringsArray",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type guard to check if a value is a TemplateStringsArray. Used to detect when a function is called as a tagged template literal.",
                  "examples": [
                    {
                      "code": "function tag(...args: unknown[]) {\n  if (isArray(args[0])) {\n    // Called as tag`template`\n  } else {\n    // Called as tag()\n  }\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 38
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "CallInput",
                  "signature": {
                    "text": "type CallInput = [Tpl, ...unknown[]]",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Tagged template literal arguments tuple. First element is the template strings array, followed by interpolated values.",
                  "examples": [
                    {
                      "code": "function tag(...args: unknown[]) {\n  if (isArgs(args)) {\n    const [strings, ...values] = args\n    // Process template literal\n  }\n}\ntag`Hello ${name}!`",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 57
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "isCallInput",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "value",
                            "type": "unknown",
                            "optional": false,
                            "rest": false,
                            "description": "Function arguments to check"
                          }
                        ],
                        "returnType": "boolean",
                        "returnDoc": "True if args are tagged template literal arguments",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Type guard to check if function arguments are from a tagged template literal.",
                  "examples": [
                    {
                      "code": "function tag(...args: unknown[]) {\n  if (isArgs(args)) {\n    const [strings, ...values] = args\n    // Process as template literal\n  }\n}\ntag`Hello ${name}!`",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 75
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "Call",
                  "signature": {
                    "text": "interface Call {\n  template: Tpl\n  args: unknown[]\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 79
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "normalizeCall",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "callInput",
                            "type": "CallInput",
                            "optional": false,
                            "rest": false,
                            "description": "Tagged template literal arguments"
                          }
                        ],
                        "returnType": "Call",
                        "returnDoc": "Object with parts (TemplateStringsArray) and values (unknown[])",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Parse tagged template literal arguments into structured parts and values.",
                  "examples": [
                    {
                      "code": "function tag(...args: unknown[]) {\n  if (isArgs(args)) {\n    const { parts, values } = parse(args)\n    // parts[0] = \"Hello \"\n    // parts[1] = \"!\"\n    // values[0] = name\n  }\n}\ntag`Hello ${name}!`",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 102
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "renderWith",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "mapper",
                            "type": "(value: unknown) => string",
                            "optional": false,
                            "rest": false,
                            "description": "Function to convert interpolated values to strings"
                          }
                        ],
                        "returnType": "(callInput: CallInput) => string",
                        "returnDoc": "Function that takes template args and returns rendered string",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Render tagged template literal arguments using a custom value renderer.",
                  "examples": [
                    {
                      "code": "// Custom renderer for JSON values\nconst renderJson = renderWith(v => JSON.stringify(v))\nfunction tag(...args: unknown[]) {\n  if (isArgs(args)) return renderJson(args)\n}\ntag`Value: ${{ foo: 'bar' }}` // \"Value: {\\\"foo\\\":\\\"bar\\\"}\"\n\n// Custom renderer that prefixes values\nconst renderPrefixed = renderWith(v => `[${v}]`)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 125
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "render",
                  "signature": {
                    "type": "(callInput: CallInput) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Render tagged template literal arguments to a string. Interpolated values are converted using plain `String()` coercion.",
                  "examples": [
                    {
                      "code": "function tag(...args: unknown[]) {\n  if (isArgs(args)) {\n    return render(args)\n  }\n}\ntag`Hello ${name}!` // \"Hello World!\"\ntag`Count: ${42}` // \"Count: 42\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 150
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "passthrough",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "strings",
                            "type": "TemplateStringsArray",
                            "optional": false,
                            "rest": false,
                            "description": "Template string parts"
                          },
                          {
                            "name": "values",
                            "type": "unknown[]",
                            "optional": true,
                            "rest": true,
                            "description": "Interpolated values"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The composed string with values interpolated",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "A passthrough tagged template literal that returns the interpolated string as-is. Useful for semantic clarity in code without any processing.",
                  "examples": [
                    {
                      "code": "const template = passthrough\nconst message = template`Hello ${name}, you have ${count} items.`\n// Result: \"Hello Alice, you have 5 items.\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 166
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "dedent",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "strings",
                            "type": "TemplateStringsArray",
                            "optional": false,
                            "rest": false,
                            "description": "Template string parts (uses raw strings to preserve escapes)"
                          },
                          {
                            "name": "values",
                            "type": "unknown[]",
                            "optional": true,
                            "rest": true,
                            "description": "Interpolated values"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "Dedented string with common indentation removed",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Tagged template literal that removes common indentation from all lines. Automatically indents multi-line interpolated values to match their context.  \n\nUses the raw template strings to preserve escape sequences (e.g., `\\n` stays as backslash-n). Trims leading and trailing blank lines from the result.",
                  "examples": [
                    {
                      "code": "const code = dedent`\n  function greet() {\n    console.log('Hello')\n  }\n`\n// Result: \"function greet() {\\n  console.log('Hello')\\n}\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Multi-line values are auto-indented\nconst inner = 'line1\\nline2'\nconst code = dedent`\n  outer:\n    ${inner}\n`\n// Result: \"outer:\\n  line1\\n  line2\"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Escape sequences are preserved\nconst path = dedent`\n  C:\\Users\\name\\Documents\n`\n// Result: \"C:\\\\Users\\\\name\\\\Documents\" (backslashes preserved)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 209
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "HighlightTag",
                  "signature": {
                    "text": "type HighlightTag = typeof passthrough",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Type for a tagged template literal function used for syntax highlighting.",
                  "examples": [],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 250
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "highlight",
                  "signature": {
                    "type": "{ ts: (strings: TemplateStringsArray, ...values: unknown[]) => string; js: (strings: TemplateStringsArray, ...values: unknown[]) => string; html: (strings: TemplateStringsArray, ...values: unknown[]) => string; css: (strings: TemplateStringsArray, ...values: unknown[]) => string; sql: (strings: TemplateStringsArray, ...values: unknown[]) => string; json: (strings: TemplateStringsArray, ...values: unknown[]) => string; yaml: (strings: TemplateStringsArray, ...values: unknown[]) => string; yml: (strings: TemplateStringsArray, ...values: unknown[]) => string; graphql: (strings: TemplateStringsArray, ...values: unknown[]) => string; gql: (strings: TemplateStringsArray, ...values: unknown[]) => string; iso: (strings: TemplateStringsArray, ...values: unknown[]) => string; }",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Object containing language-specific template tag functions for syntax highlighting. Each property is a tagged template function that provides editor syntax highlighting for that language (when supported by the editor).  \n\n**Automatically dedents content** - Removes common indentation and trims blank lines, allowing you to write naturally indented template literals in your source code while producing clean output. Relative indentation is preserved.  \n\nImplemented as a Proxy that returns the same dedent function for all properties, allowing destructuring and property access to work seamlessly.  \n\nSupported languages are based on common supported editor injection patterns:",
                  "examples": [
                    {
                      "code": "import { Str } from '@wollybeard/kit'\n\nconst { ts, html, sql } = Str.Tpl.highlight\n\n// Source indentation is automatically removed\nconst code = ts`\n  export const add = (a: number, b: number) => {\n    return a + b\n  }\n`\n// Result: \"export const add = (a: number, b: number) => {\\n  return a + b\\n}\"\n// ^ Clean output with relative indentation preserved\n\nconst markup = html`\n  <div class=\"container\">\n    <h1>Title</h1>\n  </div>\n` // Gets HTML syntax highlighting, auto-dedented\n\nconst query = sql`\n  SELECT * FROM users\n  WHERE id = ${userId}\n` // Gets SQL syntax highlighting, auto-dedented",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Template",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "tpl"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tpl",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 297
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "name": "Code",
            "signature": {
              "text": "export * as Code",
              "_tag": "TypeSignatureModel"
            },
            "description": "Code generation and documentation utilities.  \n\nProvides tools for generating markdown, TSDoc/JSDoc, and TypeScript code. Includes safe JSDoc generation with escaping, builder API, and structured tag helpers.",
            "examples": [],
            "category": "Code Generation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 20
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "code"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Md",
                  "signature": {
                    "text": "export * as Md",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Markdown string utilities for code documentation.  \n\nProvides functions for generating markdown elements like inline code, links, and tables.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "code"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 2
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "code",
                          "md"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "",
                    "exports": [
                      {
                        "name": "Raw",
                        "signature": {
                          "text": "interface Raw {\n  readonly __markdownFormatted: true\n  readonly content: string\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Branded type for markdown content that's already formatted and safe.  \n\nUse raw to create values of this type.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 21
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "raw",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "content",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "Raw",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Mark content as already-formatted markdown (won't be processed further).  \n\nUse this for pre-formatted markdown syntax that should be injected as-is.",
                        "examples": [
                          {
                            "code": "const formattedLink = raw('[Example](https://example.com)')\nconst doc = builder()\ndoc`Check out ${formattedLink}`",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 38
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "code",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "value",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Wrap value in markdown inline code (backticks).",
                        "examples": [
                          {
                            "code": "code('hello') // '`hello`'\ncode('Array<T>') // '`Array<T>`'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 56
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "link",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "url",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                },
                                {
                                  "name": "text",
                                  "type": "string | undefined",
                                  "optional": true,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a markdown inline link.  \n\nIf text is not provided, the URL is used as both the link text and target.",
                        "examples": [
                          {
                            "code": "link('https://example.com', 'Example')\n// '[Example](https://example.com)'\n\nlink('https://example.com')\n// '[https://example.com](https://example.com)'\n\n// Compose for bold code links:\nlink('/api/foo', `**${code('Foo')}**`)\n// '[**`Foo`**](/api/foo)'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 76
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "heading",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "level",
                                  "type": "number",
                                  "optional": false,
                                  "rest": false
                                },
                                {
                                  "name": "text",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a markdown heading.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 88
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "codeFence",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "code",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                },
                                {
                                  "name": "language",
                                  "type": "string",
                                  "optional": true,
                                  "rest": false,
                                  "defaultValue": "'typescript'"
                                },
                                {
                                  "name": "modifiers",
                                  "type": "string | undefined",
                                  "optional": true,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a code fence with optional language and modifiers.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 95
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "codeGroup",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "tabs",
                                  "type": "{ label: string; code: string; language?: string; modifiers?: string; }[]",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a VitePress code group with multiple tabs.",
                        "examples": [
                          {
                            "code": "codeGroup([\n  { label: 'npm', code: 'npm install foo', language: 'bash' },\n  { label: 'pnpm', code: 'pnpm add foo', language: 'bash' }\n])",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 111
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "container",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "type",
                                  "type": "\"warning\" | \"tip\" | \"info\" | \"danger\"",
                                  "optional": false,
                                  "rest": false
                                },
                                {
                                  "name": "title",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                },
                                {
                                  "name": "content",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a VitePress custom container (warning, tip, etc.).",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 126
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "deprecation",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "message",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a deprecation warning with proper link conversion.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 133
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "listItem",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "text",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                },
                                {
                                  "name": "level",
                                  "type": "number",
                                  "optional": true,
                                  "rest": false,
                                  "defaultValue": "0"
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create an unordered list item.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 140
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "sub",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "text",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a sub-text annotation (smaller font).",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 148
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "convertJSDocLinks",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "text",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Convert JSDoc  tags to markdown links.  \n\nPatterns: - Identifier  [`Identifier`](url) -   [description](url)  \n\nFor Effect library references (String.*, Array.*, etc.), links to Effect documentation.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 161
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "demoteHeadings",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "markdown",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false,
                                  "description": "The markdown content to transform"
                                },
                                {
                                  "name": "levels",
                                  "type": "number",
                                  "optional": false,
                                  "rest": false,
                                  "description": "Number of heading levels to add (e.g., 2 transforms ## to ####)"
                                }
                              ],
                              "returnType": "string",
                              "returnDoc": "Transformed markdown with demoted headings",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Demote markdown headings by adding a specified number of levels.  \n\nThis is used to ensure JSDoc descriptions don't break the document hierarchy. For example, if an export is h3, its description headings should be h4+.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 190
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "sections",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "parts",
                                  "type": "(string | false | null | undefined)[]",
                                  "optional": true,
                                  "rest": true
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Join markdown sections with double newlines, filtering out empty sections.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 204
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "kebab",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "str",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Convert string to kebab-case.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 211
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "table",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "rows",
                                  "type": "Record<string, string | null | undefined>",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate a markdown table from key-value pairs.  \n\nAutomatically filters out undefined and null values. Returns empty string if no valid entries remain after filtering.",
                        "examples": [
                          {
                            "code": "table({\n  'Name': 'Alice',\n  'Age': '30',\n  'City': undefined  // filtered out\n})\n// | | |\n// | - | - |\n// | **Name** | Alice |\n// | **Age** | 30 |",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 236
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "md",
                        "signature": {
                          "text": "export namespace md {\n  /**\n   * Create a markdown heading.\n   * Returns Raw for injection into builder.\n   */\n  export const heading = (level: number, text: string): Raw => {\n    return raw(`${'#'.repeat(level)} ${text}`)\n  }\n\n  /**\n   * Create an inline code span.\n   * Returns Raw for injection.\n   */\n  export const code = (text: string): Raw => {\n    return raw(`\\`${text}\\``)\n  }\n\n  /**\n   * Create a markdown link.\n   * Returns Raw for injection.\n   * If text is not provided, url is used as both text and URL.\n   *\n   * Compose for bold code links: `link(url, \\`**\\${code(text)}**\\`)`\n   */\n  export const link = (url: string, text?: string): Raw => {\n    if (text === undefined) {\n      return raw(`[${url}](${url})`)\n    }\n    return raw(`[${text}](${url})`)\n  }\n\n  /**\n   * Create a code fence.\n   * Returns null if code is null/undefined.\n   */\n  export const codeFence = (\n    code: string | null | undefined,\n    language = 'typescript',\n    modifiers?: string,\n  ): Raw | null => {\n    if (code === null || code === undefined) return null\n    const fence = modifiers ? `${language} ${modifiers}` : language\n    return raw(`\\`\\`\\`${fence}\\n${code}\\n\\`\\`\\``)\n  }\n\n  /**\n   * Create a list item.\n   * Returns Raw for injection.\n   */\n  export const listItem = (text: string, level = 0): Raw => {\n    const indent = '  '.repeat(level)\n    return raw(`${indent}- ${text}`)\n  }\n\n  /**\n   * Create a VitePress container.\n   * Returns null if content is null/undefined.\n   */\n  export const container = (\n    type: 'warning' | 'tip' | 'info' | 'danger',\n    title: string,\n    content: string | null | undefined,\n  ): Raw | null => {\n    if (!content) return null\n    return raw(`:::${type} ${title}\\n${content}\\n:::`)\n  }\n\n  /**\n   * Create a deprecation warning.\n   * Returns null if message is null/undefined.\n   */\n  export const deprecation = (message: string | null | undefined): Raw | null => {\n    if (!message) return null\n    return container('warning', 'DEPRECATED', message)\n  }\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Structured markdown helpers.  \n\nThese helpers generate properly formatted markdown elements. All helpers return `Raw` (already formatted) or `null` for graceful handling.",
                        "examples": [
                          {
                            "code": "md.heading(2, 'API Reference')\nmd.link('Example', 'https://example.com')\nmd.codeFence('const x = 1', 'typescript')",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 266
                        },
                        "_tag": "value",
                        "type": "namespace",
                        "module": {
                          "location": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "description": "Structured markdown helpers.  \n\nThese helpers generate properly formatted markdown elements. All helpers return `Raw` (already formatted) or `null` for graceful handling.",
                          "exports": []
                        }
                      },
                      {
                        "name": "Builder",
                        "signature": {
                          "text": "interface Builder {\n  /**\n   * Add a line to the markdown via tagged template.\n   * Use empty template for blank lines: `doc\\`\\``\n   */\n  (strings: TemplateStringsArray, ...values: Array<string | number | Raw | null | undefined>): Builder\n\n  /**\n   * Add content directly. Skips if null/undefined.\n   * Perfect for chaining with optional content.\n   *\n   * @example\n   * ```ts\n   * doc\n   *   .add(description)  // skips if null/undefined\n   *   .add('## Info')\n   * ```\n   */\n  add(content: string | null | undefined): Builder\n\n  /**\n   * Add raw formatted markdown without processing. Skips if null/undefined.\n   *\n   * @example\n   * ```ts\n   * doc.addRaw(preFormattedMarkdown)\n   * ```\n   */\n  addRaw(content: string | null | undefined): Builder\n\n  /**\n   * Add a blank line.\n   *\n   * @example\n   * ```ts\n   * doc\n   *   .add('First paragraph')\n   *   .blank()\n   *   .add('Second paragraph')\n   * ```\n   */\n  blank(): Builder\n\n  /**\n   * Add a markdown heading.\n   *\n   * @example\n   * ```ts\n   * doc.heading(2, 'API Reference')\n   * ```\n   */\n  heading(level: number, text: string): Builder\n\n  /**\n   * Add a markdown link.\n   * If text is not provided, url is used as both text and URL.\n   *\n   * @example\n   * ```ts\n   * doc.link('https://example.com', 'Example')\n   * doc.link('https://example.com')  // text defaults to URL\n   * // Compose for bold code: doc`[**\\`Foo\\`**](/api/foo)`\n   * ```\n   */\n  link(url: string, text?: string): Builder\n\n  /**\n   * Add a code fence with optional language.\n   * Skips if code is null/undefined.\n   *\n   * @example\n   * ```ts\n   * doc.codeFence('const x = 1', 'typescript')\n   * ```\n   */\n  codeFence(code: string | null | undefined, language?: string, modifiers?: string): Builder\n\n  /**\n   * Add a VitePress code group with multiple tabs.\n   *\n   * @example\n   * ```ts\n   * doc.codeGroup([\n   *   { label: 'npm', code: 'npm install foo', language: 'bash' },\n   *   { label: 'pnpm', code: 'pnpm add foo', language: 'bash' }\n   * ])\n   * ```\n   */\n  codeGroup(tabs: Array<{ label: string; code: string; language?: string; modifiers?: string }>): Builder\n\n  /**\n   * Add a list item.\n   *\n   * @example\n   * ```ts\n   * doc.listItem('First item')\n   * doc.listItem('Nested item', 1)\n   * ```\n   */\n  listItem(text: string, level?: number): Builder\n\n  /**\n   * Add a markdown table from key-value pairs.\n   * Automatically filters out undefined/null values.\n   *\n   * @example\n   * ```ts\n   * doc.table({\n   *   'Type': 'string',\n   *   'Required': 'Yes'\n   * })\n   * ```\n   */\n  table(rows: Record<string, string | Raw | undefined | null>): Builder\n\n  /**\n   * Add a VitePress container.\n   *\n   * @example\n   * ```ts\n   * doc.container('warning', 'Deprecated', 'Use newMethod() instead')\n   * ```\n   */\n  container(type: 'warning' | 'tip' | 'info' | 'danger', title: string, content: string): Builder\n\n  /**\n   * Build the final markdown string with whitespace normalization.\n   */\n  build(): string\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Markdown builder interface for imperative markdown construction.  \n\nProvides a fluent API for building markdown with conditionals, loops, and helpers.",
                        "examples": [
                          {
                            "code": "const doc = builder()\n\ndoc`# API Reference`\ndoc.blank()\ndoc`Main description here.`\n\nif (showTable) {\n  doc.table({ 'Type': 'string', 'Required': 'Yes' })\n}\n\ndoc.codeFence('const x = 1', 'typescript')\n\nreturn doc.build()",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 369
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "builder",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [],
                              "returnType": "Builder",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a new markdown builder for imperative construction.  \n\nPerfect for markdown generation with conditionals, loops, and complex logic.",
                        "examples": [
                          {
                            "code": "const doc = builder()\n\ndoc`# ${title}`\ndoc.blank()\ndoc`Main description`\n\nif (showExample) {\n  doc.codeFence('const x = 1', 'ts')\n}\n\nreturn doc.build()",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 520
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "Template",
                        "signature": {
                          "text": "interface Template {\n  /**\n   * Tagged template for building markdown content.\n   *\n   * @example\n   * ```ts\n   * const doc = template`\n   *   # ${title}\n   *\n   *   ${description}\n   *\n   *   ${md.link('Example', 'https://example.com')}\n   * `\n   * ```\n   */\n  (strings: TemplateStringsArray, ...values: Array<string | number | Raw | null | undefined>): string\n\n  /**\n   * Create a new markdown builder for imperative construction.\n   */\n  builder: typeof builder\n\n  /**\n   * Create a markdown generator function from a builder callback.\n   * Automatically calls `.build()` and returns the result.\n   *\n   * @example\n   * ```ts\n   * export const getDoc = factory<[title: string, items: string[]]>((doc, title, items) => {\n   *   doc.heading(1, title)\n   *   doc.blank()\n   *   items.forEach(item => doc.listItem(item))\n   * })\n   *\n   * // Usage: getDoc('My Title', ['item1', 'item2']) -> string\n   * ```\n   */\n  factory: <$Args extends any[]>(fn: (doc: Builder, ...args: $Args) => void) => (...args: $Args) => string\n\n  /**\n   * Markdown element helpers for generating formatted elements.\n   */\n  md: typeof md\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Markdown template function type with builder property.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 689
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "template",
                        "signature": {
                          "type": "Template",
                          "_tag": "ValueSignatureModel"
                        },
                        "description": "Tagged template for building markdown content. Also provides `.builder()` for imperative construction and `.md` for element helpers.",
                        "examples": [
                          {
                            "code": "// Template mode\nconst doc = template`\n  # API Reference\n\n  ${description}\n\n  ${template.md.link('Docs', 'https://example.com')}\n`\n\n// Builder mode for complex logic\nconst doc = template.builder()\ndoc.heading(1, 'API Reference')\ndoc.blank()\nif (hasDescription) {\n  doc.add(description)\n}\nreturn doc.build()",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "md"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "md",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 759
                        },
                        "_tag": "value",
                        "type": "const"
                      }
                    ]
                  }
                },
                {
                  "name": "TSDoc",
                  "signature": {
                    "text": "export * as TSDoc",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "TSDoc/JSDoc string utilities for code documentation.  \n\nProvides safe JSDoc generation with automatic escaping, builder API, and structured tag helpers.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "code"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 12
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "code",
                          "tsdoc"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "",
                    "exports": [
                      {
                        "name": "escape",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "content",
                                  "type": "string | null | undefined",
                                  "optional": false,
                                  "rest": false,
                                  "description": "User-provided text (e.g., GraphQL descriptions)"
                                }
                              ],
                              "returnType": "string | null",
                              "returnDoc": "Escaped content safe for JSDoc, or null if input was null/undefined",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Escape user-provided content for safe inclusion in JSDoc comments.  \n\nEscapes characters that could break JSDoc syntax: - `*\\/` - Ends the JSDoc comment prematurely - `@tag` at line start - Could be interpreted as JSDoc tags",
                        "examples": [
                          {
                            "code": "escape('Hello * / World')\n// 'Hello * / World'\n\nescape('@deprecated use new API')\n// '\\\\@deprecated use new API'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 36
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "format",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "content",
                                  "type": "string | null",
                                  "optional": false,
                                  "rest": false,
                                  "description": "Content to format as JSDoc"
                                }
                              ],
                              "returnType": "string",
                              "returnDoc": "Formatted JSDoc comment block",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Format content as JSDoc comment block.  \n\nTakes text content and wraps it in JSDoc syntax with proper indentation. Lines are trimmed and prefixed with JSDoc comment markers. Returns empty string if content is null.",
                        "examples": [
                          {
                            "code": "format('Hello\\nWorld')\n// /**\n//  * Hello\n//  * World\n//  *\\/\n\nformat('Single line')\n// /**\n//  * Single line\n//  *\\/",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 74
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "Raw",
                        "signature": {
                          "text": "interface Raw {\n  readonly __jsDocSafe: true\n  readonly content: string\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Branded type for content marked as safe for JSDoc injection.  \n\nUse raw to create values of this type. This prevents accidental injection of unescaped user content.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 95
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "raw",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "content",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "Raw",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Mark content as safe for JSDoc (already escaped or intentionally raw).  \n\nUse this for JSDoc tags, links, and other special syntax that should NOT be escaped.",
                        "examples": [
                          {
                            "code": "// Link will not be escaped\nconst link = raw(`{@link MyType}`)\nconst doc = tag\\`Type: ${link}\\`\n\n// Pre-escaped content\nconst escaped = escape(userInput)\nconst safe = raw(escaped)",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 116
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "tag",
                        "signature": {
                          "text": "export namespace tag {\n  /**\n   * Generate `@deprecated` tag with escaped reason.\n   * Returns null if reason is null/undefined for graceful template handling.\n   *\n   * @example\n   * ```ts\n   * tag.deprecated('Use newMethod() instead')\n   * // '@deprecated Use newMethod() instead'\n   * ```\n   */\n  export const deprecated = (reason: string | null | undefined): Raw | null => {\n    if (!reason) return null\n    return raw(`@deprecated ${escape(reason)}`)\n  }\n\n  /**\n   * Generate `@see` tag with link.\n   * Optionally includes display text.\n   *\n   * @example\n   * ```ts\n   * tag.see('https://example.com')\n   * // '@see {@link https://example.com}'\n   *\n   * tag.see('https://example.com', 'Documentation')\n   * // '@see {@link https://example.com | Documentation}'\n   * ```\n   */\n  export const see = (url: string, text?: string): Raw => {\n    return raw(text ? `@see {@link ${url} | ${text}}` : `@see {@link ${url}}`)\n  }\n\n  /**\n   * Generate inline `{@link}` reference (not a block tag).\n   * Use for inline documentation links.\n   *\n   * @example\n   * ```ts\n   * tag.link('MyType')\n   * // '{@link MyType}'\n   *\n   * tag.link('MyType', 'the type')\n   * // '{@link MyType | the type}'\n   * ```\n   */\n  export const link = (url: string, text?: string): Raw => {\n    return raw(text ? `{@link ${url} | ${text}}` : `{@link ${url}}`)\n  }\n\n  /**\n   * Generate `@example` tag with code block.\n   * Automatically wraps code in markdown code fence.\n   *\n   * @example\n   * ```ts\n   * tag.example('const x = 1', 'ts')\n   * // '@example\\n```ts\\nconst x = 1\\n```'\n   * ```\n   */\n  export const example = (code: string, lang: string = 'ts'): Raw => {\n    return raw(`@example\\n\\`\\`\\`${lang}\\n${code}\\n\\`\\`\\``)\n  }\n\n  /**\n   * Generate `@remarks` tag with escaped content.\n   * Returns null if content is null/undefined.\n   *\n   * @example\n   * ```ts\n   * tag.remarks('Important note')\n   * // '@remarks\\nImportant note'\n   * ```\n   */\n  export const remarks = (content: string | null | undefined): Raw | null => {\n    if (!content) return null\n    return raw(`@remarks\\n${escape(content)}`)\n  }\n\n  /**\n   * Generate `@param` tag with escaped description.\n   *\n   * @example\n   * ```ts\n   * tag.param('name', 'The user name')\n   * // '@param name - The user name'\n   * ```\n   */\n  export const param = (name: string, description: string): Raw => {\n    return raw(`@param ${name} - ${escape(description)}`)\n  }\n\n  /**\n   * Generate `@returns` tag with escaped description.\n   *\n   * @example\n   * ```ts\n   * tag.returns('The result value')\n   * // '@returns The result value'\n   * ```\n   */\n  export const returns = (description: string): Raw => {\n    return raw(`@returns ${escape(description)}`)\n  }\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Structured JSDoc tag helpers.  \n\nThese helpers generate properly formatted JSDoc tags with automatic escaping. All helpers return `Raw` (safe for injection) or `null` for graceful handling.",
                        "examples": [
                          {
                            "code": "tag\\`\n  ${description}\n  ${tag.deprecated(reason)}\n  ${tag.see('https://example.com', 'Documentation')}\n\\`",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 140
                        },
                        "_tag": "value",
                        "type": "namespace",
                        "module": {
                          "location": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "description": "Structured JSDoc tag helpers.  \n\nThese helpers generate properly formatted JSDoc tags with automatic escaping. All helpers return `Raw` (safe for injection) or `null` for graceful handling.",
                          "exports": []
                        }
                      },
                      {
                        "name": "Builder",
                        "signature": {
                          "text": "interface Builder {\n  /**\n   * Add a line to the JSDoc. Automatically escapes user content.\n   * Use empty template for blank lines: `doc\\`\\``\n   */\n  (strings: TemplateStringsArray, ...values: Array<string | number | Raw | null | undefined>): Builder\n\n  /**\n   * Add content with auto-escaping. Skips if null/undefined.\n   * Perfect for chaining with optional content.\n   * @example\n   * ```ts\n   * doc\n   *   .add(field.description)  // skips if null/undefined\n   *   .add('# Info')\n   * ```\n   */\n  add(content: string | null | undefined): Builder\n\n  /**\n   * Add raw content without escaping. Skips if null/undefined.\n   * Use for pre-escaped content or JSDoc syntax.\n   * @example\n   * ```ts\n   * doc.addRaw(sdlSignature)  // skips if null/undefined\n   * ```\n   */\n  addRaw(content: string | null | undefined): Builder\n\n  /**\n   * Add a blank line.\n   * @example\n   * ```ts\n   * doc\n   *   .add('First paragraph')\n   *   .blank()\n   *   .add('Second paragraph')\n   * ```\n   */\n  blank(): Builder\n\n  /**\n   * Add a markdown table from key-value pairs.\n   * Automatically filters out undefined/null/empty-array values.\n   *\n   * **Value handling:**\n   * - Raw values (from Md.code(), tag.link(), etc.): Used directly, already safe\n   * - Plain strings: Automatically escaped for JSDoc safety\n   * - Arrays: Items joined with `, ` (each item handled by type)\n   * - Empty arrays: Treated as undefined (filtered out)\n   *\n   * Returns builder for chaining.\n   *\n   * @example\n   * ```ts\n   * doc.table({\n   *   'Type': Md.code('string'),\n   *   'Parent': tag.link('ParentType'),\n   *   'Implements': interfaces.map(i => tag.link(i.name)),  // auto-joined\n   *   'Description': userDescription  // auto-escaped\n   * })\n   * ```\n   */\n  table(rows: Record<string, string | Raw | Array<string | Raw> | undefined | null>): Builder\n\n  /**\n   * Add a markdown code block with language syntax highlighting.\n   * Skips if content is null/undefined.\n   * @example\n   * ```ts\n   * doc.codeblock('graphql', \\`\n   *   type User {\n   *     id: ID!\n   *   }\n   * \\`)\n   * ```\n   */\n  codeblock(lang: string, content: string | null | undefined): Builder\n\n  /**\n   * Add `@deprecated` tag with escaped reason.\n   * Returns builder for chaining. Skips if reason is null/undefined.\n   */\n  $deprecated(reason: string | null | undefined): Builder\n\n  /**\n   * Add `@example` tag with code block.\n   *\n   * **Two modes:**\n   * - Template mode (2 params): Returns template function for code content\n   * - Direct mode (3 params): Accepts code string directly and returns builder\n   *\n   * @example\n   * ```ts\n   * // Template mode\n   * doc.$example('Basic usage', 'ts')\\`\n   *   const result = await api.query()\n   * \\`\n   *\n   * // Direct mode\n   * const code = 'const x = 1'\n   * doc.$example('Basic usage', 'ts', code)\n   * ```\n   */\n  $example(label?: string, lang?: string): (strings: TemplateStringsArray, ...values: any[]) => Builder\n  $example(label: string | undefined, lang: string, code: string): Builder\n\n  /**\n   * Add `@see` tag with link.\n   * Returns builder for chaining.\n   */\n  $see(url: string, text?: string): Builder\n\n  /**\n   * Generate inline `{@link}` reference for embedding in templates.\n   * Returns Raw (not the builder).\n   */\n  $link(url: string, text?: string): Raw\n\n  /**\n   * Add `@remarks` tag with content from template literal.\n   * Returns builder for chaining. Skips if content is empty.\n   */\n  $remarks(strings: TemplateStringsArray, ...values: any[]): Builder\n\n  /**\n   * Build the final JSDoc string with whitespace normalization.\n   */\n  build(): string\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "JSDoc builder interface for imperative JSDoc construction.  \n\nProvides a fluent API for building JSDoc with conditionals, loops, and tag helpers.",
                        "examples": [
                          {
                            "code": "const doc = builder()\n\ndoc\\`Main description\\`\ndoc\\`\\`  // blank line\n\nif (isDeprecated) {\n  doc.$deprecated('Use newMethod()')\n}\n\ndoc.table({ 'Type': 'string', 'Required': 'Yes' })\n\nreturn doc.build()",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 271
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "builder",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [],
                              "returnType": "Builder",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Create a new JSDoc builder for imperative construction.  \n\nPerfect for JSDoc generation with conditionals, loops, and complex logic.",
                        "examples": [
                          {
                            "code": "const doc = builder()\n\ndoc\\`Access to ${typeLink} root methods.\\`\ndoc\\`\\`  // empty line\n\nif (showExample) {\n  doc.$example('Basic usage', 'ts')\\`\n    const result = await api.query()\n  \\`\n}\n\ndoc.$deprecated\\`Use newMethod() instead\\`\n\nreturn doc.build()",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 425
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "Template",
                        "signature": {
                          "text": "interface Template {\n  /**\n   * Tagged template for building JSDoc content with automatic escaping.\n   *\n   * By default, interpolated values are escaped to prevent JSDoc injection.\n   * Use {@link raw} to inject pre-escaped or intentionally raw content.\n   *\n   * @example\n   * ```ts\n   * // User content is automatically escaped\n   * const doc = tag\\`\n   *   ${field.description}\n   *\n   *   @deprecated ${field.deprecationReason}\n   * \\`\n   *\n   * // Use raw for links and tags\n   * const link = raw(\\`{@link User}\\`)\n   * const doc = tag\\`\n   *   Field type: ${link}\n   *   Description: ${field.description}\n   * \\`\n   * ```\n   */\n  (strings: TemplateStringsArray, ...values: Array<string | number | Raw | null | undefined>): string\n\n  /**\n   * Create a new JSDoc builder for imperative construction.\n   * Perfect for JSDoc generation with conditionals, loops, and complex logic.\n   */\n  builder: typeof builder\n\n  /**\n   * Create a JSDoc generator function from a builder callback.\n   * Automatically calls `.build()` and returns the result.\n   *\n   * @example\n   * ```ts\n   * export const getFieldDoc = factory<[field: Field, parentType: Type]>((doc, field, parentType) => {\n   *   const typeLink = tag.link(field.type.name)\n   *\n   *   doc\\`Selection set for ${typeLink}.\\`\n   *   doc\\`\\`\n   *   doc.add(field.description)\n   *   doc\\`\\`\n   *   doc.table({ 'Type': \\`${field.type.name}\\` })\n   * })\n   *\n   * // Usage: getFieldDoc(field, parentType) -> string\n   * ```\n   */\n  factory: <$Args extends any[]>(fn: (doc: Builder, ...args: $Args) => void) => (...args: $Args) => string\n\n  /**\n   * JSDoc tag helpers for generating properly formatted tags.\n   */\n  tag: typeof tag\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "JSDoc template function type with builder property.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 618
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "template",
                        "signature": {
                          "type": "Template",
                          "_tag": "ValueSignatureModel"
                        },
                        "description": "Tagged template for building JSDoc content with automatic escaping. Also provides `.builder()` for imperative JSDoc construction and `.tag` for tag helpers.",
                        "examples": [
                          {
                            "code": "// Template mode with auto-escaping\nconst doc = tag\\`\n  Main description here\n\n  ${tag.deprecated('Use newMethod()')}\n  ${tag.see('https://example.com', 'Documentation')}\n\\`\n\n// Builder mode for complex logic\nconst doc = tag.builder()\ndoc\\`Main description\\`\nif (hasExample) {\n  doc.$example('Usage', 'ts')\\`const x = 1\\`\n}\nreturn doc.build()",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "tsdoc"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "tsdoc",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 700
                        },
                        "_tag": "value",
                        "type": "const"
                      }
                    ]
                  }
                },
                {
                  "name": "TS",
                  "signature": {
                    "text": "export * as TS",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "TypeScript code generation utilities.  \n\nProvides functions for generating TypeScript syntax elements like types, interfaces, imports, and exports.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "code"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 22
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str",
                          "code",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "",
                    "exports": [
                      {
                        "name": "string",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "str",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Quote a string value for TypeScript code.",
                        "examples": [
                          {
                            "code": "string('hello')\n// '\"hello\"'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 25
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "list",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "items",
                                  "type": "string[]",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate an array literal.",
                        "examples": [
                          {
                            "code": "list(['a', 'b', 'c'])\n// '[a, b, c]'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 36
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "block",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "content",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Wrap content in curly braces.",
                        "examples": [
                          {
                            "code": "block('a: string')\n// '{\\na: string\\n}'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 47
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "object",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "entries",
                                  "type": "readonly (readonly [string, string])[]",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate an object literal from entries.",
                        "examples": [
                          {
                            "code": "object([['name', '\"Alice\"'], ['age', '30']])\n// '{\\nname: \"Alice\",\\nage: 30\\n}'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 58
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "typeAlias",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "name",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false,
                                  "description": "Type name"
                                },
                                {
                                  "name": "type",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false,
                                  "description": "Type expression"
                                }
                              ],
                              "returnType": "string",
                              "returnDoc": "Type alias declaration",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate a type alias.",
                        "examples": [
                          {
                            "code": "typeAlias('UserId', 'string')\n// 'type UserId = string'\n\ntypeAlias('Point', '{ x: number; y: number }')\n// 'type Point = { x: number; y: number }'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 84
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "TypeAliasOptions",
                        "signature": {
                          "text": "interface TypeAliasOptions {\n  /**\n   * Type name\n   */\n  name: string\n\n  /**\n   * Type expression\n   */\n  type: string\n\n  /**\n   * Optional JSDoc comment content (will be formatted automatically)\n   */\n  tsDoc?: string | null\n\n  /**\n   * Optional type parameters (e.g., `['T', 'U extends string']`)\n   */\n  parameters?: string[] | null\n\n  /**\n   * Whether to export the type (default: true)\n   */\n  export?: boolean\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Options for generating a type alias with metadata.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 91
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "typeAliasWithOptions",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "options",
                                  "type": "TypeAliasOptions",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate a type alias with optional JSDoc and type parameters.",
                        "examples": [
                          {
                            "code": "typeAliasWithOptions({\n  name: 'Result',\n  type: 'T | Error',\n  parameters: ['T'],\n  tsDoc: 'A result that may be successful or an error',\n  export: true\n})\n// /**\n//  * A result that may be successful or an error\n//  *\\/\n// export type Result<T> = T | Error",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 136
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "InterfaceOptions",
                        "signature": {
                          "text": "interface InterfaceOptions {\n  /**\n   * Interface name\n   */\n  name: string\n\n  /**\n   * Interface body (fields)\n   */\n  block?: string\n\n  /**\n   * Optional JSDoc comment content (will be formatted automatically)\n   */\n  tsDoc?: string | null\n\n  /**\n   * Optional type parameters (e.g., `['T', 'U extends string']`)\n   */\n  parameters?: string[] | null\n\n  /**\n   * Optional extends clause (e.g., `['Base', 'Mixin']`)\n   */\n  extends?: string[] | null\n\n  /**\n   * Whether to export the interface (default: true)\n   */\n  export?: boolean\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Options for generating an interface.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 155
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "interfaceDecl",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "options",
                                  "type": "InterfaceOptions",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate an interface declaration.",
                        "examples": [
                          {
                            "code": "interfaceDecl({\n  name: 'User',\n  block: 'id: string\\nname: string',\n  tsDoc: 'Represents a user',\n  export: true\n})\n// /**\n//  * Represents a user\n//  *\\/\n// export interface User {\n//   id: string\n//   name: string\n// }",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 207
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "exportDecl",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "declaration",
                                  "type": "string",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate an export declaration.",
                        "examples": [
                          {
                            "code": "exportDecl('const foo = 1')\n// 'export const foo = 1'",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 239
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "reexportAll",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "input",
                                  "type": "{ from: string; type?: boolean; }",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Re-export all exports from a module.",
                        "examples": [
                          {
                            "code": "reexportAll({ from: './path' })\n// 'export * from './path''\n\nreexportAll({ from: './path', type: true })\n// 'export type * from './path''",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 255
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "reexportNamespace",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "input",
                                  "type": "{ as: string; from: string; type?: boolean; }",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Re-export all exports as a namespace.",
                        "examples": [
                          {
                            "code": "reexportNamespace({ as: 'Name', from: './path' })\n// 'export * as Name from './path''\n\nreexportNamespace({ as: 'Name', from: './path', type: true })\n// 'export type * as Name from './path''",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 275
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "reexportNamed",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "input",
                                  "type": "{ names: string | string[] | Record<string, string>; from: string; type?: boolean; }",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Re-export named exports from a module. Supports simple names, arrays, and aliased names.",
                        "examples": [
                          {
                            "code": "// export { Name } from './path'\nreexportNamed({ names: 'Name', from: './path' })\n\n// export { a, b, c } from './path'\nreexportNamed({ names: ['a', 'b', 'c'], from: './path' })\n\n// export { oldName as newName } from './path'\nreexportNamed({ names: { oldName: 'newName' }, from: './path' })\n\n// export type { Name } from './path'\nreexportNamed({ names: 'Name', from: './path', type: true })",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 303
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "importAll",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "input",
                                  "type": "{ as: string; from: string; type?: boolean; }",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Import all exports as a namespace.",
                        "examples": [
                          {
                            "code": "importAll({ as: 'Name', from: './path' })\n// 'import * as Name from './path''\n\nimportAll({ as: 'Name', from: './path', type: true })\n// 'import type * as Name from './path''",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 341
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "importNamed",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "input",
                                  "type": "{ names: string | string[] | Record<string, string>; from: string; type?: boolean; }",
                                  "optional": false,
                                  "rest": false
                                }
                              ],
                              "returnType": "string",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Import named exports from a module. Supports simple names, arrays, and aliased names.",
                        "examples": [
                          {
                            "code": "// import { Name } from './path'\nimportNamed({ names: 'Name', from: './path' })\n\n// import { a, b, c } from './path'\nimportNamed({ names: ['a', 'b', 'c'], from: './path' })\n\n// import { oldName as newName } from './path'\nimportNamed({ names: { oldName: 'newName' }, from: './path' })\n\n// import type { Name } from './path'\nimportNamed({ names: 'Name', from: './path', type: true })",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str",
                                "code",
                                "ts"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "ts",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 369
                        },
                        "_tag": "value",
                        "type": "function"
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Text",
            "signature": {
              "text": "export * as Text",
              "_tag": "TypeSignatureModel"
            },
            "description": "Multi-line text formatting and layout utilities.  \n\nProvides functions specifically for working with multi-line strings treated as text content: - **Line operations**: Split into lines, join lines, map transformations per line - **Indentation**: Add/remove indentation, strip common leading whitespace - **Alignment**: Pad text, span to width, fit to exact width - **Block formatting**: Format blocks with prefixes, styled borders  \n\n**Use Text for**: Operations that treat strings as multi-line content with visual layout (indentation, padding for tables, line-by-line transformations).  \n\n**Use root Str for**: Primitive string operations (split, join, replace, match, trim) that work on strings as atomic values.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 32
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "text",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "defaultIndentSize",
                  "signature": {
                    "type": "2",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Default indentation size in characters.",
                  "examples": [],
                  "category": "Text Formatting  2",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 11
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "defaultIndentCharacter",
                  "signature": {
                    "type": "\"\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Default character used for indentation (non-breaking space).",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 17
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "defaultLineSeparator",
                  "signature": {
                    "type": "\"\\n\"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Default line separator character (newline).",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 23
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "Column",
                  "signature": {
                    "text": "type Column = string[]",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "A column is a vertical stack of lines.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 31
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "lines",
                  "signature": {
                    "type": "(value: string) => string[]",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Split text into an array of lines. Pre-configured splitWith using newline separator.",
                  "examples": [
                    {
                      "code": "lines('hello\\nworld\\n!') // ['hello', 'world', '!']\nlines('single line') // ['single line']",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "unlines",
                  "signature": {
                    "type": "(value: string[]) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Join an array of lines into text. Pre-configured joinWith using newline separator.",
                  "examples": [
                    {
                      "code": "unlines(['hello', 'world', '!']) // 'hello\\nworld\\n!'\nunlines(['single line']) // 'single line'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 61
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "indent",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to indent"
                          },
                          {
                            "name": "size",
                            "type": "number | undefined",
                            "optional": true,
                            "rest": false,
                            "description": "Number of spaces to indent (default: defaultIndentSize)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The indented text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Indent each line of text by a specified number of spaces.",
                  "examples": [
                    {
                      "code": "indent('hello\\nworld') // '  hello\\n  world'\nindent('line1\\nline2', 4) // '    line1\\n    line2'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 77
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "indentOn",
                  "signature": {
                    "type": "(text: string) => (size?: number | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of indent with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 88
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "indentWith",
                  "signature": {
                    "type": "(size?: number | undefined) => (text: string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of indent with size first.",
                  "examples": [
                    {
                      "code": "const indent4 = indentWith(4)\nindent4('hello\\nworld') // '    hello\\n    world'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 101
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "indentBy",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to indent"
                          },
                          {
                            "name": "prefixOrFn",
                            "type": "string | ((line: string, lineIndex: number) => string)",
                            "optional": false,
                            "rest": false,
                            "description": "String to prepend to each line, or function `(line: string, lineIndex: number) => string`"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The indented text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Indent each line using a custom prefix string or function. When given a function, it receives both the line content and index, allowing for content-aware indentation.",
                  "examples": [
                    {
                      "code": "// Fixed string prefix\nindentBy('hello\\nworld', '>>> ') // '>>> hello\\n>>> world'\n\n// Dynamic prefix based on line index (ignore line content with _)\nindentBy('line1\\nline2\\nline3', (_, i) => `${i + 1}. `)\n// '1. line1\\n2. line2\\n3. line3'\n\n// Content-aware indentation\nindentBy('title\\nitem', (line, i) => line === 'title' ? '' : '  ')\n// 'title\\n  item'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 124
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "indentByOn",
                  "signature": {
                    "type": "(text: string) => (prefixOrFn: string | ((line: string, lineIndex: number) => string)) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of indentBy with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 139
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "indentByWith",
                  "signature": {
                    "type": "(prefixOrFn: string | ((line: string, lineIndex: number) => string)) => (text: string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of indentBy with prefix first.",
                  "examples": [
                    {
                      "code": "const addArrow = indentByWith(' ')\naddArrow('hello\\nworld') // ' hello\\n world'\n\nconst numbered = indentByWith((_, i) => `${i}. `)\nnumbered('first\\nsecond') // '0. first\\n1. second'\n\nconst conditionalIndent = indentByWith((line, i) =>\n  line.startsWith('#') ? '' : '  '\n)\nconditionalIndent('# Title\\nContent') // '# Title\\n  Content'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 160
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "stripIndent",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to dedent"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The dedented text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Remove common leading whitespace from all lines. Finds the minimum indentation across all non-empty lines and removes that amount from every line. This is useful for dedenting code blocks or template strings while preserving relative indentation.",
                  "examples": [
                    {
                      "code": "stripIndent('    line1\\n      line2\\n    line3')\n// 'line1\\n  line2\\nline3'\n\nstripIndent('  code\\n    nested\\n  code')\n// 'code\\n  nested\\ncode'\n\n// Empty lines are ignored when calculating minimum indent\nstripIndent('    line1\\n\\n    line2')\n// 'line1\\n\\nline2'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 182
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "defaultPadCharacter",
                  "signature": {
                    "type": "\" \"",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Default character used for padding.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 208
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "pad",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to pad"
                          },
                          {
                            "name": "size",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Number of padding characters to add"
                          },
                          {
                            "name": "side",
                            "type": "\"left\" | \"right\"",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "`left`",
                            "description": "Which side to add padding ('left' or 'right')"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The padded text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add padding characters to text.",
                  "examples": [
                    {
                      "code": "pad('hello', 3, 'left') // '   hello'\npad('hello', 3, 'right') // 'hello   '\npad('hello', 2, 'left', '-') // '--hello'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 225
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "padOn",
                  "signature": {
                    "type": "(text: string) => (size: number) => (side?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of pad with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 240
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "padWith",
                  "signature": {
                    "type": "(size: number) => (text: string) => (side?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of pad with size first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 248
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "padLeft",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to pad"
                          },
                          {
                            "name": "size",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Number of padding characters to add"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The left-padded text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add left padding to text.",
                  "examples": [
                    {
                      "code": "padLeft('hello', 3) // '   hello'\npadLeft('hello', 2, '0') // '00hello'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 263
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "padLeftOn",
                  "signature": {
                    "type": "(text: string) => (size: number) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of padLeft with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 273
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "padLeftWith",
                  "signature": {
                    "type": "(size: number) => (text: string) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of padLeft with size first.",
                  "examples": [
                    {
                      "code": "const pad3 = padLeftWith(3)\npad3('hi') // '   hi'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 286
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "padRight",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to pad"
                          },
                          {
                            "name": "size",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Number of padding characters to add"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The right-padded text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add right padding to text.",
                  "examples": [
                    {
                      "code": "padRight('hello', 3) // 'hello   '\npadRight('hello', 2, '.') // 'hello..'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 301
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "padRightOn",
                  "signature": {
                    "type": "(text: string) => (size: number) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of padRight with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 311
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "padRightWith",
                  "signature": {
                    "type": "(size: number) => (text: string) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of padRight with size first.",
                  "examples": [
                    {
                      "code": "const pad3 = padRightWith(3)\npad3('hi') // 'hi   '",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 324
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "span",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to align"
                          },
                          {
                            "name": "width",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Target width (in characters)"
                          },
                          {
                            "name": "align",
                            "type": "\"left\" | \"right\"",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "`left`",
                            "description": "Content alignment ('left' or 'right')"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The aligned text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Align text within a specified width by adding padding.  \n\nThis ensures text spans exactly the target width, aligning content to the left or right. If the text is already wider than the target width, no padding is added.",
                  "examples": [
                    {
                      "code": "// Left-align (pad right)\nStr.span('hi', 5, 'left')     // 'hi   '\n\n// Right-align (pad left)\nStr.span('hi', 5, 'right')    // '   hi'\n\n// Text already wider - no padding added\nStr.span('hello world', 5, 'left')  // 'hello world' (unchanged)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 351
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "spanOn",
                  "signature": {
                    "type": "(text: string) => (width: number) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of span with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 368
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "spanWith",
                  "signature": {
                    "type": "(width: number) => (text: string) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of span with width first.",
                  "examples": [
                    {
                      "code": "const span8 = Str.spanWith(8)\nspan8('Name', 'left')   // 'Name    '\nspan8('Age', 'right')   // '     Age'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 383
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fit",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to constrain"
                          },
                          {
                            "name": "width",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Exact target width (in characters)"
                          },
                          {
                            "name": "align",
                            "type": "\"left\" | \"right\"",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "`left`",
                            "description": "Content alignment ('left' or 'right')"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "Text constrained to exact width",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Constrain text to exact width by cropping and/or padding.  \n\nUnlike span which only pads (leaving text unchanged if too long), this function guarantees the exact width by: - Cropping text if it exceeds the target width - Padding text if it's shorter than the target width  \n\nThis is useful for fixed-width layouts where column widths must be exact, such as table columns, CSV files, and fixed-format text files.",
                  "examples": [
                    {
                      "code": "// Text too long - gets cropped\nStr.fit('hello world', 5, 'left')  // 'hello'\n\n// Text too short - gets padded\nStr.fit('hi', 5, 'left')           // 'hi   '\nStr.fit('hi', 5, 'right')          // '   hi'\n\n// Perfect fit - unchanged\nStr.fit('exact', 5, 'left')        // 'exact'\n\n// Use case: Fixed-width table columns\nconst columns = ['Name', 'Email', 'Status'].map(\n  (header, i) => Str.fit(header, [10, 20, 8][i], 'left')\n)\n// ['Name      ', 'Email               ', 'Status  ']\n\n// CSV formatting with fixed columns\nconst row = [name, email, status].map((val, i) =>\n  Str.fit(val, [20, 30, 10][i], 'left')\n).join(',')",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 427
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fitOn",
                  "signature": {
                    "type": "(text: string) => (width: number) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of fit with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 443
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fitWith",
                  "signature": {
                    "type": "(width: number) => (text: string) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of fit with width first.",
                  "examples": [
                    {
                      "code": "// Create fixed-width formatters\nconst nameColumn = Str.fitWith(20)\nconst statusColumn = Str.fitWith(10)\n\nnameColumn('John Doe', 'left')         // 'John Doe            '\nstatusColumn('Active', 'left')         // 'Active    '\nstatusColumn('Very Long Status', 'left') // 'Very Long '",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 462
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "mapLines",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to transform"
                          },
                          {
                            "name": "fn",
                            "type": "(line: string, index: number) => string",
                            "optional": false,
                            "rest": false,
                            "description": "Function to apply to each line, receiving the line and its index"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The transformed text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Map a transformation function over each line of text.",
                  "examples": [
                    {
                      "code": "mapLines('hello\\nworld', (line) => line.toUpperCase())\n// 'HELLO\\nWORLD'\n\nmapLines('a\\nb\\nc', (line, i) => `${i}: ${line}`)\n// '0: a\\n1: b\\n2: c'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 479
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "mapLinesOn",
                  "signature": {
                    "type": "(text: string) => (fn: (line: string, index: number) => string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of mapLines with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 489
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "mapLinesWith",
                  "signature": {
                    "type": "(fn: (line: string, index: number) => string) => (text: string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of mapLines with function first.",
                  "examples": [
                    {
                      "code": "const uppercase = mapLinesWith((line) => line.toUpperCase())\nuppercase('hello\\nworld') // 'HELLO\\nWORLD'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 502
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "StyledPrefix",
                  "signature": {
                    "text": "type StyledPrefix = {\n  /**\n   * The prefix text/symbol to display.\n   */\n  symbol: string\n  /**\n   * Optional function to colorize the prefix.\n   */\n  color?: (text: string) => string\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Styled prefix that can have an optional color function. Used with formatBlock for colored line prefixes.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 512
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "formatBlock",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "block",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text block to format"
                          },
                          {
                            "name": "opts",
                            "type": "{ prefix?: string | StyledPrefix; indent?: number; excludeFirstLine?: boolean; }",
                            "optional": false,
                            "rest": false,
                            "description": "Formatting options"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "Formatted text block",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Format a multi-line text block with line-by-line transformations.  \n\nProcesses each line of text, adding a prefix and optional indentation. Supports excluding the first line and styled prefixes with colors.",
                  "examples": [
                    {
                      "code": "// Simple string prefix\nformatBlock('line1\\nline2\\nline3', { prefix: '> ' })\n// '> line1\\n> line2\\n> line3'\n\n// With indentation\nformatBlock('line1\\nline2', { prefix: '| ', indent: 2 })\n// '|   line1\\n|   line2'\n\n// Exclude first line (useful for continuing indentation)\nformatBlock('header\\nline1\\nline2', { prefix: '  ', excludeFirstLine: true })\n// 'header\\n  line1\\n  line2'\n\n// Single line - returned as-is\nformatBlock('single', { prefix: '> ' })\n// 'single'\n\n// Styled prefix with color function\nformatBlock('data\\nmore data', {\n  prefix: {\n    symbol: ' ',\n    color: (text) => `\\x1b[90m${text}\\x1b[0m` // gray color\n  },\n  indent: 2\n})\n// '\\x1b[90m \\x1b[0m  data\\n\\x1b[90m \\x1b[0m  more data'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 566
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "formatBlockOn",
                  "signature": {
                    "type": "(block: string) => (opts: { prefix?: string | StyledPrefix; indent?: number; excludeFirstLine?: boolean; }) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of formatBlock with block first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 598
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "formatBlockWith",
                  "signature": {
                    "type": "(opts: { prefix?: string | StyledPrefix; indent?: number; excludeFirstLine?: boolean; }) => (block: string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of formatBlock with options first.",
                  "examples": [
                    {
                      "code": "const addSpine = formatBlockWith({ prefix: ' ', indent: 2 })\naddSpine('line1\\nline2\\nline3')\n// '   line1\\n   line2\\n   line3'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "text",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 612
                  },
                  "_tag": "value",
                  "type": "const"
                }
              ]
            }
          },
          {
            "name": "Visual",
            "signature": {
              "text": "export * as Visual",
              "_tag": "TypeSignatureModel"
            },
            "description": "Visual-aware string utilities that handle ANSI escape codes and grapheme clusters.  \n\nThese functions measure and manipulate strings based on their visual appearance, not raw character count. Useful for terminal output, tables, and formatted text.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 53
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "visual",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "Table",
                  "signature": {
                    "text": "export * as Table",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Visual-aware table operations for multi-column text layout.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 584
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual-table",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "",
                    "exports": [
                      {
                        "name": "Cell",
                        "signature": {
                          "text": "type Cell = string",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Visual-aware table operations for multi-column text layout.  \n\nTables are row-major 2D arrays where `table[row][col]` accesses individual cells. All operations use visual width (ANSI-aware) for alignment and measurement.",
                        "examples": [
                          {
                            "code": "import { Str } from '@wollybeard/kit'\n\n// Create table from row data\nconst table = [\n  ['Name', 'Age'],\n  ['Alice', '30']\n]\n\n// Render with visual alignment\nStr.Visual.Table.render(table)\n// \"Name   Age\"\n// \"Alice  30\"\n\n// With ANSI codes\nconst colored = [['\\x1b[31mRed\\x1b[0m', 'Normal']]\nStr.Visual.Table.render(colored, { separator: ' | ' })\n// \"Red | Normal\"  (correctly aligned despite ANSI)",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 41
                        },
                        "_tag": "type",
                        "type": "type-alias"
                      },
                      {
                        "name": "Row",
                        "signature": {
                          "text": "type Row = Cell[]",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Row of cells in a table.",
                        "examples": [],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 48
                        },
                        "_tag": "type",
                        "type": "type-alias"
                      },
                      {
                        "name": "Table",
                        "signature": {
                          "text": "type Table = Row[]",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Row-major 2D table of text cells.  \n\nAccess pattern: `table[rowIndex][columnIndex]` Can be jagged (rows with different lengths).",
                        "examples": [],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 58
                        },
                        "_tag": "type",
                        "type": "type-alias"
                      },
                      {
                        "name": "RenderOptions",
                        "signature": {
                          "text": "interface RenderOptions {\n  /**\n   * String to place between columns.\n   * @default '   ' (three spaces)\n   */\n  separator?: string\n\n  /**\n   * How to align content within columns.\n   * @default 'left'\n   */\n  align?: 'left' | 'right'\n\n  /**\n   * Explicit column widths. If omitted, auto-calculated from content.\n   * Useful for forcing specific column sizes.\n   */\n  columnWidths?: number[]\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Options for rendering tables into formatted text.",
                        "examples": [],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 65
                        },
                        "_tag": "type",
                        "type": "interface"
                      },
                      {
                        "name": "render",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "table",
                                  "type": "Table",
                                  "optional": false,
                                  "rest": false,
                                  "description": "The table to render"
                                },
                                {
                                  "name": "options",
                                  "type": "RenderOptions | undefined",
                                  "optional": true,
                                  "rest": false,
                                  "description": "Formatting options"
                                }
                              ],
                              "returnType": "string",
                              "returnDoc": "Multi-line string with aligned columns",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Render table rows into a formatted multi-line string.  \n\nEach column is aligned to its maximum visual width (or explicit width if provided). Missing cells in jagged arrays are treated as empty strings.",
                        "examples": [
                          {
                            "code": "const table = [\n  ['Name', 'Age', 'City'],\n  ['Alice', '30', 'NYC'],\n  ['Bob', '25', 'LA']\n]\n\nStr.Visual.Table.render(table)\n// \"Name   Age  City\"\n// \"Alice  30   NYC\"\n// \"Bob    25   LA\"\n\nStr.Visual.Table.render(table, { separator: ' | ', align: 'right' })\n// \" Name | Age | City\"\n// \"Alice |  30 |  NYC\"\n// \"  Bob |  25 |   LA\"",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 115
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "renderOn",
                        "signature": {
                          "type": "(table: Table) => (options?: RenderOptions | undefined) => string",
                          "_tag": "ValueSignatureModel"
                        },
                        "description": "Curried version of render with table first.",
                        "examples": [],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 136
                        },
                        "_tag": "value",
                        "type": "const"
                      },
                      {
                        "name": "renderWith",
                        "signature": {
                          "type": "(options?: RenderOptions | undefined) => (table: Table) => string",
                          "_tag": "ValueSignatureModel"
                        },
                        "description": "Curried version of render with options first.",
                        "examples": [],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 142
                        },
                        "_tag": "value",
                        "type": "const"
                      },
                      {
                        "name": "renderColumns",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "columns",
                                  "type": "string[][]",
                                  "optional": false,
                                  "rest": false,
                                  "description": "Array of columns, each column is an array of cell values"
                                },
                                {
                                  "name": "options",
                                  "type": "RenderOptions | undefined",
                                  "optional": true,
                                  "rest": false,
                                  "description": "Formatting options"
                                }
                              ],
                              "returnType": "string",
                              "returnDoc": "Multi-line string with aligned columns",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Render columns of text as aligned output.  \n\nTakes column-oriented data where each column can have multiple lines. Columns with different heights are padded with empty strings. Transposes the column data to row-oriented format before rendering.",
                        "examples": [
                          {
                            "code": "// Column-oriented data\nconst columns = [\n  ['Name', 'Alice', 'Bob'],    // Column 1\n  ['Age', '30', '25']           // Column 2\n]\n\nStr.Visual.Table.renderColumns(columns)\n// \"Name   Age\"\n// \"Alice  30\"\n// \"Bob    25\"\n\n// Handles jagged arrays\nconst jagged = [\n  ['A', 'B'],\n  ['X', 'Y', 'Z']\n]\nStr.Visual.Table.renderColumns(jagged)\n// \"A  X\"\n// \"B  Y\"\n// \"   Z\"",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 180
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "renderColumnsOn",
                        "signature": {
                          "type": "(columns: string[][]) => (options?: RenderOptions | undefined) => string",
                          "_tag": "ValueSignatureModel"
                        },
                        "description": "Curried version of renderColumns with columns first.",
                        "examples": [],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 190
                        },
                        "_tag": "value",
                        "type": "const"
                      },
                      {
                        "name": "renderColumnsWith",
                        "signature": {
                          "type": "(options?: RenderOptions | undefined) => (columns: string[][]) => string",
                          "_tag": "ValueSignatureModel"
                        },
                        "description": "Curried version of renderColumns with options first.",
                        "examples": [],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 196
                        },
                        "_tag": "value",
                        "type": "const"
                      },
                      {
                        "name": "columnWidths",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "table",
                                  "type": "Table",
                                  "optional": false,
                                  "rest": false,
                                  "description": "The table to measure"
                                }
                              ],
                              "returnType": "number[]",
                              "returnDoc": "Array of column widths",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Calculate the visual width of each column.  \n\nReturns an array where each element is the maximum visual width of cells in that column.",
                        "examples": [
                          {
                            "code": "const table = [\n  ['hi', 'world'],\n  ['hello', 'x']\n]\n\nStr.Visual.Table.columnWidths(table)\n// [5, 5]  (max of 'hi'/'hello', max of 'world'/'x')",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 219
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "dimensions",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "table",
                                  "type": "Table",
                                  "optional": false,
                                  "rest": false,
                                  "description": "The table to measure"
                                }
                              ],
                              "returnType": "{ rows: number; columns: number; }",
                              "returnDoc": "Object with row and column counts",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Get the dimensions of a table.",
                        "examples": [
                          {
                            "code": "const table = [['a', 'b'], ['c']]\nStr.Visual.Table.dimensions(table)\n// { rows: 2, columns: 2 }",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 251
                        },
                        "_tag": "value",
                        "type": "function"
                      },
                      {
                        "name": "normalize",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "table",
                                  "type": "Table",
                                  "optional": false,
                                  "rest": false,
                                  "description": "The table to normalize"
                                }
                              ],
                              "returnType": "Table",
                              "returnDoc": "Rectangular table",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Normalize a jagged table to be rectangular.  \n\nFills missing cells with empty strings so all rows have the same length.",
                        "examples": [
                          {
                            "code": "const jagged = [['a', 'b'], ['c']]\nStr.Visual.Table.normalize(jagged)\n// [['a', 'b'], ['c', '']]",
                            "twoslashEnabled": true,
                            "language": "typescript"
                          }
                        ],
                        "category": "Text Formatting",
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "domains",
                                "str"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "visual-table",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 274
                        },
                        "_tag": "value",
                        "type": "function"
                      }
                    ]
                  }
                },
                {
                  "name": "width",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to measure"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The visual width of the text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the visual width of a string, ignoring ANSI escape codes and counting grapheme clusters.  \n\nThis is the \"true\" visual width as it would appear in a terminal: - ANSI escape codes (colors, styles) are stripped before counting - Grapheme clusters (emojis, combining characters) count as single units",
                  "examples": [
                    {
                      "code": "// ANSI codes are stripped\nStr.Visual.width('\\x1b[31mred\\x1b[0m')  // 3\n\n// Grapheme clusters count as 1\nStr.Visual.width('')              // 1 (family emoji)\nStr.Visual.width('')                   // 1 (e + combining accent)\nStr.Visual.width('')                  // 1 (flag emoji)\n\n// Empty string\nStr.Visual.width('')                    // 0\nStr.Visual.width('\\x1b[31m\\x1b[0m')     // 0 (only ANSI codes)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 66
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "pad",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to pad"
                          },
                          {
                            "name": "size",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Target visual size (including text)"
                          },
                          {
                            "name": "side",
                            "type": "\"left\" | \"right\"",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "`left`",
                            "description": "Which side to add padding ('left' or 'right')"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The padded text (or original if already wider than size)",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Add padding to text, calculated based on visual length.  \n\nThe padding size is adjusted to account for ANSI escape codes, so the final output has the desired visual width.",
                  "examples": [
                    {
                      "code": "// Regular text\nStr.Visual.pad('hi', 5, 'right')  // 'hi   ' (visual width 5)\n\n// With ANSI codes - padding accounts for escape codes\nconst colored = '\\x1b[31mOK\\x1b[0m'\nStr.Visual.pad(colored, 5, 'right')  // Adds 3 spaces (visual: \"OK   \")\n\n// Text already wider than target size\nStr.Visual.pad('hello', 3, 'left')  // 'hello' (unchanged)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 102
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "padOn",
                  "signature": {
                    "type": "(text: string) => (size: number) => (side?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of pad with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 119
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "padWith",
                  "signature": {
                    "type": "(size: number) => (text: string) => (side?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of pad with size first.",
                  "examples": [
                    {
                      "code": "const pad10 = Str.Visual.padWith(10)\npad10('\\x1b[32mSuccess\\x1b[0m', 'right')  // Visual width 10",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 133
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "span",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to align"
                          },
                          {
                            "name": "width",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Target visual width"
                          },
                          {
                            "name": "align",
                            "type": "\"left\" | \"right\"",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "`left`",
                            "description": "Content alignment ('left' or 'right')"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The aligned text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Align text within a specified visual width by adding padding.  \n\nThis ensures text spans exactly the target width, aligning content to the left or right. If the text is already wider than the target width, no padding is added.",
                  "examples": [
                    {
                      "code": "// Left-align (pad right)\nStr.Visual.span('hi', 5, 'left')     // 'hi   '\n\n// Right-align (pad left)\nStr.Visual.span('hi', 5, 'right')    // '   hi'\n\n// With ANSI codes\nconst colored = '\\x1b[34mID\\x1b[0m'\nStr.Visual.span(colored, 6, 'left')  // Visual: \"ID    \"",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 161
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "spanOn",
                  "signature": {
                    "type": "(text: string) => (width: number) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of span with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 176
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "spanWith",
                  "signature": {
                    "type": "(width: number) => (text: string) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of span with width first.",
                  "examples": [
                    {
                      "code": "const span8 = Str.Visual.spanWith(8)\nspan8('Name', 'left')   // 'Name    '\nspan8('Age', 'right')   // '     Age'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 191
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fit",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to constrain"
                          },
                          {
                            "name": "width",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Exact target visual width"
                          },
                          {
                            "name": "align",
                            "type": "\"left\" | \"right\"",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "`left`",
                            "description": "Content alignment ('left' or 'right')"
                          },
                          {
                            "name": "char",
                            "type": "string",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "defaultPadCharacter",
                            "description": "Character to use for padding (default: space)"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "Text constrained to exact width",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Constrain text to exact visual width by cropping and/or padding.  \n\nUnlike span which only pads (leaving text unchanged if too long), this function guarantees the exact width by: - Cropping text if it exceeds the target width - Padding text if it's shorter than the target width  \n\nThis is useful for fixed-width layouts where column widths must be exact, such as table columns, status bars, and terminal UIs.",
                  "examples": [
                    {
                      "code": "// Text too long - gets cropped\nStr.Visual.fit('hello world', 5, 'left')  // 'hello'\n\n// Text too short - gets padded\nStr.Visual.fit('hi', 5, 'left')           // 'hi   '\nStr.Visual.fit('hi', 5, 'right')          // '   hi'\n\n// Perfect fit - unchanged\nStr.Visual.fit('exact', 5, 'left')        // 'exact'\n\n// With ANSI codes\nconst colored = '\\x1b[31mvery long colored text\\x1b[0m'\nStr.Visual.fit(colored, 8, 'left')        // '\\x1b[31mvery lon\\x1b[0m' (visual: \"very lon\")\n\n// Use case: Fixed-width table columns\nconst columns = ['Name', 'Email', 'Status'].map(\n  (header, i) => Str.Visual.fit(header, [10, 20, 8][i], 'left')\n)\n// ['Name      ', 'Email               ', 'Status  ']",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 234
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "fitOn",
                  "signature": {
                    "type": "(text: string) => (width: number) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of fit with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 250
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "fitWith",
                  "signature": {
                    "type": "(width: number) => (text: string) => (align?: \"left\" | \"right\" | undefined) => (char?: string | undefined) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of fit with width first.",
                  "examples": [
                    {
                      "code": "// Create fixed-width formatters\nconst nameColumn = Str.Visual.fitWith(20)\nconst statusColumn = Str.Visual.fitWith(10)\n\nnameColumn('John Doe', 'left')         // 'John Doe            '\nstatusColumn('Active', 'left')         // 'Active    '\nstatusColumn('Very Long Status', 'left') // 'Very Long '",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 269
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "take",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to extract from"
                          },
                          {
                            "name": "size",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Visual length to take"
                          }
                        ],
                        "returnType": "string",
                        "returnDoc": "The extracted substring",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Take a substring by visual length.  \n\nExtracts characters from the start of the string up to the specified visual width. Accounts for ANSI codes and grapheme clusters, so the result has the desired visual length.",
                  "examples": [
                    {
                      "code": "// Regular text\nStr.Visual.take('hello', 3)  // 'hel'\n\n// With ANSI codes\nconst colored = '\\x1b[31mhello\\x1b[0m world'\nStr.Visual.take(colored, 5)  // '\\x1b[31mhello\\x1b[0m' (visual: \"hello\")\n\n// With emoji\nStr.Visual.take(' hello', 2)  // ' ' (emoji + space)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 295
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "takeOn",
                  "signature": {
                    "type": "(text: string) => (size: number) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of take with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 312
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "takeWith",
                  "signature": {
                    "type": "(size: number) => (text: string) => string",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of take with size first.",
                  "examples": [
                    {
                      "code": "const take10 = Str.Visual.takeWith(10)\ntake10('a long string here')  // First 10 visual chars",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 326
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "takeWords",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to split"
                          },
                          {
                            "name": "size",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Maximum visual length"
                          }
                        ],
                        "returnType": "{ taken: string; remaining: string; }",
                        "returnDoc": "Object with `taken` words and `remaining` text",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Split text into words by visual length, respecting word boundaries.  \n\nExtracts words from the start of the string until reaching the visual width limit. Avoids breaking words mid-way when possible (though single words longer than size will be taken anyway).",
                  "examples": [
                    {
                      "code": "// Splits at word boundaries\nStr.Visual.takeWords('hello world here', 12)\n// { taken: 'hello world', remaining: 'here' }\n\n// Single word too long - takes it anyway\nStr.Visual.takeWords('verylongword more', 8)\n// { taken: 'verylongword', remaining: 'more' }\n\n// With ANSI codes\nconst colored = '\\x1b[32mone\\x1b[0m two three'\nStr.Visual.takeWords(colored, 7)\n// { taken: '\\x1b[32mone\\x1b[0m two', remaining: 'three' }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 356
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "takeWordsOn",
                  "signature": {
                    "type": "(text: string) => (size: number) => { taken: string; remaining: string; }",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of takeWords with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 399
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "takeWordsWith",
                  "signature": {
                    "type": "(size: number) => (text: string) => { taken: string; remaining: string; }",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of takeWords with size first.",
                  "examples": [
                    {
                      "code": "const take20 = Str.Visual.takeWordsWith(20)\ntake20('Lorem ipsum dolor sit amet')\n// { taken: 'Lorem ipsum dolor', remaining: 'sit amet' }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 414
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "wrap",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "Text to wrap (may contain existing newlines)"
                          },
                          {
                            "name": "width",
                            "type": "number",
                            "optional": false,
                            "rest": false,
                            "description": "Maximum visual width per line"
                          }
                        ],
                        "returnType": "string[]",
                        "returnDoc": "Array of wrapped lines",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Wrap text to fit within visual width, respecting word boundaries.  \n\nBreaks text into lines that fit the specified visual width. Respects existing newlines in the input and breaks long lines at word boundaries when possible.",
                  "examples": [
                    {
                      "code": "// Basic wrapping\nStr.Visual.wrap('hello world here', 10)\n// ['hello', 'world here']\n\n// Respects existing newlines\nStr.Visual.wrap('line one\\nline two is long', 10)\n// ['line one', 'line two', 'is long']\n\n// With ANSI codes - visual width accounts for escape codes\nconst colored = '\\x1b[31mthis is red text\\x1b[0m and normal'\nStr.Visual.wrap(colored, 12)\n// ['\\x1b[31mthis is red\\x1b[0m', 'text and', 'normal']",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 443
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "wrapOn",
                  "signature": {
                    "type": "(text: string) => (width: number) => string[]",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of wrap with text first.",
                  "examples": [],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 466
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "wrapWith",
                  "signature": {
                    "type": "(width: number) => (text: string) => string[]",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Curried version of wrap with width first.",
                  "examples": [
                    {
                      "code": "const wrap80 = Str.Visual.wrapWith(80)\nwrap80('long text here...')  // Wraps to 80 columns",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 480
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "size",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to measure"
                          }
                        ],
                        "returnType": "{ maxWidth: number; height: number; }",
                        "returnDoc": "Object with `maxWidth` and `height` properties",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the visual size (dimensions) of text.  \n\nReturns the maximum visual width (longest line) and height (line count). Accounts for ANSI codes and grapheme clusters.",
                  "examples": [
                    {
                      "code": "Str.Visual.size('hello\\nworld')\n// { maxWidth: 5, height: 2 }\n\n// With ANSI codes\nconst colored = '\\x1b[31mred\\x1b[0m\\n\\x1b[32mgreen!\\x1b[0m'\nStr.Visual.size(colored)\n// { maxWidth: 6, height: 2 } (visual: \"red\" and \"green!\")\n\n// Empty string\nStr.Visual.size('')\n// { maxWidth: 0, height: 0 }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 507
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "maxWidth",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "text",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The text to measure"
                          }
                        ],
                        "returnType": "number",
                        "returnDoc": "The maximum visual width across all lines",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Get the maximum visual width of text (longest line).  \n\nConvenience function that returns just the width from size. Useful when you only need width and not height.",
                  "examples": [
                    {
                      "code": "Str.Visual.maxWidth('short\\nlonger line\\nhi')  // 11\n\n// With ANSI codes\nStr.Visual.maxWidth('\\x1b[31mred\\x1b[0m\\n\\x1b[32mgreen\\x1b[0m')  // 5",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Text Formatting",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "domains",
                          "str"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "visual",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 535
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Arb",
            "signature": {
              "type": "Arb<string>",
              "_tag": "ValueSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "arb",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 31
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Eq",
            "signature": {
              "type": "Eq<string>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Eq trait implementation for strings.  \n\nProvides string equality comparison using strict equality (===). String comparison is case-sensitive and considers all Unicode characters.",
            "examples": [
              {
                "code": "import { Str } from '@wollybeard/kit'\n\nStr.Eq.is('hello', 'hello')     // true\nStr.Eq.is('hello', 'Hello')     // false (case-sensitive)\nStr.Eq.is('', '')               // true (empty strings)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "eq",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 20
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Type",
            "signature": {
              "type": "Type<string>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Type trait implementation for strings.  \n\nProvides type guard for checking if a value is a string.",
            "examples": [
              {
                "code": "import { Str } from '@wollybeard/kit'\n\nStr.Type.is('hello')    // true\nStr.Type.is(123)        // false\nStr.Type.is(null)       // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Traits",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "traits"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 19
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Empty",
            "signature": {
              "text": "type Empty = ''",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type for an empty string.",
            "examples": [],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 20
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isEmpty",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the string is empty",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type guard to check if a string is empty.",
            "examples": [
              {
                "code": "isEmpty('') // true\nisEmpty('hello') // false\nisEmpty(' ') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.isEmpty from Effect instead",
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Box",
            "signature": {
              "properties": [
                {
                  "name": "paddingHooks",
                  "type": "Partial<Record<\"mainStart\" | \"mainEnd\" | \"crossStart\" | \"crossEnd\", ((ctx: any) => number | ((v: number) => number))[]>>",
                  "optional": false,
                  "readonly": false,
                  "static": false
                },
                {
                  "name": "marginHooks",
                  "type": "Partial<Record<\"mainStart\" | \"mainEnd\" | \"crossStart\" | \"crossEnd\", ((ctx: any) => number | ((v: number) => number))[]>>",
                  "optional": false,
                  "readonly": false,
                  "static": false
                },
                {
                  "name": "borderEdgeHooks",
                  "type": "Partial<Record<\"left\" | \"right\" | \"top\" | \"bottom\", ((ctx: any) => string | ((v: string) => string))[]>>",
                  "optional": false,
                  "readonly": false,
                  "static": false
                },
                {
                  "name": "borderCornerHooks",
                  "type": "Partial<Record<\"topLeft\" | \"topRight\" | \"bottomRight\" | \"bottomLeft\", ((ctx: any) => string | ((v: string) => string))[]>>",
                  "optional": false,
                  "readonly": false,
                  "static": false
                },
                {
                  "name": "borderEdgeStyles",
                  "type": "Partial<Record<\"left\" | \"right\" | \"top\" | \"bottom\", Style>>",
                  "optional": false,
                  "readonly": false,
                  "static": false
                },
                {
                  "name": "borderCornerStyles",
                  "type": "Partial<Record<\"topLeft\" | \"topRight\" | \"bottomRight\" | \"bottomLeft\", Style>>",
                  "optional": false,
                  "readonly": false,
                  "static": false
                },
                {
                  "name": "String",
                  "type": "transformOrFail<typeof Box, typeof String, never>",
                  "optional": false,
                  "readonly": false,
                  "static": true,
                  "description": "Schema for encoding Box to string representation.  \n\nThis is a one-way transformation - boxes can be encoded to strings, but cannot be decoded from strings."
                }
              ],
              "methods": [
                {
                  "name": "toString",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [],
                      "returnType": "string",
                      "returnDoc": "The formatted string",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "content$",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "content",
                          "type": "string | (string | Box)[]",
                          "optional": false,
                          "rest": false,
                          "description": "New content for the box (string or array of strings/boxes)"
                        }
                      ],
                      "returnType": "this",
                      "returnDoc": "The same box (for chaining)",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "pad$",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "padding",
                          "type": "PaddingInput",
                          "optional": false,
                          "rest": false,
                          "description": "Padding configuration"
                        }
                      ],
                      "returnType": "this",
                      "returnDoc": "The same box (for chaining)",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "margin$",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "margin",
                          "type": "MarginInput",
                          "optional": false,
                          "rest": false,
                          "description": "Margin configuration"
                        }
                      ],
                      "returnType": "this",
                      "returnDoc": "The same box (for chaining)",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "border$",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "border",
                          "type": "BorderInput",
                          "optional": false,
                          "rest": false,
                          "description": "Border configuration (style, edges, corners, or combination)"
                        }
                      ],
                      "returnType": "this",
                      "returnDoc": "The same box (for chaining)",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "span$",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "span",
                          "type": "SpanInput",
                          "optional": false,
                          "rest": false,
                          "description": "Span configuration (number = chars, bigint = percentage)"
                        }
                      ],
                      "returnType": "this",
                      "returnDoc": "The same box (for chaining)",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "spanRange$",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "spanRange",
                          "type": "{ readonly main?: { readonly min?: number | undefined; readonly max?: number | undefined; } | undefined; readonly cross?: { readonly min?: number | undefined; readonly max?: number | undefined; } | undefined; }",
                          "optional": false,
                          "rest": false,
                          "description": "Span range constraints per axis"
                        }
                      ],
                      "returnType": "this",
                      "returnDoc": "The same box (for chaining)",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "gap$",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "gap",
                          "type": "GapInput",
                          "optional": false,
                          "rest": false,
                          "description": "Gap configuration (number or object)"
                        }
                      ],
                      "returnType": "this",
                      "returnDoc": "The same box (for chaining)",
                      "throws": []
                    }
                  ],
                  "static": false
                },
                {
                  "name": "content",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to modify"
                        },
                        {
                          "name": "content",
                          "type": "string | (string | Box)[]",
                          "optional": false,
                          "rest": false,
                          "description": "New content for the box (string or array of strings/boxes)"
                        }
                      ],
                      "returnType": "Box",
                      "returnDoc": "A new Box with the updated content",
                      "throws": []
                    }
                  ],
                  "static": true
                },
                {
                  "name": "pad",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to modify"
                        },
                        {
                          "name": "padding",
                          "type": "PaddingInput",
                          "optional": false,
                          "rest": false,
                          "description": "Padding configuration"
                        }
                      ],
                      "returnType": "Box",
                      "returnDoc": "A new Box with the padding applied",
                      "throws": []
                    }
                  ],
                  "static": true
                },
                {
                  "name": "margin",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to modify"
                        },
                        {
                          "name": "margin",
                          "type": "MarginInput",
                          "optional": false,
                          "rest": false,
                          "description": "Margin configuration"
                        }
                      ],
                      "returnType": "Box",
                      "returnDoc": "A new Box with the margin applied",
                      "throws": []
                    }
                  ],
                  "static": true
                },
                {
                  "name": "border",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to modify"
                        },
                        {
                          "name": "border",
                          "type": "BorderInput",
                          "optional": false,
                          "rest": false,
                          "description": "Border configuration"
                        }
                      ],
                      "returnType": "Box",
                      "returnDoc": "A new Box with the border applied",
                      "throws": []
                    }
                  ],
                  "static": true
                },
                {
                  "name": "span",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to modify"
                        },
                        {
                          "name": "span",
                          "type": "SpanInput",
                          "optional": false,
                          "rest": false,
                          "description": "Span configuration (number = chars, bigint = percentage)"
                        }
                      ],
                      "returnType": "Box",
                      "returnDoc": "A new Box with the span applied",
                      "throws": []
                    }
                  ],
                  "static": true
                },
                {
                  "name": "spanRange",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to modify"
                        },
                        {
                          "name": "spanRange",
                          "type": "{ readonly main?: { readonly min?: number | undefined; readonly max?: number | undefined; } | undefined; readonly cross?: { readonly min?: number | undefined; readonly max?: number | undefined; } | undefined; }",
                          "optional": false,
                          "rest": false,
                          "description": "Span range constraints per axis"
                        }
                      ],
                      "returnType": "Box",
                      "returnDoc": "A new Box with the span range applied",
                      "throws": []
                    }
                  ],
                  "static": true
                },
                {
                  "name": "gap",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to modify"
                        },
                        {
                          "name": "gap",
                          "type": "GapInput",
                          "optional": false,
                          "rest": false,
                          "description": "Gap configuration (number or object)"
                        }
                      ],
                      "returnType": "Box",
                      "returnDoc": "A new Box with the gap applied",
                      "throws": []
                    }
                  ],
                  "static": true
                },
                {
                  "name": "encode",
                  "overloads": [
                    {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "box",
                          "type": "Box",
                          "optional": false,
                          "rest": false,
                          "description": "The box to render"
                        }
                      ],
                      "returnType": "string",
                      "returnDoc": "The formatted string representation",
                      "throws": []
                    }
                  ],
                  "static": true
                }
              ],
              "_tag": "ClassSignatureModel"
            },
            "description": "Box structure with content and optional styling.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1248
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "OrientationSchema",
            "signature": {
              "type": "Literal<[\"vertical\", \"horizontal\"]>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Orientation determines the flow direction of the box.  \n\n- `vertical`: Content flows top-to-bottom (main axis = vertical) - `horizontal`: Content flows left-to-right (main axis = horizontal)",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 137
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Orientation",
            "signature": {
              "text": "type Orientation = typeof OrientationSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Orientation type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 144
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PaddingSchema",
            "signature": {
              "type": "Struct<{ mainStart: optional<typeof Number>; mainEnd: optional<typeof Number>; crossStart: optional<typeof Number>; crossEnd: optional<typeof Number>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Padding configuration using logical properties.  \n\nLogical properties adapt to orientation: - `mainStart`/`mainEnd`: Along the flow direction - `crossStart`/`crossEnd`: Perpendicular to flow",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 155
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Padding",
            "signature": {
              "text": "type Padding = typeof PaddingSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Padding configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 190
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PaddingInput",
            "signature": {
              "text": "type PaddingInput = AxisHand.Input | WithHooks<Padding, 'padding'>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Padding input accepting AxisHand notation and hook functions.  \n\nSupports AxisHand patterns: - Single value: `2`  all sides - Axis shorthands: `[2, 4]`  [main, cross] - Binary axis: `[[1, 2], [3, 4]]`  [[mainStart, mainEnd], [crossStart, crossEnd]] - Per-axis arrays: `[[1, 2], 4]`  asymmetric main, symmetric cross - Object: `{ main: [1, 2], cross: 4 }` - With hooks: `{ main: { start: (ctx) => 2 } }`",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 205
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "MarginSchema",
            "signature": {
              "type": "Struct<{ mainStart: optional<typeof Number>; mainEnd: optional<typeof Number>; crossStart: optional<typeof Number>; crossEnd: optional<typeof Number>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Margin configuration using logical properties.  \n\nLogical properties adapt to orientation (same as Padding).",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 214
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Margin",
            "signature": {
              "text": "type Margin = typeof MarginSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Margin configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 249
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "MarginInput",
            "signature": {
              "text": "type MarginInput = AxisHand.Input | WithHooks<Margin, 'margin'>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Margin input accepting AxisHand notation and hook functions.  \n\nSupports AxisHand patterns (same as PaddingInput).",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 258
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "SpanValue",
            "signature": {
              "text": "type SpanValue = number | bigint",
              "_tag": "TypeSignatureModel"
            },
            "description": "Span value type - size in characters or percentage of parent.  \n\n- `number` (1): Absolute size in characters - `bigint`: Percentage of parent span (e.g., `50n` = 50%)",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 268
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "SpanSchema",
            "signature": {
              "type": "Struct<{ main: optional<Union<[typeof Number, typeof BigIntFromSelf]>>; cross: optional<Union<[typeof Number, typeof BigIntFromSelf]>>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Span configuration using logical properties.  \n\nDefines exact/desired size along each axis: - `main`: Size along flow direction (mainSpan) - `cross`: Size perpendicular to flow (crossSpan)  \n\nPercentage values (bigint) are resolved relative to parent's available span.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 281
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Span",
            "signature": {
              "text": "type Span = typeof SpanSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Span configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 306
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "SpanInput",
            "signature": {
              "text": "type SpanInput = AxisHand.Input<SpanValue>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Span input accepting AxisHand notation.  \n\nSupports AxisHand patterns with SpanValue (number | bigint): - Single value: `80`  main and cross both 80 chars - Single percentage: `50n`  main and cross both 50% of parent - Axis shorthands: `[50n, 80]`  main 50%, cross 80 chars - Binary axis: `[[40, 50n], [80, 100]]`  different start/end (unusual for span) - Object: `{ main: 50n, cross: 80 }`",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 320
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "SpanRangeSchema",
            "signature": {
              "type": "Struct<{ main: optional<Struct<{ min: optional<typeof Number>; max: optional<typeof Number>; }>>; cross: optional<Struct<{ min: optional<typeof Number>; max: optional<typeof Number>; }>>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Span range constraints (min/max) using logical properties.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 327
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "SpanRange",
            "signature": {
              "text": "type SpanRange = typeof SpanRangeSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Span range configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 350
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GapSchema",
            "signature": {
              "type": "Struct<{ main: optional<typeof Number>; cross: optional<typeof Number>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Gap configuration using logical properties.  \n\nDefines space between array items (container property): - Vertical orientation: main=newlines between items, cross=spaces between items - Horizontal orientation: main=spaces between items, cross=newlines between items",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 361
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Gap",
            "signature": {
              "text": "type Gap = typeof GapSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Gap configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 382
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GapInput",
            "signature": {
              "text": "type GapInput = number | Gap",
              "_tag": "TypeSignatureModel"
            },
            "description": "Gap input accepting number or object with logical properties.  \n\n- `number`: Same gap on both axes - `{ main?: number, cross?: number }`: Per-axis gaps",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 392
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "BorderStyleSchema",
            "signature": {
              "type": "Literal<[\"single\", \"double\", \"rounded\", \"bold\", \"ascii\"]>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Border style presets.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 399
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "BorderStyle",
            "signature": {
              "text": "type BorderStyle = typeof BorderStyleSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border style preset type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 406
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "BorderEdgesSchema",
            "signature": {
              "type": "Struct<{ top: optional<typeof String>; right: optional<typeof String>; bottom: optional<typeof String>; left: optional<typeof String>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Border edge characters (physical coordinates).",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 413
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "BorderEdges",
            "signature": {
              "text": "type BorderEdges = typeof BorderEdgesSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border edge configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 440
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "BorderCornersSchema",
            "signature": {
              "type": "Struct<{ topLeft: optional<typeof String>; topRight: optional<typeof String>; bottomRight: optional<typeof String>; bottomLeft: optional<typeof String>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Border corner characters (physical coordinates).",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 447
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "BorderCorners",
            "signature": {
              "text": "type BorderCorners = typeof BorderCornersSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border corner configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 474
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "BorderEdgesInput",
            "signature": {
              "text": "type BorderEdgesInput =\n  | Clockhand.Value<string | CharStyle>\n  | WithHooks<BorderEdges, 'border.edges'>\n  | {\n    [K in keyof BorderEdges]?:\n      | string\n      | CharStyle\n      | WithHook<string | undefined, StyleCategoryMap[`border.edges.${K & string}`]>\n  }",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border edge input supporting Clockhand notation, CharStyle, and hook functions.  \n\nSupports Clockhand patterns: - Single value: `''`  all edges - Single styled: `{ char: '', color: { foreground: 'blue' } }`  all edges - Array: `['', '', '', '']`  [top, right, bottom, left] - Object: `{ top: '', left: '' }` - Object with CharStyle: `{ top: { char: '', color: { foreground: 'red' } } }` - With hooks: `{ top: (ctx) => '' }`",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 489
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "BorderCornersInput",
            "signature": {
              "text": "type BorderCornersInput =\n  | Clockhand.Value<string | CharStyle>\n  | WithHooks<BorderCorners, 'border.corners'>\n  | {\n    [K in keyof BorderCorners]?:\n      | string\n      | CharStyle\n      | WithHook<string | undefined, StyleCategoryMap[`border.corners.${K & string}`]>\n  }",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border corner input supporting Clockhand notation, CharStyle, and hook functions.  \n\nSupports Clockhand patterns: - Single value: `'+'`  all corners - Single styled: `{ char: '+', color: { foreground: 'yellow' }, bold: true }`  all corners - Array: `['', '', '', '']`  [topLeft, topRight, bottomRight, bottomLeft] (clockwise) - Object: `{ topLeft: '', topRight: '' }` - Object with CharStyle: `{ topLeft: { char: '', color: { foreground: 'red' }, bold: true } }` - With hooks: `{ topLeft: (ctx) => '' }`",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 512
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "BorderCharsInput",
            "signature": {
              "text": "type BorderCharsInput = {\n  edges?: BorderEdgesInput\n  corners?: BorderCornersInput\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border character configuration input with nested edges/corners.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 527
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "BorderSchema",
            "signature": {
              "type": "Struct<{ style: optional<Literal<[\"single\", \"double\", \"rounded\", \"bold\", \"ascii\"]>>; edges: optional<Struct<{ top: optional<typeof String>; right: optional<typeof String>; bottom: optional<typeof String>; left: optional<typeof String>; }>>; corners: optional<Struct<{ topLeft: optional<typeof String>; topRight: optional<typeof String>; bottomRight: optional<typeof String>; bottomLeft: optional<typeof String>; }>>; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Border configuration.  \n\nCan specify a preset style, custom edges, custom corners, or a combination. Resolution order: style  edges override  corners override.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 540
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Border",
            "signature": {
              "text": "type Border = typeof BorderSchema.Type",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border configuration type.",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 564
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "BorderInput",
            "signature": {
              "text": "type BorderInput = {\n  style?: BorderStyle\n  edges?: BorderEdgesInput\n  corners?: BorderCornersInput\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Border configuration input with hook support.  \n\nSupports: - `style`: Preset border style (provides edges and corners) - `edges`: Edge characters (with Clockhand support) - `corners`: Corner characters (with Clockhand support)  \n\nResolution order: style  edges/corners override",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 578
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "BoxContent",
            "signature": {
              "text": "type BoxContent = string | StyledText | readonly (string | StyledText | Box)[]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Content type for Box - can be a string, styled text, or array of these and boxes.  \n\nSupports: - Plain strings: `'Hello'` - Styled text: `{ text: 'Hello', color: { foreground: 'red' }, bold: true }` - Arrays: `['Header', { text: 'Body', color: { foreground: 'green' } }, Box.make(...)]`",
            "examples": [],
            "category": "Text Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str",
                    "box"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "box",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1241
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "defaultRender",
            "signature": {
              "type": "(value: string[]) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Default render function for string builders. Joins lines with newline characters.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 12
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Builder",
            "signature": {
              "text": "interface Builder {\n  /**\n   * Add lines to the builder.\n   * @param linesInput - Lines to add (null values are filtered out)\n   * @returns The builder instance for chaining\n   */\n  (...linesInput: LinesInput): Builder\n  /**\n   * Add content using template literal syntax.\n   * @param strings - Template string array\n   * @param values - Interpolated values\n   * @returns The builder instance for chaining\n   */\n  (strings: TemplateStringsArray, ...values: string[]): Builder\n  /**\n   * The internal state containing accumulated lines.\n   */\n  state: State\n  /**\n   * Render the accumulated lines into a single string.\n   * @returns The rendered string\n   */\n  render: () => string\n  /**\n   * Alias for render() to support string coercion.\n   * @returns The rendered string\n   */\n  toString(): string\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "String builder interface for constructing multi-line strings. Supports both function call syntax and template literal syntax.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 19
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "LinesInput",
            "signature": {
              "text": "type LinesInput = (Line | null)[]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Input type for lines - allows null values which are filtered out.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 53
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Lines",
            "signature": {
              "text": "type Lines = Line[]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Array of line strings.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 59
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Line",
            "signature": {
              "text": "type Line = string",
              "_tag": "TypeSignatureModel"
            },
            "description": "A single line of text.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 65
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "State",
            "signature": {
              "text": "interface State {\n  /**\n   * Accumulated lines.\n   */\n  lines: Lines\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Internal state of the string builder.",
            "examples": [],
            "category": "Builder",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "builder",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 71
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "RegExpMatchResult",
            "signature": {
              "text": "type RegExpMatchResult<$Matches extends Matches> =\n  & Omit<RegExpMatchArray, 'groups'>\n  & {\n      groups:\n        $Matches['groups'] extends readonly [MatchItem,... readonly MatchItem[]]\n          ? ArrMut.ReduceWithIntersection<ToGroupsProperties<$Matches['groups']>>\n          : undefined\n    }\n  & (\n      $Matches extends { indicies: readonly [MatchItem,... readonly MatchItem[]] }\n        ? [originalValue: string, ...$Matches['indicies']]\n        : [originalValue: string]\n    )",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "pattern",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "matches",
                      "constraint": "Matches"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "pattern",
                      "type": "RegExp",
                      "optional": false,
                      "rest": false,
                      "description": "The regular expression pattern"
                    }
                  ],
                  "returnType": "Pattern<matches>",
                  "returnDoc": "A typed pattern that preserves capture group information",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a typed pattern from a regular expression. Enables type-safe capture groups when used with match.",
            "examples": [
              {
                "code": "const p = pattern<{ groups: ['name', 'age'] }>(/(?<name>\\w+) is (?<age>\\d+)/)\nconst result = match('John is 25', p)\nif (Option.isSome(result)) {\n  console.log(result.value.groups.name) // 'John' (typed)\n  console.log(result.value.groups.age) // '25' (typed)\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Pattern Matching",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 53
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Matches",
            "signature": {
              "text": "type Matches = {\n  groups?: (string | undefined)[]\n  indicies?: (string | undefined)[]\n}",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 58
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "match",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "matches",
                      "constraint": "Matches"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "string",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to match against"
                    },
                    {
                      "name": "pattern",
                      "type": "RegExp | Pattern<matches>",
                      "optional": false,
                      "rest": false,
                      "description": "Regular expression or typed pattern"
                    }
                  ],
                  "returnType": "Option<RegExpMatchResult<matches>>",
                  "returnDoc": "Option of match result with typed capture groups, or None if no match",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Match a string against a pattern with type-safe results.",
            "examples": [
              {
                "code": "const result = match('hello world', /hello (\\w+)/)\nif (Option.isSome(result)) {\n  console.log(result.value[0]) // 'hello world'\n  console.log(result.value[1]) // 'world'\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Pattern Matching",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 80
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "PatternInput",
            "signature": {
              "text": "type PatternInput = string | RegExp",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 90
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "isMatch",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to test"
                    },
                    {
                      "name": "pattern",
                      "type": "PatternInput",
                      "optional": false,
                      "rest": false,
                      "description": "String for exact match or RegExp for pattern match"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value matches the pattern",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a string matches a pattern.",
            "examples": [
              {
                "code": "isMatch('hello', 'hello') // true\nisMatch('hello', /^h.*o$/) // true\nisMatch('world', 'hello') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 105
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isMatchOn",
            "signature": {
              "type": "(value: string) => (pattern: PatternInput) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isMatch with value first.",
            "examples": [
              {
                "code": "const isHello = isMatchOn('hello')\nisHello('hello') // true\nisHello(/^h.*o$/) // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 124
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isMatchWith",
            "signature": {
              "type": "(pattern: PatternInput) => (value: string) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isMatch with pattern first.",
            "examples": [
              {
                "code": "const matchesHello = isMatchWith('hello')\nmatchesHello('hello') // true\nmatchesHello('world') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 138
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isntMatch",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "pattern",
                      "type": "PatternInput",
                      "optional": false,
                      "rest": false,
                      "description": "String for exact match or RegExp for pattern match"
                    }
                  ],
                  "returnType": "(value: string) => boolean",
                  "returnDoc": "Function that takes a value and returns true if it doesn't match",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a string does not match a pattern.",
            "examples": [
              {
                "code": "const notHello = isntMatch('hello')\nnotHello('world') // true\nnotHello('hello') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 152
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isntMatchOn",
            "signature": {
              "type": "(pattern: PatternInput) => (value: string) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isntMatch with value first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 162
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isntMatchWith",
            "signature": {
              "type": "(value: string) => (pattern: PatternInput) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isntMatch with pattern first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 170
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "PatternsInput",
            "signature": {
              "text": "type PatternsInput = ArrMut.Maybe<string | RegExp>",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 174
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isMatchAny",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to test"
                    },
                    {
                      "name": "patterns",
                      "type": "PatternsInput",
                      "optional": false,
                      "rest": false,
                      "description": "Array of strings or RegExp patterns (or a single pattern)"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value matches any pattern",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a string matches any of the provided patterns.",
            "examples": [
              {
                "code": "isMatchAny('hello', ['hello', 'world']) // true\nisMatchAny('hello', [/^h/, /o$/]) // true\nisMatchAny('foo', ['hello', 'world']) // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 189
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isMatchAnyOn",
            "signature": {
              "type": "(value: string) => (patterns: PatternsInput) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isMatchAny with value first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 200
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isMatchAnyWith",
            "signature": {
              "type": "(patterns: PatternsInput) => (value: string) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isMatchAny with patterns first.",
            "examples": [
              {
                "code": "const matchesGreeting = isMatchAnyWith(['hello', 'hi', /^hey/])\nmatchesGreeting('hello') // true\nmatchesGreeting('hey there') // true\nmatchesGreeting('goodbye') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 215
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isNotMatchAny",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "patternOrPatterns",
                      "type": "PatternsInput",
                      "optional": false,
                      "rest": false,
                      "description": "Array of strings or RegExp patterns (or a single pattern)"
                    }
                  ],
                  "returnType": "(value: string) => boolean",
                  "returnDoc": "Function that takes a value and returns true if it doesn't match any pattern",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Check if a string does not match any of the provided patterns.",
            "examples": [
              {
                "code": "const notGreeting = isNotMatchAny(['hello', 'hi'])\nnotGreeting('goodbye') // true\nnotGreeting('hello') // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 229
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isNotMatchAnyOn",
            "signature": {
              "type": "(patternOrPatterns: PatternsInput) => (value: string) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isNotMatchAny with value first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 239
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isNotMatchAnyWith",
            "signature": {
              "type": "(value: string) => (patternOrPatterns: PatternsInput) => boolean",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of isNotMatchAny with patterns first.",
            "examples": [],
            "category": "Predicates",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "match",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 247
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "titlizeSlug",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "str",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The slug string to convert"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The title-cased string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Convert a URL slug to title case. Replaces URL path separators with spaces and converts to title case.",
            "examples": [
              {
                "code": "titlizeSlug('foo/bar/baz') // 'Foo Bar Baz'\ntitlizeSlug('the/quick/brown/fox') // 'The Quick Brown Fox'\ntitlizeSlug('hello-world') // 'Hello-World' (hyphens are preserved)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "misc",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "ensureEnd",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "string",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to check"
                    },
                    {
                      "name": "ending",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The ending to ensure"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The string with the ending ensured",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Ensure a string ends with a specific ending, adding it if not present.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "misc",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 28
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "trim",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to trim"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The trimmed string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Remove whitespace from both ends of a string.",
            "examples": [
              {
                "code": "trim('  hello  ') // 'hello'\ntrim('\\n\\thello\\n\\t') // 'hello'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.trim from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeading",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "replacement",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to replace the matcher with"
                    },
                    {
                      "name": "matcher",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to match at the beginning"
                    },
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to operate on"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The string with leading matcher replaced",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Replace the leading occurrence of a matcher string with a replacement.",
            "examples": [
              {
                "code": "replaceLeading('$', '//', '// comment') // '$ comment'\nreplaceLeading('', 'www.', 'www.example.com') // 'example.com'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 52
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeadingWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "replacement",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to replace the matcher with"
                    }
                  ],
                  "returnType": "(matcher: string) => (value: string) => string",
                  "returnDoc": "Function that takes matcher, then value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of replaceLeading with replacement first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 63
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceLeadingOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to operate on"
                    }
                  ],
                  "returnType": "(replacement: string) => (matcher: string) => string",
                  "returnDoc": "Function that takes replacement, then matcher",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of replaceLeading with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 73
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "stripLeading",
            "signature": {
              "type": "(matcher: string) => (value: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Remove the leading occurrence of a matcher string. Alias for `replaceLeadingWith('')`.",
            "examples": [
              {
                "code": "const removePrefix = stripLeading('//')\nremovePrefix('// comment') // ' comment'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 89
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "replace",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "replacement",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to replace matches with"
                    },
                    {
                      "name": "matcher",
                      "type": "PatternsInput",
                      "optional": false,
                      "rest": false,
                      "description": "String or RegExp pattern(s) to match"
                    },
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to operate on"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The string with all matches replaced",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Replace all occurrences of patterns with a replacement string.",
            "examples": [
              {
                "code": "replace('_', ' ', 'hello world') // 'hello_world'\nreplace('X', /[aeiou]/g, 'hello') // 'hXllX'\nreplace('-', [' ', '_'], 'hello world_test') // 'hello-world-test'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.replace or String.replaceAll from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 114
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "replacement",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to replace matches with"
                    }
                  ],
                  "returnType": "(matcher: PatternsInput) => (value: string) => string",
                  "returnDoc": "Function that takes matcher, then value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of replace with replacement first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 127
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "replaceOn",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to operate on"
                    }
                  ],
                  "returnType": "(replacement: string) => (matcher: PatternsInput) => string",
                  "returnDoc": "Function that takes replacement, then matcher",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Curried version of replace with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 137
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "append",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value1",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The base string"
                    },
                    {
                      "name": "value2",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to append"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The concatenated string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Append a string to another string.",
            "examples": [
              {
                "code": "append('hello', ' world') // 'hello world'\nappend('foo', 'bar') // 'foobar'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.concat from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 162
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "appendOn",
            "signature": {
              "type": "(value1: string) => (value2: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of append with value1 first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 172
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "appendWith",
            "signature": {
              "type": "(value2: string) => (value1: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of append with value2 first.",
            "examples": [
              {
                "code": "const addWorld = appendWith(' world')\naddWorld('hello') // 'hello world'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 185
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "prepend",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value1",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to prepend"
                    },
                    {
                      "name": "value2",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The base string"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The concatenated string with value1 first",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Prepend a string to another string.",
            "examples": [
              {
                "code": "prepend('hello ', 'world') // 'hello world'\nprepend('pre', 'fix') // 'prefix'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.concat from Effect instead (with arguments swapped)",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 202
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "prependOn",
            "signature": {
              "type": "(value1: string) => (value2: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of prepend with value1 first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 212
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "prependWith",
            "signature": {
              "type": "(value2: string) => (value1: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of prepend with value2 first.",
            "examples": [
              {
                "code": "const toWorld = prependWith('world')\ntoWorld('hello ') // 'hello world'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 225
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "repeat",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to repeat"
                    },
                    {
                      "name": "count",
                      "type": "number",
                      "optional": false,
                      "rest": false,
                      "description": "The number of times to repeat"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The repeated string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Repeat a string a specified number of times.",
            "examples": [
              {
                "code": "repeat('a', 3) // 'aaa'\nrepeat('hello', 2) // 'hellohello'\nrepeat('-', 10) // '----------'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.repeat from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 249
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "repeatOn",
            "signature": {
              "type": "(value: string) => (count: number) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of repeat with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 259
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "repeatWith",
            "signature": {
              "type": "(count: number) => (value: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of repeat with count first.",
            "examples": [
              {
                "code": "const triple = repeatWith(3)\ntriple('ha') // 'hahaha'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 272
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurrounding",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "str",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to process"
                    },
                    {
                      "name": "target",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The character to remove from both ends"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The string with surrounding target characters removed",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Remove all occurrences of a target character from the beginning and end of a string.",
            "examples": [
              {
                "code": "removeSurrounding('   hello   ', ' ') // 'hello'\nremoveSurrounding('***test***', '*') // 'test'\nremoveSurrounding('aaa', 'a') // ''",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 295
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "removeSurroundingOn",
            "signature": {
              "type": "(str: string) => (target: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of removeSurrounding with str first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 321
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingWith",
            "signature": {
              "type": "(target: string) => (str: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of removeSurrounding with target first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 329
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "truncate",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "str",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to truncate"
                    },
                    {
                      "name": "maxLength",
                      "type": "number",
                      "optional": true,
                      "rest": false,
                      "defaultValue": "80",
                      "description": "Maximum length of the result (default: 80)"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The truncated string with ellipsis if needed",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Truncate a string to a maximum length, adding ellipsis if truncated.",
            "examples": [
              {
                "code": "truncate('hello world', 8) // 'hello...'\ntruncate('short', 10) // 'short'\ntruncate('very long text that needs truncating') // 'very long text that needs truncating...' (if > 80 chars)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 352
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "truncateOn",
            "signature": {
              "type": "(str: string) => (maxLength?: number | undefined) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of truncate with str first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 366
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "truncateWith",
            "signature": {
              "type": "(maxLength?: number | undefined) => (str: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of truncate with maxLength first.",
            "examples": [
              {
                "code": "const truncate10 = truncateWith(10)\ntruncate10('hello world') // 'hello w...'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 379
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "strip",
            "signature": {
              "type": "(matcher: PatternsInput) => (value: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Remove all occurrences of patterns from a string. Alias for `replaceWith('')`.",
            "examples": [
              {
                "code": "const removeVowels = strip(/[aeiou]/g)\nremoveVowels('hello world') // 'hll wrld'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 401
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingSpaceRegular",
            "signature": {
              "type": "(str: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Remove regular spaces from the beginning and end of a string. Pre-configured removeSurroundingWith for regular spaces.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 410
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "removeSurroundingSpaceNoBreak",
            "signature": {
              "type": "(str: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Remove non-breaking spaces from the beginning and end of a string. Pre-configured removeSurroundingWith for non-breaking spaces.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "replace",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 419
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "split",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The string to split"
                    },
                    {
                      "name": "separator",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The separator to split on"
                    }
                  ],
                  "returnType": "string[]",
                  "returnDoc": "Array of substrings",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Split a string into an array of substrings using a separator.",
            "examples": [
              {
                "code": "split('a,b,c', ',') // ['a', 'b', 'c']\nsplit('hello world', ' ') // ['hello', 'world']\nsplit('', ',') // []",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.split from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "splitOn",
            "signature": {
              "type": "(value: string) => (separator: string) => string[]",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of split with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 29
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "splitWith",
            "signature": {
              "type": "(separator: string) => (value: string) => string[]",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of split with separator first.",
            "examples": [
              {
                "code": "const splitByComma = splitWith(',')\nsplitByComma('a,b,c') // ['a', 'b', 'c']",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 42
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "join",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "string[]",
                      "optional": false,
                      "rest": false,
                      "description": "Array of strings to join"
                    },
                    {
                      "name": "separator",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The separator to place between strings"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The joined string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Join an array of strings into a single string with a separator.",
            "examples": [
              {
                "code": "join(['a', 'b', 'c'], ',') // 'a,b,c'\njoin(['hello', 'world'], ' ') // 'hello world'\njoin([], ',') // ''",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use Array.join from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 58
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "joinOn",
            "signature": {
              "type": "(value: string[]) => (separator: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of join with value first.",
            "examples": [],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 68
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "joinWith",
            "signature": {
              "type": "(separator: string) => (value: string[]) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of join with separator first.",
            "examples": [
              {
                "code": "const joinWithComma = joinWith(',')\njoinWithComma(['a', 'b', 'c']) // 'a,b,c'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 81
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "merge",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "string1",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The first string"
                    },
                    {
                      "name": "string2",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "The second string"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "The concatenated string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Merge two strings together (concatenate).",
            "examples": [
              {
                "code": "merge('hello', ' world') // 'hello world'\nmerge('foo', 'bar') // 'foobar'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "deprecated": "Use String.concat from Effect instead",
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 96
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "mergeOn",
            "signature": {
              "type": "(string1: string) => (string2: string) => string",
              "_tag": "ValueSignatureModel"
            },
            "description": "Curried version of merge with string1 first.",
            "examples": [
              {
                "code": "const mergeWithHello = mergeOn('hello')\nmergeWithHello(' world') // 'hello world'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Transformation",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "split",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 111
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "table",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "input",
                      "type": "{ data: Record<string, string>; separator?: string | false | undefined; separatorAlignment?: boolean; }",
                      "optional": false,
                      "rest": false,
                      "description": "Configuration object"
                    }
                  ],
                  "returnType": "string",
                  "returnDoc": "Formatted table string with aligned columns",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Format a key-value object as an aligned table string.",
            "examples": [
              {
                "code": "table({\n  data: { name: 'John', age: '25', city: 'NYC' }\n})\n// Returns:\n// name  John\n// age   25\n// city  NYC\n\ntable({\n  data: { foo: 'bar', hello: 'world' },\n  separator: ' = ',\n  separatorAlignment: false\n})\n// Returns:\n// foo =   bar\n// hello = world",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Formatting",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "table",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 32
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "interpolate",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "template",
                      "type": "string",
                      "optional": false,
                      "rest": false,
                      "description": "Template string containing $variable placeholders"
                    }
                  ],
                  "returnType": "(args: TemplateArgs) => string",
                  "returnDoc": "Function that takes args object and returns interpolated string",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Interpolate variables into a template string using $variable syntax.",
            "examples": [
              {
                "code": "const greeting = interpolate('Hello ${name}, you are ${age} years old')\ngreeting({ name: 'John', age: 25 }) // 'Hello John, you are 25 years old'\n\nconst template = interpolate('${greeting} ${name}!')\ntemplate({ greeting: 'Hi', name: 'Alice' }) // 'Hi Alice!'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Template",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "template",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "templateVariablePattern",
            "signature": {
              "type": "RegExp",
              "_tag": "ValueSignatureModel"
            },
            "description": "Regular expression pattern to match template variables in $variable format. Captures the variable name inside the braces.",
            "examples": [],
            "category": "Template",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "template",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 30
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "TemplateArgs",
            "signature": {
              "text": "type TemplateArgs = Record<string, Json.Value>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Arguments object for template interpolation. Maps variable names to their JSON-serializable values.",
            "examples": [],
            "category": "Template",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "template",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 37
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "EndsWith",
            "signature": {
              "text": "type EndsWith<S extends string, T extends string> = S extends `${string}${T}` ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a string ends with a specific suffix.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "StartsWith",
            "signature": {
              "text": "type StartsWith<S extends string, T extends string> = S extends `${T}${string}` ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a string starts with a specific prefix.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 19
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "LastSegment",
            "signature": {
              "text": "type LastSegment<S extends string> = S extends `${string}/${infer Rest}` ? LastSegment<Rest>\n  : S",
              "_tag": "TypeSignatureModel"
            },
            "description": "Extract the last segment from a path-like string (after the last '/').",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 25
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "RemoveTrailingSlash",
            "signature": {
              "text": "type RemoveTrailingSlash<S extends string> = S extends `${infer Rest}/` ? Rest extends '' ? '/' : Rest\n  : S",
              "_tag": "TypeSignatureModel"
            },
            "description": "Remove trailing slash from a string.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 32
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Split",
            "signature": {
              "text": "type Split<S extends string, D extends string, Acc extends string[] = []> = S extends '' ? Acc\n  : S extends `${infer Segment}${D}${infer Rest}` ? Segment extends '' ? Split<Rest, D, Acc>\n    : Segment extends '.' ? Split<Rest, D, Acc>\n    : Split<Rest, D, [...Acc, Segment]>\n  : S extends '.' ? Acc\n  : [...Acc, S]",
              "_tag": "TypeSignatureModel"
            },
            "description": "Split a string by a delimiter, filtering out empty segments and '.' segments. This is useful for path-like strings.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 40
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Contains",
            "signature": {
              "text": "type Contains<S extends string, C extends string> = S extends `${string}${C}${string}` ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if string contains a character.",
            "examples": [],
            "category": "Type-Level Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 51
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "LiteralOnly",
            "signature": {
              "text": "type LiteralOnly<\n  T extends string,\n  $ErrorMessage extends string = 'Expected a literal string',\n> = string extends T ? Ts.StaticError<\n    $ErrorMessage,\n    { ReceivedType: T },\n    'Use a string literal instead of string type'\n  >\n  : T",
              "_tag": "TypeSignatureModel"
            },
            "description": "Constraint that only accepts literal strings. Returns StaticError for non-literal string type with customizable error message.",
            "examples": [],
            "category": "Type-Level Utilities  T - The string type to check  $ErrorMessage - Custom error message to display when T is not a literal",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 60
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Length",
            "signature": {
              "text": "type Length<$S extends string, $Acc extends 0[] = []> = $S extends `${string}${infer __rest__}`\n  ? Length<__rest__, [...$Acc, 0]>\n  : $Acc['length']",
              "_tag": "TypeSignatureModel"
            },
            "description": "Get the length of a string type using tuple counting.  \n\nUses recursive template literal parsing with tuple accumulation to count characters. Limited by TypeScript's recursion depth (typically ~50 levels).",
            "examples": [
              {
                "code": "type L1 = Str.Length<'hello'> // 5\ntype L2 = Str.Length<''> // 0\ntype L3 = Str.Length<'a'> // 1",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type-Level Utilities  $S - The string to measure  $Acc - Accumulator tuple for counting (internal)",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 87
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PadEnd",
            "signature": {
              "text": "type PadEnd<\n  $S extends string,\n  $TargetLen extends number,\n  $Fill extends string = '_',\n  $Acc extends 0[] = [],\n> = Length<$S> extends $TargetLen ? $S\n  : $Acc['length'] extends 50 // Recursion limit safety\n    ? $S\n    : PadEnd<`${$S}${$Fill}`, $TargetLen, $Fill, [...$Acc, 0]>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Pad a string to a target length by appending a fill character.  \n\nIf the string is already at or exceeds the target length, returns it unchanged. Limited by TypeScript's recursion depth (~50 iterations).",
            "examples": [
              {
                "code": "type P1 = Str.PadEnd<'foo', 10, '_'> // 'foo_______'\ntype P2 = Str.PadEnd<'hello', 3, '_'> // 'hello' (already longer)\ntype P3 = Str.PadEnd<'abc', 5, '0'> // 'abc00'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type-Level Utilities  $S - The string to pad  $TargetLen - The desired final length  $Fill - The character to use for padding (default: '_')  $Acc - Accumulator for recursion depth tracking (internal)",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 111
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "PadStart",
            "signature": {
              "text": "type PadStart<\n  $S extends string,\n  $TargetLen extends number,\n  $Fill extends string = '0',\n  $Acc extends 0[] = [],\n> = Length<$S> extends $TargetLen ? $S\n  : $Acc['length'] extends 50 // Recursion limit safety\n    ? $S\n    : PadStart<`${$Fill}${$S}`, $TargetLen, $Fill, [...$Acc, 0]>",
              "_tag": "TypeSignatureModel"
            },
            "description": "Pad a string to a target length by prepending a fill character.  \n\nIf the string is already at or exceeds the target length, returns it unchanged. Limited by TypeScript's recursion depth (~50 iterations).",
            "examples": [
              {
                "code": "type P1 = Str.PadStart<'42', 5, '0'> // '00042'\ntype P2 = Str.PadStart<'hello', 3, '0'> // 'hello' (already longer)\ntype P3 = Str.PadStart<'x', 3, ' '> // '  x'",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type-Level Utilities  $S - The string to pad  $TargetLen - The desired final length  $Fill - The character to use for padding (default: '0')  $Acc - Accumulator for recursion depth tracking (internal)",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "domains",
                    "str"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-level",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 141
            },
            "_tag": "type",
            "type": "type-alias"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./test",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "test"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "Enhanced test utilities for table-driven testing with Vitest.  \n\nProvides builder API and type-safe utilities for parameterized tests with built-in support for todo, skip, and only cases.",
        "category": "Development",
        "exports": [
          {
            "name": "Test",
            "signature": {
              "text": "export * as Test",
              "_tag": "TypeSignatureModel"
            },
            "description": "Enhanced test utilities for table-driven testing with Vitest.  \n\nProvides builder API and type-safe utilities for parameterized tests with built-in support for todo, skip, and only cases.",
            "examples": [
              {
                "code": "const add = (a: number, b: number) => a + b\n\nTest.describe('addition')\n  .on(add)\n  .cases(\n    [[2, 3], 5],\n    [[0, 0], 0],\n    [[-1, 1], 0]\n  )\n  .test()",
                "title": "Basic table-driven testing with builder API",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "Test.describe('validation')\n  .i<string>()\n  .o<boolean>()\n  .cases(\n    { n: 'valid email', i: 'user@example.com', o: true },\n    { n: 'invalid', i: 'not-email', o: false },\n    { n: 'future feature', todo: 'Not implemented yet' }\n  )\n  .test((input, expected) => {\n    expect(isValid(input)).toBe(expected)\n  })",
                "title": "Custom test logic",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "Test.property(\n  'reversing array twice returns original',\n  fc.array(fc.integer()),\n  (arr) => {\n    const reversed = arr.slice().reverse()\n    const reversedTwice = reversed.slice().reverse()\n    expect(reversedTwice).toEqual(arr)\n  }\n)",
                "title": "Property-based testing",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Development",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "test"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 51
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "test"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Custom Vitest matchers for Effect Schema and equivalence testing.",
              "category": "Assertions",
              "exports": [
                {
                  "name": "Matchers",
                  "signature": {
                    "text": "export * as Matchers",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Custom Vitest matchers for Effect Schema and equivalence testing.",
                  "examples": [],
                  "category": "Assertions",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 6
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "test",
                          "matchers"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "",
                    "exports": []
                  }
                },
                {
                  "name": "property",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "Ts",
                            "constraint": "[unknown, ...unknown[]]"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "args",
                            "type": "[description: string, ...arbitraries: { [K in keyof Ts]: Arbitrary<Ts[K]>; }, predicate: (...args: Ts) => boolean | void]",
                            "optional": true,
                            "rest": true,
                            "description": "Test arguments in order:   - description: The test description   - arbitraries: Fast-check arbitraries for generating test values   - predicate: Function that should hold true for all generated values"
                          }
                        ],
                        "returnType": "void",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Create a property-based test using fast-check within vitest.  \n\n Ts - Tuple type of the arbitrary values.",
                  "examples": [
                    {
                      "code": "// test that array reverse twice returns original\nproperty(\n  'reversing array twice returns original',\n  fc.array(fc.integer()),\n  (arr) => {\n    const reversed = arr.slice().reverse()\n    const reversedTwice = reversed.slice().reverse()\n    expect(reversedTwice).toEqual(arr)\n  }\n)\n\n// test with multiple arbitraries\nproperty(\n  'addition is commutative',\n  fc.integer(),\n  fc.integer(),\n  (a, b) => {\n    expect(a + b).toBe(b + a)\n  }\n)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Property Testing",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "property",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 40
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "on",
                  "signature": {
                    "typeName": "TestBuilder",
                    "entryPoint": {
                      "typeParameters": [
                        {
                          "name": "$fn",
                          "constraint": "Fn.AnyAny"
                        }
                      ],
                      "parameters": [
                        {
                          "name": "$fn",
                          "type": "$fn",
                          "optional": false,
                          "rest": false
                        }
                      ],
                      "returnType": "TestBuilder<UpdateState<BuilderTypeStateEmpty, { fn: $fn; }>>",
                      "throws": []
                    },
                    "chainableMethods": [
                      {
                        "name": "only",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "skip",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "reason",
                                "type": "string | undefined",
                                "optional": true,
                                "rest": false,
                                "description": "Optional reason for skipping (shown in test output)"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "skipIf",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "condition",
                                "type": "() => boolean",
                                "optional": false,
                                "rest": false,
                                "description": "Function that returns true to skip tests"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "concurrent",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "tags",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "tags",
                                "type": "string[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of tag strings"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "name",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "template",
                                "type": "string",
                                "optional": false,
                                "rest": false
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "onlyMatching",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "matcher",
                                "type": "string",
                                "optional": false,
                                "rest": false
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "inputType",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "I"
                              }
                            ],
                            "parameters": [],
                            "returnType": "TestBuilder<UpdateState<State, { input: I; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "contextType",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Ctx",
                                "constraint": "{}",
                                "default": "{}"
                              }
                            ],
                            "parameters": [],
                            "returnType": "TestBuilder<UpdateState<State, { context: Ctx; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "matrix",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "$values",
                                "constraint": "Rec.AnyReadonlyKeyTo<Arr.Any>"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "values",
                                "type": "$values",
                                "optional": false,
                                "rest": false
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { matrix: { [K in keyof $values]: $values[K][number]; }; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "snapshotSerializer",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "serializer",
                                "type": "(output: any, context: { i: State[\"input\"]; n: string; o: State[\"output\"]; } & State[\"context\"]) => string",
                                "optional": false,
                                "rest": false,
                                "description": "Function that takes (output, context) and returns formatted string"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "snapshotSchemas",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "schemas",
                                "type": "any[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of Effect schemas to register for automatic encoding.                  Typically union types that cover all possible schema variants."
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "on",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Fn",
                                "constraint": "Fn.AnyAny"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "fn",
                                "type": "Fn",
                                "optional": false,
                                "rest": false,
                                "description": "The function to test"
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { input: never; output: never; fn: Fn; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "cases",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Cases",
                                "constraint": "readonly any[]",
                                "default": "readonly []"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "cases",
                                "type": "State[\"fn\"] extends undefined ? GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>[] : State[\"fn\"] extends AnyAny ? (FunctionCase<EffectiveInput<State>, EffectiveOutput<State>, State[\"context\"]> | ((ctx: State[\"context\"]) => FunctionCase<EffectiveInput<State>, EffectiveOutput<State>, State[\"context\"]>))[] : GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>[]",
                                "optional": true,
                                "rest": true,
                                "description": "Array of test cases (static or function-based)"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "case",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "args",
                                "type": "State[\"fn\"] extends undefined ? GenericCaseSingleParams<State[\"input\"], State[\"output\"], State[\"context\"]> : State[\"fn\"] extends AnyAny ? CaseSingleParams<EffectiveInput<State>, EffectiveOutput<State>> : never",
                                "optional": true,
                                "rest": true,
                                "description": "Arguments and expected output (spreads naturally)"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          },
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Test case name"
                              },
                              {
                                "name": "runner",
                                "type": "(context: State[\"context\"]) => any",
                                "optional": false,
                                "rest": false,
                                "description": "Runner function that receives context"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "case$",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "caseObj",
                                "type": "GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>",
                                "optional": false,
                                "rest": false,
                                "description": "Test case object with input, output, and optional context"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "casesInput",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "inputs",
                                "type": "UnwrappedInput<State>[]",
                                "optional": true,
                                "rest": true,
                                "description": "Input values for snapshot testing"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "describeInputs",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Name for the describe block"
                              },
                              {
                                "name": "inputs",
                                "type": "readonly UnwrappedInput<State>[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of input values for snapshot testing"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "describe",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Name for the describe block"
                              },
                              {
                                "name": "cases",
                                "type": "readonly (State[\"fn\"] extends undefined ? GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]> : State[\"fn\"] extends AnyAny ? FunctionCase<EffectiveInput<State>, EffectiveOutput<State>, State[\"context\"]> : GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>)[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of test cases"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          },
                          {
                            "typeParameters": [
                              {
                                "name": "ChildContext",
                                "constraint": "object",
                                "default": "{}"
                              },
                              {
                                "name": "ChildI",
                                "default": "State['input']"
                              },
                              {
                                "name": "ChildO",
                                "default": "State['output']"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Name for the nested describe block. Supports ` > ` separator for multi-level nesting."
                              },
                              {
                                "name": "callback",
                                "type": "(builder: TestBuilder<State>) => TestBuilder<{ context: ChildContext; input: ChildI; output: ChildO; fn: State[\"fn\"]; matrix: State[\"matrix\"]; }>",
                                "optional": false,
                                "rest": false,
                                "description": "Function that receives child builder and returns it with cases"
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { context: Omit<State[\"context\"], keyof ChildContext> & ChildContext; input: State[\"input\"] | ChildI; output: State[\"output\"] | ChildO; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "onSetup",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Ctx",
                                "constraint": "object"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "factory",
                                "type": "() => Ctx",
                                "optional": false,
                                "rest": false,
                                "description": "Function that returns context object"
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { context: State[\"context\"] & Ctx; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      }
                    ],
                    "terminalMethods": [
                      {
                        "name": "outputType",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "O"
                              }
                            ],
                            "parameters": [],
                            "returnType": "State[\"fn\"] extends undefined ? TestBuilder<UpdateState<State, { output: O; }>> : never",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      },
                      {
                        "name": "outputDefault",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "R"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "provider",
                                "type": "State[\"output\"] extends undefined ? (context: State[\"context\"]) => R : (context: State[\"context\"]) => State[\"output\"]",
                                "optional": false,
                                "rest": false,
                                "description": "Function that receives context and returns default expected output"
                              }
                            ],
                            "returnType": "State[\"output\"] extends undefined ? TestBuilder<UpdateState<State, { output: R; }>> : TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      },
                      {
                        "name": "onOutput",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "MappedInput"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "mapper",
                                "type": "State[\"fn\"] extends undefined ? never : State[\"fn\"] extends AnyAny ? (output: MappedInput, context: { i: EffectiveInput<State>; n: string; o: MappedInput; } & State[\"context\"]) => EffectiveOutput<State> : never",
                                "optional": false,
                                "rest": false,
                                "description": "Function that transforms the test case output"
                              }
                            ],
                            "returnType": "State[\"fn\"] extends undefined ? never : State[\"fn\"] extends AnyAny ? TestBuilder<UpdateState<State, { output: MappedInput; }>> : never",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      },
                      {
                        "name": "test",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [],
                            "returnType": "void",
                            "throws": []
                          },
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "fn",
                                "type": "State[\"fn\"] extends undefined ? GenericTestFn<State> : State[\"fn\"] extends AnyAny ? FunctionTestFn<State> : GenericTestFn<State>",
                                "optional": false,
                                "rest": false,
                                "description": "Custom test function with access to results and context"
                              }
                            ],
                            "returnType": "void",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      }
                    ],
                    "transformMethods": [
                      {
                        "name": "layer",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "R"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "layer",
                                "type": "Layer<R, never, never>",
                                "optional": false,
                                "rest": false,
                                "description": "The Effect layer to provide"
                              }
                            ],
                            "returnType": "TestBuilderWithLayers<State, R>",
                            "throws": []
                          }
                        ],
                        "category": "transform",
                        "transformsTo": "TestBuilderWithLayers"
                      },
                      {
                        "name": "layerEach",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "R"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "factory",
                                "type": "State[\"fn\"] extends undefined ? (testCase: { i: State[\"input\"]; o: State[\"output\"]; } & State[\"context\"]) => Layer<R, never, never> : State[\"fn\"] extends AnyAny ? (testCase: { i: EffectiveInput<State>; o?: EffectiveOutput<State>; }) => Layer<R, never, never> : (testCase: { i: State[\"input\"]; o: State[\"output\"]; } & State[\"context\"]) => Layer<R, never, never>",
                                "optional": false,
                                "rest": false,
                                "description": "Function that creates a layer based on test case data"
                              }
                            ],
                            "returnType": "TestBuilderWithLayers<State, R>",
                            "throws": []
                          }
                        ],
                        "category": "transform",
                        "transformsTo": "TestBuilderWithLayers"
                      }
                    ],
                    "_tag": "BuilderSignatureModel"
                  },
                  "description": "Creates a test table builder for testing a specific function.  \n\nThis is a shorthand for `describe().on(fn)` when you don't need a describe block. Types are automatically inferred from the function signature, making it ideal for quick function testing with minimal boilerplate.  \n\n## Case Formats  \n\nTest cases can be specified in multiple formats:  \n\n**Tuple Format** (most common): - `[[arg1, arg2], expected]` - Test with expected output - `['name', [arg1, arg2], expected]` - Named test case - `[[arg1, arg2]]` - Snapshot test (no expected value)  \n\n**Object Format** (more verbose but clearer): - `{ input: [arg1, arg2], output: expected }` - `{ input: [arg1, arg2], output: expected, skip: true, comment: 'name' }` - `{ todo: 'Not implemented yet', comment: 'name' }`",
                  "examples": [
                    {
                      "code": "// Basic function testing\nTest.on(add)\n  .cases(\n    [[2, 3], 5],                    // add(2, 3) === 5\n    [[0, 0], 0],                    // add(0, 0) === 0\n    [[-1, 1], 0]                    // add(-1, 1) === 0\n  )\n  .test()\n\n// Using different case formats\nTest.on(multiply)\n  .cases(\n    [[2, 3], 6],                              // Tuple format\n    ['zero case', [5, 0], 0],                 // Named tuple\n    { input: [-2, 3], output: -6 },           // Object format\n    { input: [100, 100], output: 10000, comment: 'large numbers' }\n  )\n  .test()\n\n// Custom assertions\nTest.on(divide)\n  .cases([[10, 2], 5], [[10, 0], Infinity])\n  .test(({ result, output }) => {\n    if (output === Infinity) {\n      expect(result).toBe(Infinity)\n    } else {\n      expect(result).toBeCloseTo(output, 2)\n    }\n  })\n\n// Output transformation - build full expectations from partials\nTest.on(createUser)\n  .onOutput((partial, context) => ({ ...defaultUser, name: context.input[0], ...partial }))\n  .cases(\n    [['Alice'], { role: 'admin' }],           // Only specify differences\n    [['Bob'], { role: 'user', age: 30 }]\n  )\n  .test()",
                      "title": "## Snapshot Mode with Error Handling",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Mix successful and error cases - errors are captured automatically\nTest.on(parseInt)\n  .cases(\n    ['42'],      // Returns: 42\n    ['hello'],   // Returns: NaN\n  )\n  .test()\n\n// Validation functions - errors documented in snapshots\nTest.on(Positive.from)\n  .cases(\n    [1], [10], [100],        // THEN RETURNS the value\n    [0], [-1], [-10],        // THEN THROWS \"Value must be positive\"\n  )\n  .test()",
                      "title": "## Promise Auto-Awaiting",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": " GIVEN ARGUMENTS\nhello\n THEN RETURNS PROMISE RESOLVING TO STRING\nHELLO\n",
                      "title": "## Snapshot Format",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Test Builders",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "test",
                          "table"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "constructors",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 155
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "describe",
                  "signature": {
                    "typeName": "TestBuilder",
                    "entryPoint": {
                      "typeParameters": [],
                      "parameters": [
                        {
                          "name": "description",
                          "type": "string | undefined",
                          "optional": true,
                          "rest": false
                        }
                      ],
                      "returnType": "TestBuilderEmpty",
                      "throws": []
                    },
                    "chainableMethods": [
                      {
                        "name": "only",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "skip",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "reason",
                                "type": "string | undefined",
                                "optional": true,
                                "rest": false,
                                "description": "Optional reason for skipping (shown in test output)"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "skipIf",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "condition",
                                "type": "() => boolean",
                                "optional": false,
                                "rest": false,
                                "description": "Function that returns true to skip tests"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "concurrent",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "tags",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "tags",
                                "type": "string[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of tag strings"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "name",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "template",
                                "type": "string",
                                "optional": false,
                                "rest": false
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "onlyMatching",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "matcher",
                                "type": "string",
                                "optional": false,
                                "rest": false
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "inputType",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "I"
                              }
                            ],
                            "parameters": [],
                            "returnType": "TestBuilder<UpdateState<State, { input: I; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "contextType",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Ctx",
                                "constraint": "{}",
                                "default": "{}"
                              }
                            ],
                            "parameters": [],
                            "returnType": "TestBuilder<UpdateState<State, { context: Ctx; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "matrix",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "$values",
                                "constraint": "Rec.AnyReadonlyKeyTo<Arr.Any>"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "values",
                                "type": "$values",
                                "optional": false,
                                "rest": false
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { matrix: { [K in keyof $values]: $values[K][number]; }; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "snapshotSerializer",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "serializer",
                                "type": "(output: any, context: { i: State[\"input\"]; n: string; o: State[\"output\"]; } & State[\"context\"]) => string",
                                "optional": false,
                                "rest": false,
                                "description": "Function that takes (output, context) and returns formatted string"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "snapshotSchemas",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "schemas",
                                "type": "any[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of Effect schemas to register for automatic encoding.                  Typically union types that cover all possible schema variants."
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "on",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Fn",
                                "constraint": "Fn.AnyAny"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "fn",
                                "type": "Fn",
                                "optional": false,
                                "rest": false,
                                "description": "The function to test"
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { input: never; output: never; fn: Fn; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "cases",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Cases",
                                "constraint": "readonly any[]",
                                "default": "readonly []"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "cases",
                                "type": "State[\"fn\"] extends undefined ? GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>[] : State[\"fn\"] extends AnyAny ? (FunctionCase<EffectiveInput<State>, EffectiveOutput<State>, State[\"context\"]> | ((ctx: State[\"context\"]) => FunctionCase<EffectiveInput<State>, EffectiveOutput<State>, State[\"context\"]>))[] : GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>[]",
                                "optional": true,
                                "rest": true,
                                "description": "Array of test cases (static or function-based)"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "case",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "args",
                                "type": "State[\"fn\"] extends undefined ? GenericCaseSingleParams<State[\"input\"], State[\"output\"], State[\"context\"]> : State[\"fn\"] extends AnyAny ? CaseSingleParams<EffectiveInput<State>, EffectiveOutput<State>> : never",
                                "optional": true,
                                "rest": true,
                                "description": "Arguments and expected output (spreads naturally)"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          },
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Test case name"
                              },
                              {
                                "name": "runner",
                                "type": "(context: State[\"context\"]) => any",
                                "optional": false,
                                "rest": false,
                                "description": "Runner function that receives context"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "case$",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "caseObj",
                                "type": "GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>",
                                "optional": false,
                                "rest": false,
                                "description": "Test case object with input, output, and optional context"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "casesInput",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "inputs",
                                "type": "UnwrappedInput<State>[]",
                                "optional": true,
                                "rest": true,
                                "description": "Input values for snapshot testing"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "describeInputs",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Name for the describe block"
                              },
                              {
                                "name": "inputs",
                                "type": "readonly UnwrappedInput<State>[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of input values for snapshot testing"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "describe",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Name for the describe block"
                              },
                              {
                                "name": "cases",
                                "type": "readonly (State[\"fn\"] extends undefined ? GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]> : State[\"fn\"] extends AnyAny ? FunctionCase<EffectiveInput<State>, EffectiveOutput<State>, State[\"context\"]> : GenericCase<State[\"input\"], State[\"output\"], State[\"context\"]>)[]",
                                "optional": false,
                                "rest": false,
                                "description": "Array of test cases"
                              }
                            ],
                            "returnType": "TestBuilder<State>",
                            "throws": []
                          },
                          {
                            "typeParameters": [
                              {
                                "name": "ChildContext",
                                "constraint": "object",
                                "default": "{}"
                              },
                              {
                                "name": "ChildI",
                                "default": "State['input']"
                              },
                              {
                                "name": "ChildO",
                                "default": "State['output']"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "name",
                                "type": "string",
                                "optional": false,
                                "rest": false,
                                "description": "Name for the nested describe block. Supports ` > ` separator for multi-level nesting."
                              },
                              {
                                "name": "callback",
                                "type": "(builder: TestBuilder<State>) => TestBuilder<{ context: ChildContext; input: ChildI; output: ChildO; fn: State[\"fn\"]; matrix: State[\"matrix\"]; }>",
                                "optional": false,
                                "rest": false,
                                "description": "Function that receives child builder and returns it with cases"
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { context: Omit<State[\"context\"], keyof ChildContext> & ChildContext; input: State[\"input\"] | ChildI; output: State[\"output\"] | ChildO; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      },
                      {
                        "name": "onSetup",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "Ctx",
                                "constraint": "object"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "factory",
                                "type": "() => Ctx",
                                "optional": false,
                                "rest": false,
                                "description": "Function that returns context object"
                              }
                            ],
                            "returnType": "TestBuilder<UpdateState<State, { context: State[\"context\"] & Ctx; }>>",
                            "throws": []
                          }
                        ],
                        "category": "chainable"
                      }
                    ],
                    "terminalMethods": [
                      {
                        "name": "outputType",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "O"
                              }
                            ],
                            "parameters": [],
                            "returnType": "State[\"fn\"] extends undefined ? TestBuilder<UpdateState<State, { output: O; }>> : never",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      },
                      {
                        "name": "outputDefault",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "R"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "provider",
                                "type": "State[\"output\"] extends undefined ? (context: State[\"context\"]) => R : (context: State[\"context\"]) => State[\"output\"]",
                                "optional": false,
                                "rest": false,
                                "description": "Function that receives context and returns default expected output"
                              }
                            ],
                            "returnType": "State[\"output\"] extends undefined ? TestBuilder<UpdateState<State, { output: R; }>> : TestBuilder<State>",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      },
                      {
                        "name": "onOutput",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "MappedInput"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "mapper",
                                "type": "State[\"fn\"] extends undefined ? never : State[\"fn\"] extends AnyAny ? (output: MappedInput, context: { i: EffectiveInput<State>; n: string; o: MappedInput; } & State[\"context\"]) => EffectiveOutput<State> : never",
                                "optional": false,
                                "rest": false,
                                "description": "Function that transforms the test case output"
                              }
                            ],
                            "returnType": "State[\"fn\"] extends undefined ? never : State[\"fn\"] extends AnyAny ? TestBuilder<UpdateState<State, { output: MappedInput; }>> : never",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      },
                      {
                        "name": "test",
                        "overloads": [
                          {
                            "typeParameters": [],
                            "parameters": [],
                            "returnType": "void",
                            "throws": []
                          },
                          {
                            "typeParameters": [],
                            "parameters": [
                              {
                                "name": "fn",
                                "type": "State[\"fn\"] extends undefined ? GenericTestFn<State> : State[\"fn\"] extends AnyAny ? FunctionTestFn<State> : GenericTestFn<State>",
                                "optional": false,
                                "rest": false,
                                "description": "Custom test function with access to results and context"
                              }
                            ],
                            "returnType": "void",
                            "throws": []
                          }
                        ],
                        "category": "terminal"
                      }
                    ],
                    "transformMethods": [
                      {
                        "name": "layer",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "R"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "layer",
                                "type": "Layer<R, never, never>",
                                "optional": false,
                                "rest": false,
                                "description": "The Effect layer to provide"
                              }
                            ],
                            "returnType": "TestBuilderWithLayers<State, R>",
                            "throws": []
                          }
                        ],
                        "category": "transform",
                        "transformsTo": "TestBuilderWithLayers"
                      },
                      {
                        "name": "layerEach",
                        "overloads": [
                          {
                            "typeParameters": [
                              {
                                "name": "R"
                              }
                            ],
                            "parameters": [
                              {
                                "name": "factory",
                                "type": "State[\"fn\"] extends undefined ? (testCase: { i: State[\"input\"]; o: State[\"output\"]; } & State[\"context\"]) => Layer<R, never, never> : State[\"fn\"] extends AnyAny ? (testCase: { i: EffectiveInput<State>; o?: EffectiveOutput<State>; }) => Layer<R, never, never> : (testCase: { i: State[\"input\"]; o: State[\"output\"]; } & State[\"context\"]) => Layer<R, never, never>",
                                "optional": false,
                                "rest": false,
                                "description": "Function that creates a layer based on test case data"
                              }
                            ],
                            "returnType": "TestBuilderWithLayers<State, R>",
                            "throws": []
                          }
                        ],
                        "category": "transform",
                        "transformsTo": "TestBuilderWithLayers"
                      }
                    ],
                    "_tag": "BuilderSignatureModel"
                  },
                  "description": "Creates a test table builder for property-based and example-based testing.  \n\n**CRITICAL**: Each call to `Test.describe()` creates a SEPARATE, INDEPENDENT test block. The builder is NOT reusable - you CANNOT chain multiple `.cases()` or `.describeInputs()` calls to add test cases to the same describe block. Each builder must end with `.test()`.  \n\nTest tables allow you to define multiple test cases with inputs and expected outputs, reducing boilerplate and making tests more maintainable. The builder supports two modes:  \n\n## Modes  \n\n**Function Mode** - Test a specific function with `.on(fn)`: - Types are automatically inferred from the function signature - Test cases specify function arguments and expected return values - Default assertion compares actual vs expected using Effect's equality  \n\n**Generic Mode** - Define custom types with `.i<T>` and `.o<T>`: - Explicitly specify input and output types - Provide custom test logic to validate cases - Useful for testing complex behaviors beyond simple function calls  \n\n## Features  \n\n**Nested Describes** - Use ` > ` separator to create nested describe blocks: - `Test.describe('Parent > Child')` creates `describe('Parent', () => describe('Child', ...))` - Multiple SEPARATE Test.describe() calls with the same prefix share the outer describe block - Supports any depth: `'API > Users > Create'` creates three levels  \n\n**Matrix Testing** - Use `.matrix()` to run cases across parameter combinations: - Generates cartesian product of all matrix value arrays - Each test case runs once for each combination - Matrix values available as `matrix` in test context - Combines with nested describes for organized test suites",
                  "examples": [
                    {
                      "code": "//  WRONG - Trying to chain test cases (DOES NOT WORK)\nTest.describe('decodeSync > basic')\n  .on(decodeSync)\n  .cases([['1.2.3']])\n  .describeInputs('union', [['1.2.3-beta']])  //  This creates a NESTED describe, not sibling!\n  .test()\n\n//  CORRECT - Separate Test.describe() calls for separate test groups\nTest.describe('decodeSync > basic')\n  .on(decodeSync)\n  .cases([['1.2.3']], [['invalid']])\n  .test()\n\nTest.describe('decodeSync > union')  // Shares 'decodeSync' parent describe\n  .on(decodeSync)\n  .cases([['1.2.3-beta']], [['1.2.3+build']])\n  .test()\n\n// Function mode - testing a math function\nTest.describe('addition')\n  .on(add)\n  .cases(\n    [[2, 3], 5],                          // add(2, 3) should return 5\n    ['negative', [-1, -2], -3],           // Named test case\n    [[0, 0], 0]                           // Edge case\n  )\n  .test()  // Uses default assertion (Effect's Equal.equals)\n\n// Generic mode - custom validation logic\nTest.describe('email validation')\n  .inputType<string>()\n  .outputType<boolean>()\n  .cases(\n    ['user@example.com', true],\n    ['invalid.com', false],\n    ['', false]\n  )\n  .test(({ input, output }) => {\n    const result = isValidEmail(input)\n    expect(result).toBe(output)\n  })\n\n// Nested describe blocks with ' > ' separator\nTest.describe('Transform > String')  // Creates nested: Transform -> String\n  .inputType<string>()\n  .outputType<string>()\n  .cases(['hello', 'HELLO'])\n  .test(({ input, output }) => {\n    expect(input.toUpperCase()).toBe(output)\n  })\n\nTest.describe('Transform > Number')  // SEPARATE call - Shares 'Transform' parent describe\n  .inputType<number>()\n  .outputType<number>()\n  .cases([42, 42])\n  .test(({ input, output }) => {\n    expect(input).toBe(output)\n  })\n\n// Matrix testing - runs each case for all parameter combinations\nTest.describe('string transform')\n  .inputType<string>()\n  .outputType<string>()\n  .matrix({\n    uppercase: [true, false],\n    prefix: ['', 'pre_'],\n  })\n  .cases(\n    ['hello', 'hello'],\n    ['world', 'world']\n  )\n  .test(({ input, output, matrix }) => {\n    // Runs 4 times (2 cases  2 uppercase  2 prefix = 8 tests)\n    let result = input\n    if (matrix.prefix) result = matrix.prefix + result\n    if (matrix.uppercase) result = result.toUpperCase()\n\n    let expected = output\n    if (matrix.prefix) expected = matrix.prefix + expected\n    if (matrix.uppercase) expected = expected.toUpperCase()\n\n    expect(result).toBe(expected)\n  })",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Test Builders",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "test",
                          "table"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "constructors",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 296
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          }
        ]
      },
      "_tag": "SimpleEntrypoint"
    },
    {
      "path": "./ts",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "ts"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "TypeScript type utilities and type-level programming helpers.  \n\nProvides comprehensive type-level utilities including type printing, static errors, type guards, simplification utilities, exact type matching, and type testing tools. Features conditional types, type transformations, and type-level assertions for advanced TypeScript patterns.",
        "category": "Development",
        "exports": [
          {
            "name": "Kind",
            "signature": {
              "text": "export * as Kind",
              "_tag": "TypeSignatureModel"
            },
            "description": "Higher-kinded type utilities for type-level programming. Provides type-level functions and utilities for simulating higher-kinded types in TypeScript.",
            "examples": [],
            "category": "Higher-Kinded Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "kind",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Higher-kinded type utilities for TypeScript.  \n\nProvides type-level functions and utilities for simulating higher-kinded types in TypeScript, enabling more advanced type-level programming patterns.",
              "exports": [
                {
                  "name": "Apply",
                  "signature": {
                    "text": "type Apply<$Kind, $Args> =\n  // @ts-expect-error - Intentional type manipulation for kind simulation\n  ($Kind & { parameters: $Args })['return']",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Higher-kinded type utilities for TypeScript.  \n\nProvides type-level functions and utilities for simulating higher-kinded types in TypeScript, enabling more advanced type-level programming patterns.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 32
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Kind",
                  "signature": {
                    "text": "interface Kind<$Params = unknown, $Return = unknown> {\n  readonly parameters: $Params\n  readonly return: $Return\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Define a kind (higher-kinded type) function interface.  \n\nProvides a standard structure for defining type-level functions that can be applied using the Apply utility.  \n\n $Params - The parameter types this kind accepts  $Return - The return type this kind produces",
                  "examples": [
                    {
                      "code": "interface BoxOf extends Kind<[unknown], Box<any>> {\n  return: Box<this['parameters'][0]>\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 52
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "Parameters",
                  "signature": {
                    "text": "type Parameters<$Kind> = $Kind extends Kind<infer P, any> ? P : never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Extract the parameter types from a kind.  \n\n $Kind - The kind to extract parameters from",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 62
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Return",
                  "signature": {
                    "text": "type Return<$Kind> = $Kind extends Kind<any, infer R> ? R : never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Extract the return type from a kind.  \n\n $Kind - The kind to extract return type from",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 69
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Identity",
                  "signature": {
                    "text": "interface Identity extends Kind {\n  // @ts-expect-error\n  return: this['parameters'][0]\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Create a type-level identity function.  \n\nReturns the input type unchanged. Useful as a default or placeholder in kind compositions.",
                  "examples": [
                    {
                      "code": "type Same = Kind.Apply<Kind.Identity, [string]> // string",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 82
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "Const",
                  "signature": {
                    "text": "interface Const<$Const> extends Kind {\n  return: $Const\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Create a type-level constant function.  \n\nAlways returns the same type regardless of input.  \n\n $Const - The constant type to always return",
                  "examples": [
                    {
                      "code": "type AlwaysString = Kind.Apply<Kind.Const<string>, [number]> // string",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 99
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "PrivateKindReturn",
                  "signature": {
                    "type": "typeof PrivateKindReturn",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Private symbol for storing kind return type.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 114
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "PrivateKindParameters",
                  "signature": {
                    "type": "typeof PrivateKindParameters",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Private symbol for storing kind parameters.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 120
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "Private",
                  "signature": {
                    "text": "interface Private {\n  [PrivateKindReturn]: unknown\n  [PrivateKindParameters]: unknown\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Private kind interface using symbols instead of string keys.  \n\nThis provides a more secure way to define higher-kinded types as the symbols cannot be accessed outside the module.",
                  "examples": [
                    {
                      "code": "interface BoxKind extends PrivateKind {\n  // @ts-expect-error\n  [PRIVATE_KIND_RETURN]: Box<this[PRIVATE_KIND_PARAMETERS][0]>\n  [PRIVATE_KIND_PARAMETERS]: unknown\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 138
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "PrivateApply",
                  "signature": {
                    "text": "type PrivateApply<$Kind extends Private, $Args> = ($Kind & { [PrivateKindParameters]: $Args })[PrivateKindReturn]",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Apply arguments to a private kind.  \n\n $Kind - The private kind to apply  $Args - The arguments to apply",
                  "examples": [
                    {
                      "code": "type BoxOfString = PrivateKindApply<BoxKind, [string]> // Box<string>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 154
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "MaybePrivateApplyOr",
                  "signature": {
                    "text": "type MaybePrivateApplyOr<$MaybeKind, $Args, $Or> =\n  $MaybeKind extends Private\n    ? PrivateApply<$MaybeKind, $Args>\n    : $Or",
                    "_tag": "TypeSignatureModel"
                  },
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 157
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsPrivateKind",
                  "signature": {
                    "text": "type IsPrivateKind<T> = T extends Private ? true : false",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Check if a type is a private kind.  \n\n T - The type to check",
                  "examples": [
                    {
                      "code": "type Test1 = IsPrivateKind<BoxKind> // true\ntype Test2 = IsPrivateKind<string> // false",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "kind",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 173
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "name": "SimpleSignature",
            "signature": {
              "text": "export * as SimpleSignature",
              "_tag": "TypeSignatureModel"
            },
            "description": "Utilities for working with the `__simpleSignature` phantom type pattern. Allows complex generic functions to provide simpler signatures for type inference.",
            "examples": [],
            "category": "SimpleSignature",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 14
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "simple-signature",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Utilities for working with the `__simpleSignature` phantom type pattern.  \n\nThis pattern allows functions with complex generic signatures to provide a simpler signature for type inference in contexts like testing or documentation.  \n\n SimpleSignature",
              "exports": [
                {
                  "name": "symbol",
                  "signature": {
                    "type": "typeof symbol",
                    "_tag": "ValueSignatureModel"
                  },
                  "description": "Utilities for working with the `__simpleSignature` phantom type pattern.  \n\nThis pattern allows functions with complex generic signatures to provide a simpler signature for type inference in contexts like testing or documentation.  \n\n SimpleSignature",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "simple-signature",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 25
                  },
                  "_tag": "value",
                  "type": "const"
                },
                {
                  "name": "SimpleSignature",
                  "signature": {
                    "text": "interface SimpleSignature<\n  $Overloads extends readonly [(...args: any[]) => any, ...Array<(...args: any[]) => any>],\n> {\n  [symbol]: $Overloads[number]\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Helper interface for defining simple signatures with overloads.  \n\nUse this to define multiple overload signatures in a type-safe way. The type parameter accepts a tuple of function signatures.  \n\n $Overloads - Tuple of function signature types",
                  "examples": [
                    {
                      "code": "interface MyFunctionType extends SimpleSignature<[\n  (x: string) => number,\n  (x: number) => string,\n  (x: boolean) => boolean\n]> {\n  // Your complex generic signature\n  <T extends string | number | boolean>(x: T): ComplexType<T>\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Single overload (most common case)\ninterface PartitionFn extends SimpleSignature<[\n  (obj: object, keys: string[]) => { picked: object; omitted: object }\n]> {\n  <T extends object, K extends keyof T>(\n    obj: T,\n    keys: K[]\n  ): { picked: Pick<T, K>; omitted: Omit<T, K> }\n}",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "simple-signature",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 60
                  },
                  "_tag": "type",
                  "type": "interface"
                },
                {
                  "name": "GetSignature",
                  "signature": {
                    "text": "type GetSignature<$fn> = $fn extends { [symbol]: infer $sig } ? $sig : $fn",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Extract the signature from a function, preferring `__simpleSignature` if available.  \n\nIf the function has a `__simpleSignature` property, returns that type. Otherwise, returns the function's actual type unchanged.  \n\n $fn - The function type to extract from",
                  "examples": [
                    {
                      "code": "// Function without __simpleSignature\ntype Fn1 = (a: string, b: number) => boolean\ntype Result1 = GetSignature<Fn1>  // (a: string, b: number) => boolean\n\n// Function with __simpleSignature\ndeclare const partition: {\n  <T extends object, K extends keyof T>(obj: T, keys: K[]): { picked: Pick<T, K>; omitted: Omit<T, K> }\n  [__simpleSignature]: (obj: object, keys: string[]) => { picked: object; omitted: object }\n}\ntype Result2 = GetSignature<typeof partition>  // (obj: object, keys: string[]) => { picked: object; omitted: object }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "simple-signature",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 88
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "GetParameters",
                  "signature": {
                    "text": "type GetParameters<$fn> = GetSignature<$fn> extends (...args: any) => any ? Parameters<GetSignature<$fn>>\n  : never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Extract parameters from a function, using `__simpleSignature` if available.  \n\n $fn - The function type to extract parameters from",
                  "examples": [
                    {
                      "code": "type Params1 = GetParameters<(a: string, b: number) => void>  // [a: string, b: number]\n\n// With __simpleSignature\ndeclare const partition: {\n  <T extends object, K extends keyof T>(obj: T, keys: K[]): any\n  [__simpleSignature]: (obj: object, keys: string[]) => any\n}\ntype Params2 = GetParameters<typeof partition>  // [obj: object, keys: string[]]",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "simple-signature",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 107
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "GetReturnType",
                  "signature": {
                    "text": "type GetReturnType<$fn> = GetSignature<$fn> extends (...args: any) => any ? ReturnType<GetSignature<$fn>>\n  : never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Extract return type from a function, using `__simpleSignature` if available.  \n\n $fn - The function type to extract return type from",
                  "examples": [
                    {
                      "code": "type Return1 = GetReturnType<(a: string) => number>  // number\n\n// With __simpleSignature\ndeclare const partition: {\n  <T extends object, K extends keyof T>(obj: T, keys: K[]): { picked: Pick<T, K>; omitted: Omit<T, K> }\n  [__simpleSignature]: (obj: object, keys: string[]) => { picked: object; omitted: object }\n}\ntype Return2 = GetReturnType<typeof partition>  // { picked: object; omitted: object }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "simple-signature",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 127
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "implement",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [
                          {
                            "name": "$Fn"
                          }
                        ],
                        "parameters": [
                          {
                            "name": "impl",
                            "type": "GetSignature<$Fn>",
                            "optional": false,
                            "rest": false,
                            "description": "Implementation function typed with the simple signature"
                          }
                        ],
                        "returnType": "$Fn",
                        "returnDoc": "The implementation cast to the full function type",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Helper to implement a function with a simple signature for inference.  \n\nThis allows you to write the implementation using the simple signature types while the returned function has the full complex signature.  \n\n $Fn - The full function interface (with complex generics)",
                  "examples": [
                    {
                      "code": "interface PartitionFn extends SimpleSignature<[\n  (obj: object, keys: string[]) => { picked: object; omitted: object }\n]> {\n  <T extends object, K extends keyof T>(\n    obj: T,\n    keys: K[]\n  ): { picked: Pick<T, K>; omitted: Omit<T, K> }\n}\n\nexport const partition = implement<PartitionFn>((obj, pickedKeys) => {\n  // Implementation typed with simple signature: object and string[]\n  return { picked: {}, omitted: { ...obj } }\n})",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "simple-signature",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 157
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "Test",
            "signature": {
              "text": "export * as Test",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level assertion utilities for testing type correctness. Provides compile-time type checking and assertions for tests.",
            "examples": [],
            "category": "Type Testing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 24
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts",
                    "test"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Type-level assertion utilities for testing type correctness.  \n\n## Choosing the Right Assertion  \n\n**Structural Equality (`exact`)**: Use when types must be structurally identical \n\n```ts\nexact<string, string>           //  Pass\nexact<1 | 2, 2 | 1>             //  Pass (union order doesn't affect structure)\nexact<string & {}, string>      //  Fail (different structure)\n\n```\n\n **Mutual Assignability (`equiv`)**: Use for semantically equal types \n\n```ts\nequiv<1 | 2, 2 | 1>             //  Pass (same computed type)\nequiv<string & {}, string>      //  Pass (both compute to string)\nequiv<string, number>           //  Fail (not mutually assignable)\n\n```\n\n **Subtype Checking (`sub`)**: Use when actual must extend expected \n\n```ts\nsub<string, 'hello'>            //  Pass ('hello' extends string)\nsub<object, { a: 1 }>           //  Pass (more specific extends less specific)\nsub<'hello', string>            //  Fail (string doesn't extend 'hello')\n\n```\n\n **Excess Property Detection**: Add `NoExcess` suffix to catch typos \n\n```ts\nsub<Config>()({ id: true, extra: 1 })         //  Pass (sub allows excess)\nsubNoExcess<Config>()({ id: true, extra: 1 }) //  Fail (catches typo!)\n\n```\n\n **Negative Assertions (`Not`)**: Assert types are NOT related \n\n```ts\nNot.exact<string, number>       //  Pass (they're different)\nNot.sub<number, string>         //  Pass (string doesn't extend number)\nNot.promise<number>             //  Pass (number is not a Promise)\n\n```\n\n ## Configuration  \n\nAssertion behavior can be configured via global settings. See KitLibrarySettings.Ts.Test.Settings for available options.",
              "exports": [
                {
                  "name": "exact",
                  "signature": {
                    "text": "type exact<$Expected, $Actual> = Apply<ExactKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that two types are exactly equal (structurally).  \n\nUses a conditional type inference trick to check exact structural equality, correctly handling any, never, and unknown edge cases.  \n\nThis checks for structural equality - types must have the same structure, not just compute to the same result. For mutual assignability, use equiv.  \n\nWhen types are equivalent but not exact (mutually assignable), provides a helpful error suggesting to use equiv(). For other mismatches, TypeScript's native error messages show the specific structural differences.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.exact<string, string>,           //  Pass\n  Ts.Test.exact<string | number, string>,  //  Fail - TypeScript shows mismatch\n  Ts.Test.exact<{ a: 1 }, { a: 1 }>,       //  Pass\n  Ts.Test.exact<any, unknown>,             //  Fail - TypeScript shows mismatch\n  Ts.Test.exact<1 | 2, 2 | 1>              //  Fail with tip - types are equivalent but not structurally equal\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "exact",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 65
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "exactType",
                  "signature": {
                    "text": "type exact<$Expected, $Actual> = Apply<ExactKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that two types are exactly equal (structurally).  \n\nUses a conditional type inference trick to check exact structural equality, correctly handling any, never, and unknown edge cases.  \n\nThis checks for structural equality - types must have the same structure, not just compute to the same result. For mutual assignability, use equiv.  \n\nWhen types are equivalent but not exact (mutually assignable), provides a helpful error suggesting to use equiv(). For other mismatches, TypeScript's native error messages show the specific structural differences.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.exact<string, string>,           //  Pass\n  Ts.Test.exact<string | number, string>,  //  Fail - TypeScript shows mismatch\n  Ts.Test.exact<{ a: 1 }, { a: 1 }>,       //  Pass\n  Ts.Test.exact<any, unknown>,             //  Fail - TypeScript shows mismatch\n  Ts.Test.exact<1 | 2, 2 | 1>              //  Fail with tip - types are equivalent but not structurally equal\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "exact",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 65
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equiv",
                  "signature": {
                    "text": "type equiv<$Expected, $Actual> = Apply<EquivKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that two types are equivalent (mutually assignable).  \n\nThis checks that types are mutually assignable (A extends B and B extends A), which means they compute to the same result even if their structure differs.  \n\nUse this when you care about semantic equality rather than structural equality. For strict structural equality, use exact.  \n\n**Linting:** When `KitLibrarySettings.Ts.Test.Settings.lintBidForExactPossibility` is `true`, this will show an error if exact would work, encouraging use of the stricter assertion. See module documentation for configuration example.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equiv<string, string>,      //  Pass (or error if linting enabled - should use exact)\n  Ts.Test.equiv<1 | 2, 2 | 1>,        //  Pass (or error if linting enabled - should use exact)\n  Ts.Test.equiv<string & {}, string>, //  Pass - both compute to string (exact would fail)\n  Ts.Test.equiv<string, number>       //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "equiv",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 95
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equivNoExcess",
                  "signature": {
                    "text": "type equivNoExcess<$Expected, $Actual> = Apply<EquivNoExcessKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that two types are equivalent (mutually assignable) AND have no excess properties.  \n\nSimilar to equiv but also rejects excess properties in the actual type. This is useful for catching typos or unintended properties in configuration objects while still allowing types that compute to the same result.",
                  "examples": [
                    {
                      "code": "type Config = { id: boolean; name?: string }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.equivNoExcess<Config, { id: true }>,               //  Pass\n  Ts.Test.equivNoExcess<Config, { id: true; name: 'test' }>, //  Pass - optional included\n  Ts.Test.equivNoExcess<Config, { id: true; extra: 1 }>,     //  Fail - excess property\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "equiv",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 195
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equivType",
                  "signature": {
                    "text": "type equiv<$Expected, $Actual> = Apply<EquivKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that two types are equivalent (mutually assignable).  \n\nThis checks that types are mutually assignable (A extends B and B extends A), which means they compute to the same result even if their structure differs.  \n\nUse this when you care about semantic equality rather than structural equality. For strict structural equality, use exact.  \n\n**Linting:** When `KitLibrarySettings.Ts.Test.Settings.lintBidForExactPossibility` is `true`, this will show an error if exact would work, encouraging use of the stricter assertion. See module documentation for configuration example.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equiv<string, string>,      //  Pass (or error if linting enabled - should use exact)\n  Ts.Test.equiv<1 | 2, 2 | 1>,        //  Pass (or error if linting enabled - should use exact)\n  Ts.Test.equiv<string & {}, string>, //  Pass - both compute to string (exact would fail)\n  Ts.Test.equiv<string, number>       //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "equiv",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 95
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equivNoExcessType",
                  "signature": {
                    "text": "type equivNoExcess<$Expected, $Actual> = Apply<EquivNoExcessKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that two types are equivalent (mutually assignable) AND have no excess properties.  \n\nSimilar to equiv but also rejects excess properties in the actual type. This is useful for catching typos or unintended properties in configuration objects while still allowing types that compute to the same result.",
                  "examples": [
                    {
                      "code": "type Config = { id: boolean; name?: string }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.equivNoExcess<Config, { id: true }>,               //  Pass\n  Ts.Test.equivNoExcess<Config, { id: true; name: 'test' }>, //  Pass - optional included\n  Ts.Test.equivNoExcess<Config, { id: true; extra: 1 }>,     //  Fail - excess property\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "equiv",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 195
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "sub",
                  "signature": {
                    "text": "type sub<$Expected, $Actual> = Apply<SubKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type extends (is a subtype of) another type.  \n\nEquivalent to TypeScript's `extends` keyword: checks if `$Actual extends $Expected`. This is useful for validating type relationships and narrowing.  \n\nFor exact type equality (not just subtyping), use exact instead.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.sub<string, 'hello'>,           //  Pass - 'hello' extends string\n  Ts.Test.sub<'hello', string>,           //  Fail - string doesn't extend 'hello'\n  Ts.Test.sub<{ a: 1 }, { a: 1; b: 2 }>,  //  Pass - more specific extends less specific\n  Ts.Test.sub<object, { a: 1 }>           //  Pass - { a: 1 } extends object\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sub",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 56
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNoExcess",
                  "signature": {
                    "text": "type subNoExcess<$Expected, $Actual> = Apply<SubNoExcessKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type extends the expected type AND has no excess properties.  \n\nSimilar to sub but also rejects excess properties beyond those defined in the expected type. This catches common bugs like typos in configuration objects or accidentally passing extra properties.  \n\nThis is particularly useful for: - Validating configuration objects - Checking function parameters that shouldn't have extra properties - Testing that types don't have unexpected fields",
                  "examples": [
                    {
                      "code": "type Config = { id: boolean; name?: string }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.subNoExcess<Config, { id: true }>,               //  Pass\n  Ts.Test.subNoExcess<Config, { id: true; name: 'test' }>, //  Pass - optional included\n  Ts.Test.subNoExcess<Config, { id: true; $skip: true }>,  //  Fail - excess property\n  Ts.Test.subNoExcess<Config, { id: 'wrong' }>             //  Fail - wrong type\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Compare with .sub (allows excess):\ntype Q = { id: boolean }\n\ntype T1 = Ts.Test.sub<Q, { id: true; extra: 1 }>         //  Pass (sub allows excess)\ntype T2 = Ts.Test.subNoExcess<Q, { id: true; extra: 1 }> //  Fail (subNoExcess rejects)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sub",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 169
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNot",
                  "signature": {
                    "text": "type subNot<$NotExpected, $Actual> = Apply<SubNotKind, [$NotExpected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type does NOT extend another type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.subNot<number, string>,  //  Pass\n  Ts.Test.subNot<string, 'hello'>  //  Fail - 'hello' extends string\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sub",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 264
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subType",
                  "signature": {
                    "text": "type sub<$Expected, $Actual> = Apply<SubKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type extends (is a subtype of) another type.  \n\nEquivalent to TypeScript's `extends` keyword: checks if `$Actual extends $Expected`. This is useful for validating type relationships and narrowing.  \n\nFor exact type equality (not just subtyping), use exact instead.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.sub<string, 'hello'>,           //  Pass - 'hello' extends string\n  Ts.Test.sub<'hello', string>,           //  Fail - string doesn't extend 'hello'\n  Ts.Test.sub<{ a: 1 }, { a: 1; b: 2 }>,  //  Pass - more specific extends less specific\n  Ts.Test.sub<object, { a: 1 }>           //  Pass - { a: 1 } extends object\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sub",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 56
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNoExcessType",
                  "signature": {
                    "text": "type subNoExcess<$Expected, $Actual> = Apply<SubNoExcessKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type extends the expected type AND has no excess properties.  \n\nSimilar to sub but also rejects excess properties beyond those defined in the expected type. This catches common bugs like typos in configuration objects or accidentally passing extra properties.  \n\nThis is particularly useful for: - Validating configuration objects - Checking function parameters that shouldn't have extra properties - Testing that types don't have unexpected fields",
                  "examples": [
                    {
                      "code": "type Config = { id: boolean; name?: string }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.subNoExcess<Config, { id: true }>,               //  Pass\n  Ts.Test.subNoExcess<Config, { id: true; name: 'test' }>, //  Pass - optional included\n  Ts.Test.subNoExcess<Config, { id: true; $skip: true }>,  //  Fail - excess property\n  Ts.Test.subNoExcess<Config, { id: 'wrong' }>             //  Fail - wrong type\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Compare with .sub (allows excess):\ntype Q = { id: boolean }\n\ntype T1 = Ts.Test.sub<Q, { id: true; extra: 1 }>         //  Pass (sub allows excess)\ntype T2 = Ts.Test.subNoExcess<Q, { id: true; extra: 1 }> //  Fail (subNoExcess rejects)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sub",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 169
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "subNotType",
                  "signature": {
                    "text": "type subNot<$NotExpected, $Actual> = Apply<SubNotKind, [$NotExpected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type does NOT extend another type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.subNot<number, string>,  //  Pass\n  Ts.Test.subNot<string, 'hello'>  //  Fail - 'hello' extends string\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sub",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 264
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "sup",
                  "signature": {
                    "text": "type sup<$Supertype, $Actual> = Apply<SupKind, [$Supertype, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is a supertype of (i.e., extended by) another type.  \n\nEquivalent to TypeScript's `extends` keyword: checks if `$Actual extends $Supertype`. This is the reverse parameter order of sub - the expected type is the supertype. Less commonly used than `sub` - most cases should use `sub` with reversed parameters for clarity.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.sup<object, { a: 1 }>,  //  Pass - { a: 1 } extends object (object is supertype)\n  Ts.Test.sup<{ a: 1 }, object>,  //  Fail - object doesn't extend { a: 1 }\n  Ts.Test.sup<string, 'hello'>    //  Pass - 'hello' extends string (string is supertype)\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sup",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 51
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "supType",
                  "signature": {
                    "text": "type sup<$Supertype, $Actual> = Apply<SupKind, [$Supertype, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is a supertype of (i.e., extended by) another type.  \n\nEquivalent to TypeScript's `extends` keyword: checks if `$Actual extends $Supertype`. This is the reverse parameter order of sub - the expected type is the supertype. Less commonly used than `sub` - most cases should use `sub` with reversed parameters for clarity.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.sup<object, { a: 1 }>,  //  Pass - { a: 1 } extends object (object is supertype)\n  Ts.Test.sup<{ a: 1 }, object>,  //  Fail - object doesn't extend { a: 1 }\n  Ts.Test.sup<string, 'hello'>    //  Pass - 'hello' extends string (string is supertype)\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "sup",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 51
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalAny",
                  "signature": {
                    "text": "type equalAny<$Actual> = Apply<EqualAnyKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is exactly `any`.  \n\nUses the `0 extends 1 & T` trick to detect `any`.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalAny<any>,      //  Pass\n  Ts.Test.equalAny<unknown>,  //  Fail - Type error\n  Ts.Test.equalAny<string>    //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 82
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalEmptyObject",
                  "signature": {
                    "text": "type equalEmptyObject<$Actual extends object> = Apply<EqualEmptyObjectKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is an empty object (no properties).  \n\nUses Obj.IsEmpty from kit to check if the object has no keys. Note: `{}` in TypeScript means \"any non-nullish value\", not an empty object.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalEmptyObject<Record<string, never>>,  //  Pass\n  Ts.Test.equalEmptyObject<{}>,                      //  Fail - {} is not empty\n  Ts.Test.equalEmptyObject<{ a: 1 }>                 //  Fail - has properties\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 183
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalNever",
                  "signature": {
                    "text": "type equalNever<$Actual> = Apply<EqualNeverKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is exactly `never`.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalNever<never>,  //  Pass\n  Ts.Test.equalNever<string>  //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 33
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalUnknown",
                  "signature": {
                    "text": "type equalUnknown<$Actual> = Apply<EqualUnknownKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is exactly `unknown`.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalUnknown<unknown>,  //  Pass\n  Ts.Test.equalUnknown<any>,      //  Fail - Type error\n  Ts.Test.equalUnknown<string>    //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 133
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalAnyType",
                  "signature": {
                    "text": "type equalAny<$Actual> = Apply<EqualAnyKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is exactly `any`.  \n\nUses the `0 extends 1 & T` trick to detect `any`.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalAny<any>,      //  Pass\n  Ts.Test.equalAny<unknown>,  //  Fail - Type error\n  Ts.Test.equalAny<string>    //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 82
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalEmptyObjectType",
                  "signature": {
                    "text": "type equalEmptyObject<$Actual extends object> = Apply<EqualEmptyObjectKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is an empty object (no properties).  \n\nUses Obj.IsEmpty from kit to check if the object has no keys. Note: `{}` in TypeScript means \"any non-nullish value\", not an empty object.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalEmptyObject<Record<string, never>>,  //  Pass\n  Ts.Test.equalEmptyObject<{}>,                      //  Fail - {} is not empty\n  Ts.Test.equalEmptyObject<{ a: 1 }>                 //  Fail - has properties\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 183
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalNeverType",
                  "signature": {
                    "text": "type equalNever<$Actual> = Apply<EqualNeverKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is exactly `never`.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalNever<never>,  //  Pass\n  Ts.Test.equalNever<string>  //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 33
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "equalUnknownType",
                  "signature": {
                    "text": "type equalUnknown<$Actual> = Apply<EqualUnknownKind, [$Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is exactly `unknown`.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.equalUnknown<unknown>,  //  Pass\n  Ts.Test.equalUnknown<any>,      //  Fail - Type error\n  Ts.Test.equalUnknown<string>    //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "special-types",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 133
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "tuple",
                  "signature": {
                    "text": "type tuple<$Expected extends readonly any[], $Actual> = Apply<TupleKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is a tuple with specific element types.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.tuple<[string, number], [string, number]>,  //  Pass\n  Ts.Test.tuple<[string, number], [number, string]>,  //  Fail - Type error\n  Ts.Test.tuple<[string], string>                     //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tuple",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "tupleType",
                  "signature": {
                    "text": "type tuple<$Expected extends readonly any[], $Actual> = Apply<TupleKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is a tuple with specific element types.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.tuple<[string, number], [string, number]>,  //  Pass\n  Ts.Test.tuple<[string, number], [number, string]>,  //  Fail - Type error\n  Ts.Test.tuple<[string], string>                     //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "tuple",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 47
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "array",
                  "signature": {
                    "text": "type array<$ElementType, $Actual> = Apply<ArrayKind, [$ElementType, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is an array with specific element type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.array<string, string[]>,  //  Pass\n  Ts.Test.array<number, string[]>,  //  Fail - Type error\n  Ts.Test.array<string, string>     //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "array",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "arrayType",
                  "signature": {
                    "text": "type array<$ElementType, $Actual> = Apply<ArrayKind, [$ElementType, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is an array with specific element type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.array<string, string[]>,  //  Pass\n  Ts.Test.array<number, string[]>,  //  Fail - Type error\n  Ts.Test.array<string, string>     //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "array",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "promise",
                  "signature": {
                    "text": "type promise<$Type, $Actual> = Apply<PromiseKind, [$Type, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is a Promise with specific element type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.promise<number, Promise<number>>,  //  Pass\n  Ts.Test.promise<string, Promise<number>>,  //  Fail - Type error\n  Ts.Test.promise<number, number>            //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "promise",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "promiseType",
                  "signature": {
                    "text": "type promise<$Type, $Actual> = Apply<PromiseKind, [$Type, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a type is a Promise with specific element type.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.promise<number, Promise<number>>,  //  Pass\n  Ts.Test.promise<string, Promise<number>>,  //  Fail - Type error\n  Ts.Test.promise<number, number>            //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "promise",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "parameters",
                  "signature": {
                    "text": "type parameters<$Expected extends readonly any[], $Actual extends readonly any[]> = Apply<\n  ParametersKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a function's parameters match the expected type. Combines `Parameters<typeof fn>` with assertion in one step.",
                  "examples": [
                    {
                      "code": "function add(a: number, b: number): number { return a + b }\ntype _ = Ts.Test.Cases<\n  Ts.Test.parameters<[number, number], Parameters<typeof add>>,  //  Pass\n  Ts.Test.parameters<[string, string], Parameters<typeof add>>   //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "parameters",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "parametersType",
                  "signature": {
                    "text": "type parameters<$Expected extends readonly any[], $Actual extends readonly any[]> = Apply<\n  ParametersKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a function's parameters match the expected type. Combines `Parameters<typeof fn>` with assertion in one step.",
                  "examples": [
                    {
                      "code": "function add(a: number, b: number): number { return a + b }\ntype _ = Ts.Test.Cases<\n  Ts.Test.parameters<[number, number], Parameters<typeof add>>,  //  Pass\n  Ts.Test.parameters<[string, string], Parameters<typeof add>>   //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "parameters",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 46
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "returns",
                  "signature": {
                    "text": "type returns<$Expected, $Actual> = Apply<ReturnsAssertionKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a function's return type matches the expected type. Combines `ReturnType<typeof fn>` with assertion in one step.",
                  "examples": [
                    {
                      "code": "function getUser() { return { name: 'John', age: 30 } }\ntype _ = Ts.Test.Cases<\n  Ts.Test.returns<{ name: string; age: number }, ReturnType<typeof getUser>>,  //  Pass\n  Ts.Test.returns<{ name: string }, ReturnType<typeof getUser>>                //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "returns",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 62
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "returnsType",
                  "signature": {
                    "text": "type returns<$Expected, $Actual> = Apply<ReturnsAssertionKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that a function's return type matches the expected type. Combines `ReturnType<typeof fn>` with assertion in one step.",
                  "examples": [
                    {
                      "code": "function getUser() { return { name: 'John', age: 30 } }\ntype _ = Ts.Test.Cases<\n  Ts.Test.returns<{ name: string; age: number }, ReturnType<typeof getUser>>,  //  Pass\n  Ts.Test.returns<{ name: string }, ReturnType<typeof getUser>>                //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "returns",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 62
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "returnsPromise",
                  "signature": {
                    "text": "type returnsPromise<$Expected, $Actual> = Apply<ReturnsPromiseAssertionKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that an async function's resolved return type matches the expected type. Combines `Awaited<ReturnType<typeof fn>>` with assertion in one step.",
                  "examples": [
                    {
                      "code": "async function getUser() { return { name: 'John', age: 30 } }\ntype _ = Ts.Test.Cases<\n  Ts.Test.returnsPromise<{ name: string; age: number }, Awaited<ReturnType<typeof getUser>>>,  //  Pass\n  Ts.Test.returnsPromise<{ name: string }, Awaited<ReturnType<typeof getUser>>>                //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "returns-promise",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 62
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "returnsPromiseType",
                  "signature": {
                    "text": "type returnsPromise<$Expected, $Actual> = Apply<ReturnsPromiseAssertionKind, [$Expected, $Actual]>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that an async function's resolved return type matches the expected type. Combines `Awaited<ReturnType<typeof fn>>` with assertion in one step.",
                  "examples": [
                    {
                      "code": "async function getUser() { return { name: 'John', age: 30 } }\ntype _ = Ts.Test.Cases<\n  Ts.Test.returnsPromise<{ name: string; age: number }, Awaited<ReturnType<typeof getUser>>>,  //  Pass\n  Ts.Test.returnsPromise<{ name: string }, Awaited<ReturnType<typeof getUser>>>                //  Fail - Type error\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "returns-promise",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 62
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "propertiesEquiv",
                  "signature": {
                    "text": "type propertiesEquiv<$Expected extends object, $Actual extends object> = Apply<\n  PropertiesEquivKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that specified properties in an object are equivalent (mutually assignable) to expected types.  \n\nChecks that for each property in the expected shape, the actual object has that property and its type is mutually assignable (equivalent but not necessarily structurally equal). Only checks properties explicitly listed in the expected shape.",
                  "examples": [
                    {
                      "code": "type User = { name: string; count: number & {} }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.propertiesEquiv<{ name: string }, User>,     //  Pass\n  Ts.Test.propertiesEquiv<{ count: number }, User>,    //  Pass - number & {} equiv to number\n  Ts.Test.propertiesEquiv<{ name: number }, User>      //  Fail - not equivalent\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "properties",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 229
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "propertiesExact",
                  "signature": {
                    "text": "type propertiesExact<$Expected extends object, $Actual extends object> = Apply<\n  PropertiesExactKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that specified properties in an object are exactly equal to expected types.  \n\nChecks that for each property in the expected shape, the actual object has that property and its type is structurally identical. Only checks properties explicitly listed in the expected shape - additional properties in the actual object are ignored.",
                  "examples": [
                    {
                      "code": "type User = { name: string; age: number; role: 'admin' | 'user' }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.propertiesExact<{ name: string }, User>,             //  Pass\n  Ts.Test.propertiesExact<{ role: 'admin' | 'user' }, User>,   //  Pass\n  Ts.Test.propertiesExact<{ role: 'admin' }, User>             //  Fail - not exact\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "properties",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 147
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "propertiesSub",
                  "signature": {
                    "text": "type propertiesSub<$Expected extends object, $Actual extends object> = Apply<\n  PropertiesSubKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that specified properties in an object are subtypes of expected types.  \n\nChecks that for each property in the expected shape, the actual object has that property and its type extends the expected type. Only checks properties explicitly listed in the expected shape - additional properties in the actual object are ignored.",
                  "examples": [
                    {
                      "code": "type User = { name: string; age: number; email?: string }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.propertiesSub<{ name: string }, User>,              //  Pass\n  Ts.Test.propertiesSub<{ name: string; age: number }, User>, //  Pass\n  Ts.Test.propertiesSub<{ name: number }, User>               //  Fail - wrong type\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "properties",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 63
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "propertiesEquivType",
                  "signature": {
                    "text": "type propertiesEquiv<$Expected extends object, $Actual extends object> = Apply<\n  PropertiesEquivKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that specified properties in an object are equivalent (mutually assignable) to expected types.  \n\nChecks that for each property in the expected shape, the actual object has that property and its type is mutually assignable (equivalent but not necessarily structurally equal). Only checks properties explicitly listed in the expected shape.",
                  "examples": [
                    {
                      "code": "type User = { name: string; count: number & {} }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.propertiesEquiv<{ name: string }, User>,     //  Pass\n  Ts.Test.propertiesEquiv<{ count: number }, User>,    //  Pass - number & {} equiv to number\n  Ts.Test.propertiesEquiv<{ name: number }, User>      //  Fail - not equivalent\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "properties",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 229
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "propertiesExactType",
                  "signature": {
                    "text": "type propertiesExact<$Expected extends object, $Actual extends object> = Apply<\n  PropertiesExactKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that specified properties in an object are exactly equal to expected types.  \n\nChecks that for each property in the expected shape, the actual object has that property and its type is structurally identical. Only checks properties explicitly listed in the expected shape - additional properties in the actual object are ignored.",
                  "examples": [
                    {
                      "code": "type User = { name: string; age: number; role: 'admin' | 'user' }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.propertiesExact<{ name: string }, User>,             //  Pass\n  Ts.Test.propertiesExact<{ role: 'admin' | 'user' }, User>,   //  Pass\n  Ts.Test.propertiesExact<{ role: 'admin' }, User>             //  Fail - not exact\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "properties",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 147
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "propertiesSubType",
                  "signature": {
                    "text": "type propertiesSub<$Expected extends object, $Actual extends object> = Apply<\n  PropertiesSubKind,\n  [$Expected, $Actual]\n>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Assert that specified properties in an object are subtypes of expected types.  \n\nChecks that for each property in the expected shape, the actual object has that property and its type extends the expected type. Only checks properties explicitly listed in the expected shape - additional properties in the actual object are ignored.",
                  "examples": [
                    {
                      "code": "type User = { name: string; age: number; email?: string }\n\ntype _ = Ts.Test.Cases<\n  Ts.Test.propertiesSub<{ name: string }, User>,              //  Pass\n  Ts.Test.propertiesSub<{ name: string; age: number }, User>, //  Pass\n  Ts.Test.propertiesSub<{ name: number }, User>               //  Fail - wrong type\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "properties",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 63
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Not",
                  "signature": {
                    "text": "export namespace Not {\n  //\n  //\n  //\n  //\n  //   NotExact Assertion\n  //\n  //\n  //\n  //\n\n  /**\n   * NotExact assertion kind - checks that types are NOT exactly equal.\n   *\n   * Part of the Higher-Kinded Types (HKT) pattern. See {@link helpers.ts} for detailed explanation.\n   *\n   * Parameters: [$A, $B]\n   * Returns: never if types are NOT exactly equal, otherwise StaticErrorAssertion\n   */\n  interface NotExactKind {\n    parameters: [$A: unknown, $B: unknown]\n    // dprint-ignore\n    return:\n      IsExact<this['parameters'][0], this['parameters'][1]> extends true\n        ? StaticErrorAssertion<\n            'Types are exactly equal but should not be',\n            this['parameters'][0],\n            this['parameters'][1]\n          >\n        : never\n  }\n\n  /**\n   * Assert that two types are NOT exactly equal.\n   *\n   * @example\n   * ```ts\n   * type _ = Ts.Test.Cases<\n   *   Ts.Test.Not.exact<string, number>,          //  Pass\n   *   Ts.Test.Not.exact<1 | 2, 2 | 1>,            //  Fail - they are exactly equal\n   *   Ts.Test.Not.exact<string & {}, string>      //  Pass - different structure\n   * >\n   * ```\n   */\n  export type exact<$A, $B> = Apply<NotExactKind, [$A, $B]>\n\n  /**\n   * Assert that two types are NOT exactly equal at runtime.\n   *\n   * Type-level equivalent: {@link exact}\n   *\n   * @example\n   * ```ts\n   * // Value mode\n   * const x: string = 'hello'\n   * const y: number = 42\n   * Ts.Test.Not.exact<typeof x, typeof y>()  //  Pass\n   *\n   * // Type-only mode\n   * Ts.Test.Not.exact<string, number>()  //  Pass\n   * ```\n   */\n  export const exact: AssertionFn<NotExactKind> = runtime\n\n  //\n  //\n  //\n  //\n  //   NotSub Assertion\n  //\n  //\n  //\n  //\n\n  /**\n   * NotSub assertion kind - checks that type does NOT extend another.\n   *\n   * Part of the Higher-Kinded Types (HKT) pattern. See {@link helpers.ts} for detailed explanation.\n   *\n   * Parameters: [$A, $B]\n   * Returns: never if $B does NOT extend $A, otherwise StaticErrorAssertion\n   */\n  interface NotSubKind {\n    parameters: [$A: unknown, $B: unknown]\n    // dprint-ignore\n    return:\n      this['parameters'][1] extends this['parameters'][0]\n        ? StaticErrorAssertion<\n            'Type extends the type it should not extend',\n            this['parameters'][0],\n            this['parameters'][1]\n          >\n        : never\n  }\n\n  /**\n   * Assert that a type does NOT extend another type.\n   *\n   * @example\n   * ```ts\n   * type _ = Ts.Test.Cases<\n   *   Ts.Test.Not.sub<string, number>,     //  Pass - number doesn't extend string\n   *   Ts.Test.Not.sub<string, 'hello'>,    //  Fail - 'hello' extends string\n   *   Ts.Test.Not.sub<object, { a: 1 }>    //  Fail - { a: 1 } extends object\n   * >\n   * ```\n   */\n  export type sub<$A, $B> = Apply<NotSubKind, [$A, $B]>\n\n  /**\n   * Assert that a value's type does NOT extend another type at runtime.\n   *\n   * Type-level equivalent: {@link sub}\n   *\n   * @example\n   * ```ts\n   * // Value mode\n   * const x = 42\n   * Ts.Test.Not.sub<string>()(x)  //  Pass - number doesn't extend string\n   *\n   * // Type-only mode\n   * Ts.Test.Not.sub<string, number>()  //  Pass\n   * ```\n   */\n  export const sub: AssertionFn<NotSubKind> = runtime\n\n  //\n  //\n  //\n  //\n  //   NotEquiv Assertion\n  //\n  //\n  //\n  //\n\n  /**\n   * NotEquiv assertion kind - checks that types are NOT mutually assignable.\n   *\n   * Part of the Higher-Kinded Types (HKT) pattern. See {@link helpers.ts} for detailed explanation.\n   *\n   * Parameters: [$A, $B]\n   * Returns: never if types are NOT equivalent, otherwise StaticErrorAssertion\n   */\n  interface NotEquivKind {\n    parameters: [$A: unknown, $B: unknown]\n    // dprint-ignore\n    return:\n      GetRelation<this['parameters'][0], this['parameters'][1]> extends 'equivalent'\n        ? StaticErrorAssertion<\n            'Types are equivalent (mutually assignable) but should not be',\n            this['parameters'][0],\n            this['parameters'][1]\n          >\n        : never\n  }\n\n  /**\n   * Assert that two types are NOT equivalent (mutually assignable).\n   *\n   * @example\n   * ```ts\n   * type _ = Ts.Test.Cases<\n   *   Ts.Test.Not.equiv<string, number>,      //  Pass\n   *   Ts.Test.Not.equiv<string, 'hello'>,     //  Pass - 'hello' is subtype, not equivalent\n   *   Ts.Test.Not.equiv<string & {}, string>  //  Fail - they are equivalent\n   * >\n   * ```\n   */\n  export type equiv<$A, $B> = Apply<NotEquivKind, [$A, $B]>\n\n  /**\n   * Assert that two types are NOT equivalent at runtime.\n   *\n   * Type-level equivalent: {@link equiv}\n   *\n   * @example\n   * ```ts\n   * // Value mode\n   * const x: string = 'hello'\n   * const y: number = 42\n   * Ts.Test.Not.equiv<typeof x, typeof y>()  //  Pass\n   *\n   * // Type-only mode\n   * Ts.Test.Not.equiv<string, number>()  //  Pass\n   * ```\n   */\n  export const equiv: AssertionFn<NotEquivKind> = runtime\n\n  //\n  //\n  //\n  //\n  //   NotPromise Assertion\n  //\n  //\n  //\n  //\n\n  /**\n   * NotPromise assertion kind - checks that type is NOT a Promise.\n   *\n   * Part of the Higher-Kinded Types (HKT) pattern. See {@link helpers.ts} for detailed explanation.\n   *\n   * Parameters: [$Actual]\n   * Returns: never if $Actual is NOT a Promise, otherwise StaticErrorAssertion\n   */\n  interface NotPromiseKind {\n    parameters: [$Actual: unknown]\n    // dprint-ignore\n    return:\n      this['parameters'][0] extends Promise<any>\n        ? StaticErrorAssertion<\n            'Type is a Promise but should not be',\n            'not a Promise',\n            this['parameters'][0]\n          >\n        : never\n  }\n\n  /**\n   * Assert that a type is NOT a Promise.\n   *\n   * @example\n   * ```ts\n   * type _ = Ts.Test.Cases<\n   *   Ts.Test.Not.promise<number>,          //  Pass\n   *   Ts.Test.Not.promise<Promise<number>>  //  Fail - Type error\n   * >\n   * ```\n   */\n  export type promise<$Actual> = Apply<NotPromiseKind, [$Actual]>\n\n  /**\n   * Assert that a value is NOT a Promise at runtime.\n   *\n   * Type-level equivalent: {@link promise}\n   *\n   * @example\n   * ```ts\n   * // Value mode\n   * Ts.Test.Not.promise()(42)  //  Pass\n   * Ts.Test.Not.promise()(Promise.resolve(42))  //  Fail\n   *\n   * // Type-only mode\n   * Ts.Test.Not.promise<number>()  //  Pass\n   * Ts.Test.Not.promise<Promise<number>>()  //  Fail\n   * ```\n   */\n  export const promise: UnaryAssertionFn<NotPromiseKind> = runtimeUnary\n\n  //\n  //\n  //\n  //\n  //   NotArray Assertion\n  //\n  //\n  //\n  //\n\n  /**\n   * NotArray assertion kind - checks that type is NOT an array.\n   *\n   * Part of the Higher-Kinded Types (HKT) pattern. See {@link helpers.ts} for detailed explanation.\n   *\n   * Parameters: [$Actual]\n   * Returns: never if $Actual is NOT an array, otherwise StaticErrorAssertion\n   */\n  interface NotArrayKind {\n    parameters: [$Actual: unknown]\n    // dprint-ignore\n    return:\n      this['parameters'][0] extends any[]\n        ? StaticErrorAssertion<\n            'Type is an array but should not be',\n            'not an array',\n            this['parameters'][0]\n          >\n        : never\n  }\n\n  /**\n   * Assert that a type is NOT an array.\n   *\n   * @example\n   * ```ts\n   * type _ = Ts.Test.Cases<\n   *   Ts.Test.Not.array<string>,       //  Pass\n   *   Ts.Test.Not.array<string[]>      //  Fail - Type error\n   * >\n   * ```\n   */\n  export type array<$Actual> = Apply<NotArrayKind, [$Actual]>\n\n  /**\n   * Assert that a value is NOT an array at runtime.\n   *\n   * Type-level equivalent: {@link array}\n   *\n   * @example\n   * ```ts\n   * // Value mode\n   * Ts.Test.Not.array()('hello')  //  Pass\n   * Ts.Test.Not.array()([1, 2, 3])  //  Fail\n   *\n   * // Type-only mode\n   * Ts.Test.Not.array<string>()  //  Pass\n   * Ts.Test.Not.array<string[]>()  //  Fail\n   * ```\n   */\n  export const array: UnaryAssertionFn<NotArrayKind> = runtimeUnary\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Namespace for negative assertions - asserting that types are NOT related in specific ways.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Ts.Test.Not.exact<string, number>,   //  Pass - they're different\n  Ts.Test.Not.sub<number, string>,     //  Pass - number doesn't extend string\n  Ts.Test.Not.equiv<string, number>    //  Pass - not mutually assignable\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "not",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 17
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "not",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "Namespace for negative assertions - asserting that types are NOT related in specific ways.",
                    "exports": []
                  }
                },
                {
                  "name": "Case",
                  "signature": {
                    "text": "type Case<$Result extends never> = $Result",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Type-level test assertion that requires the result to be never (no error). Used in type-level test suites to ensure a type evaluates to never (success).",
                  "examples": [
                    {
                      "code": "type MyTests = [\n  Ts.Test.Case<Equal<string, string>>,  // OK - evaluates to never (success)\n  Ts.Test.Case<Equal<string, number>>,  // Error - doesn't extend never (returns error)\n]",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "helpers",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 39
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Cases",
                  "signature": {
                    "text": "type Cases<\n  _T1 extends never = never,\n  _T2 extends never = never,\n  _T3 extends never = never,\n  _T4 extends never = never,\n  _T5 extends never = never,\n  _T6 extends never = never,\n  _T7 extends never = never,\n  _T8 extends never = never,\n  _T9 extends never = never,\n  _T10 extends never = never,\n  _T11 extends never = never,\n  _T12 extends never = never,\n  _T13 extends never = never,\n  _T14 extends never = never,\n  _T15 extends never = never,\n  _T16 extends never = never,\n  _T17 extends never = never,\n  _T18 extends never = never,\n  _T19 extends never = never,\n  _T20 extends never = never,\n  _T21 extends never = never,\n  _T22 extends never = never,\n  _T23 extends never = never,\n  _T24 extends never = never,\n  _T25 extends never = never,\n  _T26 extends never = never,\n  _T27 extends never = never,\n  _T28 extends never = never,\n  _T29 extends never = never,\n  _T30 extends never = never,\n  _T31 extends never = never,\n  _T32 extends never = never,\n  _T33 extends never = never,\n  _T34 extends never = never,\n  _T35 extends never = never,\n  _T36 extends never = never,\n  _T37 extends never = never,\n  _T38 extends never = never,\n  _T39 extends never = never,\n  _T40 extends never = never,\n  _T41 extends never = never,\n  _T42 extends never = never,\n  _T43 extends never = never,\n  _T44 extends never = never,\n  _T45 extends never = never,\n  _T46 extends never = never,\n  _T47 extends never = never,\n  _T48 extends never = never,\n  _T49 extends never = never,\n  _T50 extends never = never,\n  _T51 extends never = never,\n  _T52 extends never = never,\n  _T53 extends never = never,\n  _T54 extends never = never,\n  _T55 extends never = never,\n  _T56 extends never = never,\n  _T57 extends never = never,\n  _T58 extends never = never,\n  _T59 extends never = never,\n  _T60 extends never = never,\n  _T61 extends never = never,\n  _T62 extends never = never,\n  _T63 extends never = never,\n  _T64 extends never = never,\n  _T65 extends never = never,\n  _T66 extends never = never,\n  _T67 extends never = never,\n  _T68 extends never = never,\n  _T69 extends never = never,\n  _T70 extends never = never,\n  _T71 extends never = never,\n  _T72 extends never = never,\n  _T73 extends never = never,\n  _T74 extends never = never,\n  _T75 extends never = never,\n  _T76 extends never = never,\n  _T77 extends never = never,\n  _T78 extends never = never,\n  _T79 extends never = never,\n  _T80 extends never = never,\n  _T81 extends never = never,\n  _T82 extends never = never,\n  _T83 extends never = never,\n  _T84 extends never = never,\n  _T85 extends never = never,\n  _T86 extends never = never,\n  _T87 extends never = never,\n  _T88 extends never = never,\n  _T89 extends never = never,\n  _T90 extends never = never,\n  _T91 extends never = never,\n  _T92 extends never = never,\n  _T93 extends never = never,\n  _T94 extends never = never,\n  _T95 extends never = never,\n  _T96 extends never = never,\n  _T97 extends never = never,\n  _T98 extends never = never,\n  _T99 extends never = never,\n  _T100 extends never = never,\n> = true",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Type-level batch assertion helper that accepts multiple assertions. Each type parameter must extend never (no error), allowing batch type assertions.",
                  "examples": [
                    {
                      "code": "type _ = Ts.Test.Cases<\n  Equal<string, string>,     //  Pass (returns never)\n  Extends<string, 'hello'>,  //  Pass (returns never)\n  Never<never>               //  Pass (returns never)\n>\n\n// Type error if any assertion fails\ntype _ = Ts.Test.Cases<\n  Equal<string, string>,     //  Pass (returns never)\n  Equal<string, number>,     //  Fail - Type error here (returns StaticErrorAssertion)\n  Extends<string, 'hello'>   //  Pass (returns never)\n>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "helpers",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 61
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "StaticErrorAssertion",
                  "signature": {
                    "text": "type StaticErrorAssertion<\n  $Message extends string = string,\n  $Expected = unknown,\n  $Actual = unknown,\n  $Tip extends string | readonly string[] = never,\n  $Meta extends Record<string, any> = {},\n> =\n  // Check if we have tips or metadata - if not, skip Simplify to avoid {} collapse\n  [keyof $Meta] extends [never]\n    ? [$Tip] extends [never]\n      ? {\n          [k in keyof { ERROR: $Message; expected: $Expected; actual: $Actual } as k extends string ? Str.PadEnd<k, GetTestSetting<'errorKeyLength'>, '_'> : k]:\n            { ERROR: $Message; expected: $Expected; actual: $Actual }[k]\n        }\n      : Simplify<{\n          [k in keyof ({ ERROR: $Message; expected: $Expected; actual: $Actual } & ([$Tip] extends [readonly string[]] ? TupleToTips<$Tip> : { tip: $Tip })) as k extends string ? Str.PadEnd<k, GetTestSetting<'errorKeyLength'>, '_'> : k]:\n            ({ ERROR: $Message; expected: $Expected; actual: $Actual } & ([$Tip] extends [readonly string[]] ? TupleToTips<$Tip> : { tip: $Tip }))[k]\n        }>\n    : Simplify<{\n        [k in keyof ({ ERROR: $Message; expected: $Expected; actual: $Actual } & $Meta & ([$Tip] extends [never] ? {} : [$Tip] extends [readonly string[]] ? TupleToTips<$Tip> : { tip: $Tip })) as k extends string ? Str.PadEnd<k, GetTestSetting<'errorKeyLength'>, '_'> : k]:\n          ({ ERROR: $Message; expected: $Expected; actual: $Actual } & $Meta & ([$Tip] extends [never] ? {} : [$Tip] extends [readonly string[]] ? TupleToTips<$Tip> : { tip: $Tip }))[k]\n      }>",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Represents a static assertion error at the type level, optimized for type testing.  \n\nThis is a simpler, more focused error type compared to StaticError. It's specifically designed for type assertions where you need to communicate expected vs. actual types.  \n\nSupports three forms of tips: - Single string: `StaticErrorAssertion<'msg', E, A, 'tip'>` - Tuple of strings: `StaticErrorAssertion<'msg', E, A, ['tip1', 'tip2']>` - Metadata object: `StaticErrorAssertion<'msg', E, A, never, { custom: 'data' }>`  \n\n $Message - A string literal type describing the assertion failure  $Expected - The expected type  $Actual - The actual type that was provided  $Tip - Optional tip string or tuple of tip strings  $Meta - Optional metadata object for additional context",
                  "examples": [
                    {
                      "code": "// Simple error with message only\ntype E1 = StaticErrorAssertion<'Types mismatch', string, number>\n\n// With a single tip\ntype E2 = StaticErrorAssertion<'Types mismatch', string, number, 'Use String() to convert'>\n\n// With multiple tips\ntype E3 = StaticErrorAssertion<'Types mismatch', string, number, ['Tip 1', 'Tip 2']>\n\n// With metadata object\ntype E4 = StaticErrorAssertion<'Types mismatch', string, number, never, { operation: 'concat' }>",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "category": "Error Messages",
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts",
                          "test"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "helpers",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 328
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "name": "Union",
            "signature": {
              "text": "export * as Union",
              "_tag": "TypeSignatureModel"
            },
            "description": "Utilities for working with union types at the type level.",
            "examples": [],
            "category": "Union Types",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 37
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "union",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Valid values for discriminant properties in tagged unions.",
              "exports": [
                {
                  "name": "DiscriminantPropertyValue",
                  "signature": {
                    "text": "type DiscriminantPropertyValue = string | number | symbol",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Valid values for discriminant properties in tagged unions.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 4
                  },
                  "_tag": "type",
                  "type": "union"
                },
                {
                  "name": "__FORCE_DISTRIBUTION__",
                  "signature": {
                    "text": "type __FORCE_DISTRIBUTION__ = any",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Marker type to make forced union distribution explicit and self-documenting.  \n\nTypeScript distributes unions in conditional types when the checked type is a naked type parameter. Using this marker in your conditional type makes the intent explicit to readers.",
                  "examples": [
                    {
                      "code": "// Without marker - unclear if distribution is intentional\ntype Transform<T> = T extends string ? Uppercase<T> : T\n\n// With marker - explicitly documents that distribution is desired\ntype Transform<T> = T extends __FORCE_DISTRIBUTION__ ? T extends string ? Uppercase<T> : T : never\n\n// More typical usage pattern\ntype MapUnion<T> = T extends __FORCE_DISTRIBUTION__\n  ? TransformSingleMember<T>\n  : never",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Real-world example: mapping over union members\ntype AddPrefix<T> = T extends __FORCE_DISTRIBUTION__\n  ? T extends string ? `prefix_${T}` : T\n  : never\n\ntype Result = AddPrefix<'a' | 'b' | 'c'>\n// 'prefix_a' | 'prefix_b' | 'prefix_c'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 37
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Include",
                  "signature": {
                    "text": "type Include<$T, $U> = $T extends $U ? $T : never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Include only types that extend a constraint (opposite of Exclude). Filters a union type to only include members that extend the constraint.",
                  "examples": [
                    {
                      "code": "type T = Union.Include<string | number | boolean, string | number>  // string | number\ntype T2 = Union.Include<'a' | 'b' | 1 | 2, string>  // 'a' | 'b'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 49
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "ToTuple",
                  "signature": {
                    "text": "type ToTuple<\n  $Union,\n  ___L = LastOf<$Union>,\n  ___N = [$Union] extends [never] ? true : false,\n> = true extends ___N ? []\n  : [...ToTuple<Exclude<$Union, ___L>>, ___L]",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Convert a union type to a tuple type.",
                  "examples": [
                    {
                      "code": "type T = Union.ToTuple<'a' | 'b' | 'c'>  // ['a', 'b', 'c']",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 59
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "ToIntersection",
                  "signature": {
                    "text": "type ToIntersection<$U> = ($U extends any ? (k: $U) => void : never) extends ((k: infer __i__) => void) ? __i__\n  : never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Convert a union type to an intersection type.",
                  "examples": [
                    {
                      "code": "type U = { a: string } | { b: number }\ntype I = Union.ToIntersection<U>  // { a: string } & { b: number }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 75
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "LastOf",
                  "signature": {
                    "text": "type LastOf<$T> = ToIntersection<$T extends any ? () => $T : never> extends () => infer __r__ ? __r__\n  : never",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Get the last type in a union.",
                  "examples": [
                    {
                      "code": "type T = Union.LastOf<'a' | 'b' | 'c'>  // 'c'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 86
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Expanded",
                  "signature": {
                    "text": "type Expanded<$Union> = $Union",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Force union distribution in conditional types.",
                  "examples": [
                    {
                      "code": "type T = Union.Expanded<'a' | 'b'>  // 'a' | 'b' (forced distribution)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 97
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IgnoreAnyOrUnknown",
                  "signature": {
                    "text": "type IgnoreAnyOrUnknown<$T> = unknown extends $T ? never : $T",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Union that ignores any and unknown.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 102
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsAnyMemberExtends",
                  "signature": {
                    "text": "type IsAnyMemberExtends<$Union, $Type> =\n  (\n    // [1] Force distribution\n    $Union extends any ?\n      ($Union /* member */ extends $Type ? true : false) :\n      never // [1]\n  ) extends false\n    ? false\n    : true",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Check if any member of a union extends a type.",
                  "examples": [
                    {
                      "code": "type T1 = Union.IsAnyMemberExtends<string | number, string>  // true\ntype T2 = Union.IsAnyMemberExtends<number | boolean, string>  // false",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 114
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "IsHas",
                  "signature": {
                    "text": "type IsHas<$Type, $LookingFor> =\n  _IsHas<$Type, $LookingFor> extends false\n    ? false\n    : true",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Checks if a union type contains a specific type.  \n\nReturns `true` if any member of the union type extends the target type, `false` otherwise. This is useful for conditional type logic based on union membership.  \n\n $Type - The union type to search within  $LookingFor - The type to search for",
                  "examples": [
                    {
                      "code": "type HasString = Union.IsHas<string | number | boolean, string>  // true\ntype HasDate = Union.IsHas<string | number, Date>                // false\ntype HasLiteral = Union.IsHas<'a' | 'b' | 'c', 'b'>             // true\n\n// Useful in conditional types\ntype ProcessValue<T> = Union.IsHas<T, Promise<any>> extends true\n  ? 'async'\n  : 'sync'\n\ntype R1 = ProcessValue<string | Promise<string>>  // 'async'\ntype R2 = ProcessValue<string | number>           // 'sync'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Works with complex types\ntype Events = { type: 'click' } | { type: 'hover' } | { type: 'focus' }\ntype HasClick = Union.IsHas<Events, { type: 'click' }>  // true\n\n// Check for any promise in union\ntype MaybeAsync<T> = Union.IsHas<T, Promise<any>>\ntype R3 = MaybeAsync<string | Promise<number>>  // true\ntype R4 = MaybeAsync<string | number>           // false",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 162
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Merge",
                  "signature": {
                    "text": "type Merge<$U> = {\n  [\n    k in (\n      $U extends any ? keyof $U : never\n    )\n  ]: $U extends any ? (k extends keyof $U ? $U[k] : never) : never\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Merge all members of a union into a single type.",
                  "examples": [
                    {
                      "code": "type U = { a: string } | { b: number }\ntype M = Union.Merge<U>  // { a: string; b: number }",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 182
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Is",
                  "signature": {
                    "text": "type Is<$Type> =\n  [$Type] extends [never]                   ? false :\n  [$Type] extends [ToIntersection<$Type>]   ? false :\n                                              true",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Check if a type is a union type.  \n\nReturns `true` if the type is a union with multiple members, `false` if it's a single type or `never`. This is useful for conditional type logic that needs to handle unions differently from single types.  \n\nThe check works by: 1. First checking if the type is `never` (not a union) 2. Then checking if converting the type to an intersection yields the same type    (single types remain unchanged when converted to intersection, unions do not)",
                  "examples": [
                    {
                      "code": "// Union types return true\ntype T1 = Union.Is<string | number>              // true\ntype T2 = Union.Is<'a' | 'b' | 'c'>             // true\ntype T3 = Union.Is<{ a: 1 } | { b: 2 }>         // true\n\n// Single types return false\ntype T4 = Union.Is<string>                       // false\ntype T5 = Union.Is<number>                       // false\ntype T6 = Union.Is<{ a: string }>               // false\n\n// Special cases\ntype T7 = Union.Is<never>                        // false\ntype T8 = Union.Is<any>                          // false",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    },
                    {
                      "code": "// Conditional logic based on union detection\ntype ProcessType<T> = Union.Is<T> extends true\n  ? 'multiple options'\n  : 'single option'\n\ntype R1 = ProcessType<string | number>  // 'multiple options'\ntype R2 = ProcessType<string>           // 'single option'",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "union",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 231
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "name": "VariancePhantom",
            "signature": {
              "text": "export * as VariancePhantom",
              "_tag": "TypeSignatureModel"
            },
            "description": "Phantom type helpers for controlling type variance (covariance, contravariance, invariance, bivariance).",
            "examples": [],
            "category": "Variance",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 46
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "variance-phantom",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "Phantom type helper that makes a type parameter covariant.",
              "exports": [
                {
                  "name": "Co",
                  "signature": {
                    "text": "type Co<$T> = () => $T",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Phantom type helper that makes a type parameter covariant.",
                  "examples": [
                    {
                      "code": "interface Container<T> {\n  readonly __type?: Covariant<T>\n}\n\nlet narrow: Container<1> = {}\nlet wide: Container<number> = {}\n\nwide = narrow  //  Allowed (1 extends number)\nnarrow = wide  //  Error (number does not extend 1)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance-phantom",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 28
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Contra",
                  "signature": {
                    "text": "type Contra<$T> = (value: $T) => void",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Phantom type helper that makes a type parameter contravariant.",
                  "examples": [
                    {
                      "code": "interface Handler<T> {\n  readonly __type?: Contravariant<T>\n}\n\nlet narrow: Handler<1> = {}\nlet wide: Handler<number> = {}\n\nnarrow = wide  //  Allowed (reversed direction!)\nwide = narrow  //  Error",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance-phantom",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 55
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "In",
                  "signature": {
                    "text": "type In<$T> = (value: $T) => $T",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Phantom type helper that makes a type parameter invariant.",
                  "examples": [
                    {
                      "code": "interface Exact<T> {\n  readonly __type?: Invariant<T>\n}\n\nlet one: Exact<1> = {}\nlet num: Exact<number> = {}\n\nnum = one  //  Error (no direction works)\none = num  //  Error (no direction works)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance-phantom",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 77
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "Bi",
                  "signature": {
                    "text": "type Bi<$T> = { bivariantHack(value: $T): void }['bivariantHack']",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Phantom type helper that makes a type parameter bivariant (unsafe).",
                  "examples": [
                    {
                      "code": "interface Unsafe<T> {\n  readonly __type?: Bivariant<T>\n}\n\nlet one: Unsafe<1> = {}\nlet num: Unsafe<number> = {}\n\nnum = one  //  Allowed (both directions work)\none = num  //  Allowed (unsafe!)",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "ts"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "variance-phantom",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 99
                  },
                  "_tag": "type",
                  "type": "type-alias"
                }
              ]
            }
          },
          {
            "name": "Print",
            "signature": {
              "text": "type Print<$Type, $Fallback extends string | undefined = undefined> =\n  // Language base category types\n    IsAny<$Type> extends true     ? 'any'\n  : IsUnknown<$Type> extends true ? 'unknown'\n  : IsNever<$Type> extends true   ? 'never'\n\n  // Special union type boolean which we display as boolean insead of true | false\n  : [$Type] extends [boolean]      ? ([boolean] extends [$Type] ? 'boolean' : `${$Type}`)\n\n  // General unions types\n  : Union.ToTuple<$Type> extends ArrMut.Any2OrMoreRO ? _PrintUnion<Union.ToTuple<$Type>>\n\n  // Primitive and literal types\n  : $Type extends true             ? 'true'\n  : $Type extends false            ? 'false'\n  : $Type extends void             ? ($Type extends undefined ? 'undefined' : 'void')\n  : $Type extends string           ? (string extends $Type    ? 'string'  : `'${$Type}'`)\n  : $Type extends number           ? (number extends $Type    ? 'number'  : `${$Type}`)\n  : $Type extends bigint           ? (bigint extends $Type    ? 'bigint'  : `${$Type}n`)\n  : $Type extends null             ? 'null'\n  : $Type extends undefined        ? 'undefined'\n\n  // User-provided fallback takes precedence if type is not a primitive\n  : $Fallback extends string       ? $Fallback\n\n  // Common object types and specific generic patterns\n  : $Type extends Promise<infer T> ? `Promise<${Print<T>}>`\n  : $Type extends (infer T)[]      ? `Array<${Print<T>}>`\n  : $Type extends readonly (infer T)[]      ? `ReadonlyArray<${Print<T>}>`\n  : $Type extends Date             ? 'Date'\n  : $Type extends RegExp           ? 'RegExp'\n  //\n  : $Type extends Function         ? 'Function'\n  : $Type extends symbol           ? 'symbol'\n\n  // General object fallback\n  : $Type extends object           ? 'object'\n\n  // Ultimate fallback\n  : '?'",
              "_tag": "TypeSignatureModel"
            },
            "description": "Print a type as a readable string representation.",
            "examples": [],
            "category": "Type Printing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "print",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 13
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "as",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "$value"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": true,
                      "rest": false,
                      "description": "The value to cast (defaults to undefined)"
                    }
                  ],
                  "returnType": "$value",
                  "returnDoc": "The value cast to the specified type",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Cast any value to a specific type for testing purposes. Useful for type-level testing where you need to create a value with a specific type.  \n\n $value - The type to cast to",
            "examples": [
              {
                "code": "// Creating typed test values\nconst user = as<{ id: string; name: string }>({ id: '1', name: 'Alice' })\n\n// Testing type inference\ndeclare let _: any\nconst result = someFunction()\nassertExtends<string>()(_ as typeof result)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 24
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "Interpolatable",
            "signature": {
              "text": "type Interpolatable =\n  | string\n  | number\n  | bigint\n  | boolean\n  | null\n  | undefined\n  | symbol\n  | object\n  | unknown\n  | any\n  | never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Types that TypeScript accepts being interpolated into a Template Literal Type.  \n\nThese are the types that can be used within template literal types without causing a TypeScript error. When a value of one of these types is interpolated into a template literal type, TypeScript will properly convert it to its string representation.",
            "examples": [
              {
                "code": "// All these types can be interpolated:\ntype Valid1 = `Value: ${string}`\ntype Valid2 = `Count: ${number}`\ntype Valid3 = `Flag: ${boolean}`\ntype Valid4 = `ID: ${123n}`\n\n// Example usage in conditional types:\ntype Stringify<T extends Interpolatable> = `${T}`\ntype Result1 = Stringify<42>        // \"42\"\ntype Result2 = Stringify<true>      // \"true\"\ntype Result3 = Stringify<'hello'>   // \"hello\"",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 50
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "StaticError",
            "signature": {
              "text": "interface StaticError<\n  $Message extends string = string,\n  $Context extends object = {},\n  $Hint extends string = '(none)',\n> {\n  ERROR: $Message\n  CONTEXT: $Context\n  HINT: $Hint\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Represents a type error that can be surfaced at the type level.  \n\nThis is useful for providing more informative error messages directly in TypeScript's type checking, often used with conditional types or generic constraints. When TypeScript encounters this type, it will display the error information in a structured way.  \n\n $Message - A string literal type describing the error  $Context - An object type providing additional context about the error,                      often including the types involved  $Hint - A string literal type providing a hint for resolving the error",
            "examples": [
              {
                "code": "// Creating a custom type error\ntype RequireString<T> = T extends string ? T : StaticError<\n  'Type must be a string',\n  { Received: T },\n  'Consider using string or a string literal type'\n>\n\ntype Good = RequireString<'hello'>  // 'hello'\ntype Bad = RequireString<number>    // StaticError<...>",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using in function constraints\nfunction processString<T>(\n  value: T extends string ? T : StaticError<\n    'Argument must be a string',\n    { ProvidedType: T }\n  >\n): void {\n  // Implementation\n}\n\nprocessString('hello')  // OK\nprocessString(42)       // Type error with custom message",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Error Messages",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 106
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "StaticErrorAny",
            "signature": {
              "text": "type StaticErrorAny = StaticError<string, object, string>",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "category": "Error Messages",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 119
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Show",
            "signature": {
              "text": "type Show<$Type> = `\\`${Print<$Type>}\\``",
              "_tag": "TypeSignatureModel"
            },
            "description": "Like Print but adds additional styling to display the rendered type in a sentence.  \n\nUseful for type-level error messages where you want to clearly distinguish type names from surrounding text. Wraps the printed type with backticks () like inline code in Markdown.  \n\n $Type - The type to format and display",
            "examples": [
              {
                "code": "type Message1 = `Expected ${Show<string>} but got ${Show<number>}`\n// Result: \"Expected `string` but got `number`\"\n\ntype Message2 = `The type ${Show<'hello' | 'world'>} is not assignable`\n// Result: \"The type `'hello' | 'world'` is not assignable\"\n\n// Using in error messages\ntype TypeError<Expected, Actual> = StaticError<\n  `Type mismatch: expected ${Show<Expected>} but got ${Show<Actual>}`,\n  { Expected, Actual }\n>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Printing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 146
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ShowInTemplate",
            "signature": {
              "text": "type ShowInTemplate<$Type> = `'${Print<$Type>}'`",
              "_tag": "TypeSignatureModel"
            },
            "description": "Version of Show but uses single quotes instead of backticks.  \n\nThis can be useful in template literal types where backticks would be rendered as \"\" which is not ideal for readability. Use this when the output will be used within another template literal type or when backticks cause display issues.  \n\nNote that when working with TS-level errors, if TS can instantiate all the types involved then the result will be a string, not a string literal type. So when working with TS-level errors, only reach for this variant of Show if you think there is likelihood that types won't be instantiated.  \n\n $Type - The type to format and display",
            "examples": [
              {
                "code": "// When backticks would be escaped in output\ntype ErrorInTemplate = `Error: ${ShowInTemplate<string>} is required`\n// Result: \"Error: 'string' is required\"\n\n// Comparing Show vs ShowInTemplate\ntype WithShow = `Type is ${Show<number>}`\n// May display as: \"Type is \\`number\\`\" (escaped backticks)\n\ntype WithShowInTemplate = `Type is ${ShowInTemplate<number>}`\n// Displays as: \"Type is 'number'\" (cleaner)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Printing",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 177
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Simplify",
            "signature": {
              "text": "type Simplify<$Type> =\n  & {\n    [_ in keyof $Type]: $Type[_]\n  }\n  & unknown",
              "_tag": "TypeSignatureModel"
            },
            "description": "Simplifies complex type intersections and mapped types for better readability.  \n\nForces TypeScript to evaluate and flatten a type, which is especially useful for: - Intersection types that appear as `A & B & C` in tooltips - Complex mapped types that show their internal structure - Making type aliases more readable in IDE tooltips  \n\n $Type - The type to simplify",
            "examples": [
              {
                "code": "// Without Simplify\ntype Complex = { a: string } & { b: number } & { c: boolean }\n// Tooltip shows: { a: string } & { b: number } & { c: boolean }\n\n// With Simplify\ntype Simple = Simplify<Complex>\n// Tooltip shows: { a: string; b: number; c: boolean }",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Simplifying complex mapped types\ntype UserPermissions =\n  & { read: boolean }\n  & { write: boolean }\n  & { admin: boolean }\n\ntype FlatPermissions = Simplify<UserPermissions>\n// Shows as: { read: boolean; write: boolean; admin: boolean }\n\n// Useful with generic constraints\nfunction processUser<T extends Simplify<UserPermissions>>(user: T) {\n  // T will show flattened structure in errors and tooltips\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 219
            },
            "_tag": "type",
            "type": "intersection"
          },
          {
            "name": "SimplifyNullable",
            "signature": {
              "text": "type SimplifyNullable<$T> = null extends $T ? (Simplify<$T> & {}) | null : Simplify<$T> & {}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Simplify a type while preserving `| null` unions.  \n\nThis solves a subtle problem with Simplify: when you have `Type | null`, using `Simplify<Type | null>` can absorb or transform the `null` in unexpected ways due to the intersection with `& unknown` or `& {}`. This utility checks for null first, then explicitly reconstructs the union to ensure `| null` remains intact.  \n\n**When to use:** - Use SimplifyNullable when simplifying types that may contain `| null` or `| undefined` - Use Simplify for non-nullable types or when null handling doesn't matter  \n\n $T - The type to simplify",
            "examples": [
              {
                "code": "// Problem: Plain Simplify can mangle nullable unions\ntype User = { name: string } & { age: number }\ntype MaybeUser = User | null\ntype Bad = Simplify<MaybeUser>  // May not preserve | null correctly\n\n// Solution: SimplifyNullable preserves the null union\ntype Good = SimplifyNullable<MaybeUser>  // { name: string; age: number } | null",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Works with non-nullable types too\ntype Simple = SimplifyNullable<{ a: 1 } & { b: 2 }>  // { a: 1; b: 2 }\n\n// Preserves null in unions\ntype Nullable = SimplifyNullable<({ a: 1 } & { b: 2 }) | null>  // { a: 1; b: 2 } | null",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 259
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "ExtendsExact",
            "signature": {
              "text": "type ExtendsExact<$Input, $Constraint> =\n  $Input extends $Constraint\n    ? $Constraint extends $Input\n      ? $Input\n      : never\n    : never",
              "_tag": "TypeSignatureModel"
            },
            "description": "Utilities for working with union types at the type level.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 299
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "NotExtends",
            "signature": {
              "text": "type NotExtends<$A, $B> = [$A] extends [$B] ? false : true",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level utility that checks if a type does NOT extend another type.  \n\nReturns `true` if type A does not extend type B, `false` otherwise. Useful for conditional type logic where you need to check the absence of a type relationship.  \n\n $A - The type to check  $B - The type to check against",
            "examples": [
              {
                "code": "type T1 = NotExtends<string, number>      // true (string doesn't extend number)\ntype T2 = NotExtends<'hello', string>     // false ('hello' extends string)\ntype T3 = NotExtends<42, number>          // false (42 extends number)\ntype T4 = NotExtends<{ a: 1 }, { b: 2 }>  // true (different properties)",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Using in conditional types for optional handling\ntype VarBuilderToType<$Type, $VarBuilder> =\n  $VarBuilder['required'] extends true                     ? Exclude<$Type, undefined> :\n  NotExtends<$VarBuilder['default'], undefined> extends true ? $Type | undefined :\n                                                              $Type\n\n// If default is undefined, type is just $Type\n// If default is not undefined, type is $Type | undefined",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// Checking for specific type exclusions\ntype SafeDivide<T> = NotExtends<T, 0> extends true\n  ? number\n  : StaticError<'Cannot divide by zero'>\n\ntype Result1 = SafeDivide<5>   // number\ntype Result2 = SafeDivide<0>   // StaticError<'Cannot divide by zero'>",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 348
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Writeable",
            "signature": {
              "text": "type Writeable<$Object> = {\n  -readonly [k in keyof $Object]: $Object[k]\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Make all properties in an object mutable (removes readonly modifiers).",
            "examples": [
              {
                "code": "type Readonly = { readonly x: number; readonly y: string }\ntype Mutable = Writeable<Readonly>  // { x: number; y: string }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 359
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IfExtendsElse",
            "signature": {
              "text": "type IfExtendsElse<$Type, $Extends, $Then, $Else> = $Type extends $Extends ? $Then : $Else",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "deprecated": "- Commented out 2025-01-07  \n\nThis utility was too strict - requires BIDIRECTIONAL extends, which rejects valid narrowed types (e.g.,  id: true  for  id: boolean ).  \n\nUse Obj.NoExcess instead, which: -  Rejects excess properties (what you want) -  Allows valid subtypes/narrowing (what you need)  \n\nIf a use case for true bidirectional exact matching emerges, uncomment. Otherwise, remove after 3-6 months (target: ~2025-07-01).  \n\nOriginal implementation:",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 398
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsNever",
            "signature": {
              "text": "type IsNever<$Type> = [$Type] extends [never] ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 400
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IntersectionIgnoreNeverOrAny",
            "signature": {
              "text": "type IntersectionIgnoreNeverOrAny<$T> = IsAny<$T> extends true ? unknown : $T extends never ? unknown : $T",
              "_tag": "TypeSignatureModel"
            },
            "description": "Intersection that ignores never and any.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 405
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "NeverOrAnyToUnknown",
            "signature": {
              "text": "type NeverOrAnyToUnknown<$T> = IsAny<$T> extends true ? unknown : $T extends never ? unknown : $T",
              "_tag": "TypeSignatureModel"
            },
            "description": "Convert never or any to unknown.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 410
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "Narrowable",
            "signature": {
              "text": "type Narrowable = string | number | bigint | boolean | []",
              "_tag": "TypeSignatureModel"
            },
            "description": "Any narrowable primitive type.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 415
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "AnyAndUnknownToNever",
            "signature": {
              "text": "type AnyAndUnknownToNever<$T> = IsAny<$T> extends true ? never : IsUnknown<$T> extends true ? never : $T",
              "_tag": "TypeSignatureModel"
            },
            "description": "Convert any and unknown to never.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 420
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsAny",
            "signature": {
              "text": "type IsAny<T> = 0 extends 1 & T ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a type is `any`.  \n\nUses the fact that `any` is the only type where `0 extends (1 & T)` is true, since `any` absorbs all type operations including impossible intersections.",
            "examples": [
              {
                "code": "type T1 = IsAny<any>      // true\ntype T2 = IsAny<unknown>  // false\ntype T3 = IsAny<string>   // false\ntype T4 = IsAny<never>    // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 436
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsUnknown",
            "signature": {
              "text": "type IsUnknown<T> = unknown extends T ? (IsAny<T> extends true ? false : true) : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if a type is `unknown`.  \n\nUnknown is the top type - everything extends unknown (except any, which is special). So we check if unknown extends the type (only true for unknown and any), then exclude any using IsAny.",
            "examples": [
              {
                "code": "type T1 = IsUnknown<unknown>  // true\ntype T2 = IsUnknown<any>      // false\ntype T3 = IsUnknown<string>   // false\ntype T4 = IsUnknown<never>    // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "ts",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 453
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsExact",
            "signature": {
              "text": "type IsExact<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if two types are structurally equal (exact match).  \n\nUses a conditional type inference trick to detect exact structural equality. This is more strict than bidirectional extends (mutual assignability) as it checks the actual structure, not just compatibility.  \n\nNote: This is different from IsEquivalent which only checks mutual assignability. Two types can be mutually assignable without being structurally equal (e.g., `string & {}` and `string` are equivalent but not exact).",
            "examples": [
              {
                "code": "type T1 = IsExact<string, string> // true\ntype T2 = IsExact<1 | 2, 2 | 1> // true (union order doesn't matter)\ntype T3 = IsExact<string & {}, string> // false (different structure)\ntype T4 = IsExact<any, unknown> // false\ntype T5 = IsExact<{ a: 1 }, { a: 1 }> // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "relation",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 30
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsEquivalent",
            "signature": {
              "text": "type IsEquivalent<A, B> = [A] extends [B] ? [B] extends [A] ? true : false : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if types are mutually assignable (equivalent).  \n\nReturns true if A extends B AND B extends A. This means the types can be used interchangeably in assignments, though they may not have the same structure.",
            "examples": [
              {
                "code": "type T1 = IsEquivalent<string, string> // true\ntype T2 = IsEquivalent<1 | 2, 2 | 1> // true\ntype T3 = IsEquivalent<string & {}, string> // true (both compute to string)\ntype T4 = IsEquivalent<string, number> // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "relation",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 47
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsSubtype",
            "signature": {
              "text": "type IsSubtype<A, B> = [B] extends [A] ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if B is a subtype of A (B extends A, B is narrower than A).",
            "examples": [
              {
                "code": "type T1 = IsSubtype<string, 'hello'> // true ('hello' extends string)\ntype T2 = IsSubtype<'hello', string> // false (string doesn't extend 'hello')\ntype T3 = IsSubtype<number | string, number> // true (number extends number | string)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "relation",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 59
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsSupertype",
            "signature": {
              "text": "type IsSupertype<A, B> = [A] extends [B] ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if B is a supertype of A (A extends B, B is wider than A).",
            "examples": [
              {
                "code": "type T1 = IsSupertype<'hello', string> // true (string is supertype of 'hello')\ntype T2 = IsSupertype<string, 'hello'> // false ('hello' is not supertype of string)\ntype T3 = IsSupertype<number, number | string> // true",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "relation",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 71
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsOverlapping",
            "signature": {
              "text": "type IsOverlapping<A, B> = [A & B] extends [never] ? false : true",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if types have overlapping values (their intersection is not empty).",
            "examples": [
              {
                "code": "type T1 = IsOverlapping<{ a: 1 }, { b: 2 }> // true (can have both properties)\ntype T2 = IsOverlapping<string, number> // false (no overlap)\ntype T3 = IsOverlapping<{ id: 1; a: 2 }, { id: 1; b: 3 }> // true (share id)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "relation",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 83
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "IsDisjoint",
            "signature": {
              "text": "type IsDisjoint<A, B> = [A & B] extends [never] ? true : false",
              "_tag": "TypeSignatureModel"
            },
            "description": "Check if types are disjoint (no common values).",
            "examples": [
              {
                "code": "type T1 = IsDisjoint<string, number> // true (no common values)\ntype T2 = IsDisjoint<{ a: 1 }, { b: 2 }> // false (can have both properties)\ntype T3 = IsDisjoint<'a', 'b'> // true (different literals)",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "relation",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 95
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "GetRelation",
            "signature": {
              "text": "type GetRelation<A, B> =\n  // First check: Are types equivalent (mutually assignable)?\n  // Using [A] extends [B] with brackets prevents union distribution - we want to check\n  // the whole union type as a single unit, not distribute over union members.\n  // Without brackets, `('a' | 'b') extends 'a'` would distribute and check each member separately.\n  [A] extends [B] ? [B] extends [A] ?\n    'equivalent' // Both extend each other - types are mutually assignable\n  : 'supertype'   // A extends B but not vice versa - B is wider/supertype of A\n\n  // Second check: Is B a subtype of A?\n  : [B] extends [A] ? 'subtype'  // B extends A - B is narrower/subtype of A\n\n  // Neither extends the other - need special handling for edge cases.\n  // TypeScript's type system treats primitive and non-primitive as fundamentally different categories.\n  // A primitive can never be the same reference as an object, making them always disjoint.\n  : A extends Lang.Primitive ?\n      B extends Lang.Primitive ?\n        // Both are primitives - check if their intersection is empty.\n        // Primitives can only overlap if they share literal values.\n        // Examples:\n        // - 'a' & 'b' = never (disjoint literals)\n        // - string & 'hello' = 'hello' (overlapping - 'hello' is in string)\n        // - string & number = never (disjoint base types)\n        [A & B] extends [never] ? 'disjoint' : 'overlapping'\n      : 'disjoint'  // Primitive vs object - always disjoint (no possible overlap between value and reference types)\n\n    : B extends Lang.Primitive ? 'disjoint'  // Object vs primitive - always disjoint\n\n    // Both are non-primitives (objects/interfaces).\n    // Objects can have overlapping properties even if neither extends the other.\n    // Example: {a: 1} and {b: 2} don't extend each other, but {a: 1, b: 2} satisfies both.\n    // We check if their intersection is never to determine if they're completely incompatible.\n    : [A & B] extends [never] ? 'disjoint' : 'overlapping'",
              "_tag": "TypeSignatureModel"
            },
            "description": "Classify how the SECOND type parameter relates to the FIRST type parameter.  \n\nReturns one of: - `'subtype'` - B is a subtype of A (B extends A, B is narrower/more specific than A).   See: https://en.wikipedia.org/wiki/Subtyping  \n\n- `'supertype'` - B is a supertype of A (A extends B, B is wider/more general than A).   This is the inverse of subtyping. See: https://en.wikipedia.org/wiki/Subtyping#Subsumption  \n\n- `'equivalent'` - A and B are mutually assignable (both extend each other).   Also known as type equality in structural type systems.   See: https://en.wikipedia.org/wiki/Type_system#Type_equivalence  \n\n- `'overlapping'` - Types share some possible values but neither is a subtype of the other.   Common in structural typing where types can share properties without a subtype relationship.   See: https://www.typescriptlang.org/docs/handbook/type-compatibility.html  \n\n- `'disjoint'` - Types have no values in common (their intersection is empty/never).   See: https://en.wikipedia.org/wiki/Disjoint_union",
            "examples": [
              {
                "code": "// Read as: \"How does the second type relate to the first?\"\ntype T1 = GetRelation<string, string> // 'equivalent'\ntype T2 = GetRelation<1, 1> // 'equivalent'\ntype T3 = GetRelation<string, number> // 'disjoint'\ntype T4 = GetRelation<{a: 1}, {b: 2}> // 'overlapping' (objects can have both properties)\ntype T5 = GetRelation<{a: 1, id: 1}, {b: 2, id: 1}> // 'overlapping'\ntype T6 = GetRelation<{a: 1}, {a: 1}> // 'equivalent'\ntype T7 = GetRelation<'a' | 'b', 'a'> // 'subtype' ('a' is narrower than 'a' | 'b')\ntype T8 = GetRelation<'a', 'a' | 'b'> // 'supertype' ('a' | 'b' is wider than 'a')",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "relation",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 141
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "isTypeWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "reference"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "reference",
                      "type": "reference",
                      "optional": false,
                      "rest": false,
                      "description": "The reference value to compare against"
                    }
                  ],
                  "returnType": "<valueGiven>(value: ValidateIsSupertype<reference, valueGiven>) => value is reference extends valueGiven ? reference : never",
                  "returnDoc": "A type guard function that narrows to the reference type",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a type guard that checks if a value equals a reference value.",
            "examples": [
              {
                "code": "const isNull = isTypeWith(null)\nconst value: string | null = getString()\nif (isNull(value)) {\n  // value is narrowed to null\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-guards",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 18
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isntTypeWith",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "reference"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "reference",
                      "type": "reference",
                      "optional": false,
                      "rest": false,
                      "description": "The reference value to compare against"
                    }
                  ],
                  "returnType": "<valueGiven>(value: ValidateIsSupertype<reference, valueGiven>) => value is reference extends valueGiven ? Exclude<valueGiven, reference> : never",
                  "returnDoc": "A type guard function that narrows by excluding the reference type",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Create a type guard that checks if a value does not equal a reference value.",
            "examples": [
              {
                "code": "const isntNull = isntTypeWith(null)\nconst value: string | null = getString()\nif (isntNull(value)) {\n  // value is narrowed to string\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "ts"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "type-guards",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 41
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./value",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "value"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "General value utilities for common JavaScript values and patterns.  \n\nProvides utilities for lazy values, type guards for symbols and dates, identity proxies, and lazy value resolution. Includes helpers for working with deferred computations and value type checking.",
        "category": "Error Handling & Values",
        "exports": [
          {
            "name": "Lazy",
            "signature": {
              "text": "type Lazy<$Value> = () => $Value",
              "_tag": "TypeSignatureModel"
            },
            "description": "A lazy value that is computed when called.  $Value - The type of value that will be returned when the lazy function is invoked",
            "examples": [],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 9
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "lazy",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "value",
                      "optional": false,
                      "rest": false,
                      "description": "The value to wrap in a lazy computation"
                    }
                  ],
                  "returnType": "Lazy<value>",
                  "returnDoc": "A function that returns the wrapped value when called",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Creates a lazy value that returns the given value when invoked.  value - The type of the value to be lazily returned",
            "examples": [
              {
                "code": "const lazyNumber = lazy(42)\nconsole.log(lazyNumber()) // 42\n\nconst lazyObject = lazy({ foo: 'bar' })\nconsole.log(lazyObject()) // { foo: 'bar' }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 27
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "LazyMaybe",
            "signature": {
              "text": "type LazyMaybe<$Value = unknown> = $Value | Lazy<$Value>",
              "_tag": "TypeSignatureModel"
            },
            "description": "A value that may be either immediate or lazy.  $Value - The type of the value, whether immediate or lazy",
            "examples": [],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 35
            },
            "_tag": "type",
            "type": "union"
          },
          {
            "name": "resolveLazy",
            "signature": {
              "text": "type resolveLazy<$LazyMaybeValue extends LazyMaybe<any>> =\n  $LazyMaybeValue extends Lazy<infer __value__> ? __value__ : $LazyMaybeValue",
              "_tag": "TypeSignatureModel"
            },
            "description": "Type-level resolution of a LazyMaybe value. Extracts the underlying value type whether it's lazy or immediate.  $LazyMaybeValue - A value that may be lazy or immediate",
            "examples": [],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 45
            },
            "_tag": "type",
            "type": "type-alias"
          },
          {
            "name": "resolveLazyFactory",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [
                    {
                      "name": "value"
                    }
                  ],
                  "parameters": [
                    {
                      "name": "lazyMaybeValue",
                      "type": "LazyMaybe<value>",
                      "optional": false,
                      "rest": false,
                      "description": "A value that may be lazy (function) or immediate"
                    }
                  ],
                  "returnType": "() => value",
                  "returnDoc": "A function that when called, resolves and returns the value",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Creates a factory function that resolves a lazy or immediate value when called. This is useful when you want to defer the resolution of a LazyMaybe value.  value - The type of the value to be resolved",
            "examples": [
              {
                "code": "const getValue = resolveLazyFactory(42)\nconsole.log(getValue()) // 42\n\nconst getLazyValue = resolveLazyFactory(() => 42)\nconsole.log(getLazyValue()) // 42\n\n// Useful for configuration that may be lazy\nconst getConfig = resolveLazyFactory(() => ({ apiUrl: 'https://api.example.com' }))\nconsole.log(getConfig()) // { apiUrl: 'https://api.example.com' }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Lazy Values",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 94
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "identityProxy",
            "signature": {
              "type": "{}",
              "_tag": "ValueSignatureModel"
            },
            "description": "A proxy that returns itself for any property access. Useful for default values or chaining patterns.",
            "examples": [
              {
                "code": "identityProxy.foo.bar.baz  // Returns identityProxy\nidentityProxy.anything()  // Returns identityProxy",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Utilities",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 113
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "isSymbol",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The value to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value is a symbol",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type guard to check if a value is a symbol.",
            "examples": [
              {
                "code": "isSymbol(Symbol('test'))  // true\nisSymbol('test')  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 130
            },
            "_tag": "value",
            "type": "function"
          },
          {
            "name": "isDate",
            "signature": {
              "overloads": [
                {
                  "typeParameters": [],
                  "parameters": [
                    {
                      "name": "value",
                      "type": "unknown",
                      "optional": false,
                      "rest": false,
                      "description": "The value to check"
                    }
                  ],
                  "returnType": "boolean",
                  "returnDoc": "True if the value is a Date",
                  "throws": []
                }
              ],
              "_tag": "FunctionSignatureModel"
            },
            "description": "Type guard to check if a value is a Date instance.",
            "examples": [
              {
                "code": "isDate(new Date())  // true\nisDate('2024-01-01')  // false\nisDate(Date.now())  // false",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "category": "Type Guards",
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "value"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "value",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 155
            },
            "_tag": "value",
            "type": "function"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    },
    {
      "path": "./paka",
      "module": {
        "location": {
          "path": {
            "segments": [
              "src",
              "utils",
              "paka"
            ],
            "_tag": "PathRelative"
          },
          "file": {
            "stem": "$$",
            "extension": ".ts",
            "_tag": "File"
          },
          "_tag": "LocRelFile"
        },
        "description": "# Paka Documentation Extractor\n\nPaka is a TypeScript documentation extraction tool that generates structured API documentation from your TypeScript source code. It analyzes your codebase using `ts-morph`, extracts type information and JSDoc comments, and outputs a comprehensive interface model that can be rendered into documentation websites.\n\n## Features\n\n### JSDoc Tag Support\n\nPaka extracts and processes standard JSDoc tags:\n\n- **`@param`** - Parameter descriptions for functions and methods\n- **`@returns`** - Return value descriptions\n- **`@throws`** - Error conditions and exceptions\n- **`@example`** - Code examples (supports multiple examples per export)\n- **`@deprecated`** - Deprecation notices\n- **`@category`** - Group exports by category in documentation\n- **`@internal`** - Mark exports as internal (filtered from public docs)\n\n### Documentation Patterns\n\n#### Module-level Documentation\n\n**External Markdown Files** (#17 - Just Implemented!)\n\nPaka supports external markdown files for module documentation:\n\n1. **Sibling `.md` file**: `kind.ts`  `kind.md`\n2. **Directory `README.md`**: Applies to any module in that directory\n\nPrecedence: Sibling `.md` > `README.md` > JSDoc module comment\n\n**JSDoc Module Comments**\n\nPlace a JSDoc comment at the top of your module file:\n\n```typescript\n/**\n * Higher-kinded type utilities for TypeScript.\n *\n * Provides type-level functions for simulating higher-kinded types.\n *\n * @module\n */\nexport type Apply<$Kind, $Args> = ...\n```\n\n#### Namespace Documentation Patterns\n\n**TypeScript Namespace Shadow**\n\nAdd JSDoc to ESM namespace re-exports using a TypeScript namespace shadow:\n\n```typescript\n// @ts-expect-error Duplicate identifier\nexport * as Utils from './utils.js'\n/**\n * Utility functions for common operations.\n *\n * @category Utilities\n */\nexport namespace Utils {}\n```\n\nThe shadow's JSDoc overrides the nested module's documentation.\n\n**Wrapper File Markdown** (Pure Wrapper Pattern)\n\nFor files containing ONLY a namespace export and NO other exports:\n\n```typescript\n// parent.ts - contains ONLY this export\nexport * as Utils from './utils.js'\n```\n\nCreate `parent.md` to override the nested module's description. This is useful for namespace wrapper files like `$.ts`.\n\n**Precedence**: TypeScript shadow > Wrapper markdown > Nested module markdown > Nested module JSDoc\n\n### Export Filtering\n\n**`@internal` Tag**\n\nMark exports as internal to exclude them from public documentation:\n\n```typescript\n/**\n * Internal helper function\n * @internal\n */\nexport const _internalHelper = () => {}\n```\n\nAlways filtered when `filterInternal: true` (default in production).\n\n**Underscore Prefix Convention**\n\nOptionally filter exports starting with `_`:\n\n```typescript\nexport const _privateHelper = () => {} // Filtered when filterUnderscoreExports: true\n```\n\nEnable with `filterUnderscoreExports` option (default: `false` for backward compatibility).\n\n### Builder Pattern Detection\n\nMark functions with `@builder` to enable builder pattern documentation:\n\n```typescript\n/**\n * Create a test builder\n * @builder\n */\nexport const on = <Fn>(fn: Fn): TestBuilder<{fn: Fn}> => ...\n\ninterface TestBuilder<State> {\n  cases(...cases: any[]): TestBuilder<State>  // chainable\n  test(): void                                 // terminal\n}\n```\n\nPaka automatically crawls the returned builder type and classifies methods:\n\n- **Chainable**: Returns same builder type\n- **Terminal**: Returns void\n- **Transform**: Returns different builder type\n\n### Drillable Namespace Pattern\n\nSupport multiple import styles for the same module:\n\n**Package.json setup:**\n\n```json\n{\n  \"exports\": {\n    \".\": \"./build/index.js\",\n    \"./arr\": \"./build/arr/$$.js\"\n  }\n}\n```\n\n**Source structure:**\n\n```typescript\n// src/index.ts\nexport * as Arr from './arr/$$.js'\n\n// src/arr/$$.ts\nexport const map = ...\nexport const filter = ...\n```\n\nBoth import styles work:\n\n```typescript\nimport { Arr } from '@pkg' // Namespace import\nimport * as Arr from '@pkg/arr' // Direct barrel import\n```\n\n### Code Examples\n\n**Twoslash Integration**\n\nExamples support TypeScript's Twoslash for inline type display:\n\n````typescript\n/**\n * @example\n * ```ts\n * const result = add(1, 2)  // hover shows: const result: number\n * ```\n */\n````\n\nDisable per-example with `@twoslash-disable`:\n\n````typescript\n/**\n * @example\n * ```ts\n * // @twoslash-disable\n * const pseudocode = \"not real TypeScript\"\n * ```\n */\n````\n\n### Type Signature Extraction\n\nPaka extracts structured type information:\n\n**Functions**: Overloads, type parameters, parameters, return types\n**Classes**: Constructor, properties, methods\n**Types**: Interfaces, type aliases, enums\n**Builders**: Entry point + chainable/terminal/transform methods\n\n## Usage\n\n### Extract from Files (Pure Function)\n\n```typescript\nimport { Dir } from '@wollybeard/kit/dir'\nimport { extractFromFiles } from '@wollybeard/kit/paka'\n\nconst files = Dir.spec('/')\n  .add('package.json', { name: 'my-pkg', exports: { '.': './build/index.js' } })\n  .add('src/index.ts', 'export const foo = () => {}')\n  .toLayout()\n\nconst model = extractFromFiles({\n  files,\n  filterUnderscoreExports: false, // Optional\n})\n```\n\n### Extract from Filesystem\n\n```typescript\nimport { extract } from '@wollybeard/kit/paka'\n\nconst model = extract({\n  projectRoot: '/path/to/project',\n  tsconfigPath: '/path/to/tsconfig.json', // Optional\n  entrypoints: ['.', './arr'], // Optional (defaults to all)\n  filterUnderscoreExports: false, // Optional\n})\n```\n\n### Output\n\nThe extracted model follows the `InterfaceModel` schema:\n\n```typescript\n{\n  name: 'package-name',\n  version: '1.0.0',\n  entrypoints: [\n    {\n      _tag: 'SimpleEntrypoint',\n      path: '.',\n      module: {\n        location: 'src/index.ts',\n        description: '...',\n        exports: [...]\n      }\n    }\n  ],\n  metadata: {\n    extractedAt: Date,\n    extractorVersion: '0.1.0'\n  }\n}\n```\n\n## Future Enhancements\n\n- **Export-level README** (#18): `kind.Apply.md` for individual exports\n- **Structured Markdown** (#19): Heading sections map to exports\n- **Package-level Extractor** (#16): `extractPackage()` with package README support\n- **Frontmatter Parsing**: Extract metadata from markdown frontmatter\n\n## Learn More\n\n- **GitHub Issues**: [jasonkuhrt/kit#17](https://github.com/jasonkuhrt/kit/issues/17)\n- **Schema Documentation**: See `src/utils/paka/schema.ts` for the complete interface model\n",
        "exports": [
          {
            "name": "Adaptors",
            "signature": {
              "text": "export * as Adaptors",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 1
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka",
                    "adaptors"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "VitePress",
                  "signature": {
                    "text": "export * as VitePress",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "adaptors"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "$$",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 1
                  },
                  "_tag": "value",
                  "type": "namespace",
                  "module": {
                    "location": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "adaptors"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "vitepress",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "description": "",
                    "exports": [
                      {
                        "name": "VitePressConfig",
                        "signature": {
                          "text": "type VitePressConfig = {\n  /** Output directory for generated markdown files */\n  outputDir: string\n  /** Base URL for the docs site */\n  baseUrl?: string\n  /** GitHub repository URL for source links (e.g., 'https://github.com/owner/repo') */\n  githubUrl?: string\n  /** Group exports by @category tag (auto-detects if undefined) */\n  groupByCategory?: boolean\n}",
                          "_tag": "TypeSignatureModel"
                        },
                        "description": "Configuration for VitePress generation.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "utils",
                                "paka",
                                "adaptors"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "vitepress",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 15
                        },
                        "_tag": "type",
                        "type": "type-alias"
                      },
                      {
                        "name": "generate",
                        "signature": {
                          "overloads": [
                            {
                              "typeParameters": [],
                              "parameters": [
                                {
                                  "name": "model",
                                  "type": "Package",
                                  "optional": false,
                                  "rest": false,
                                  "description": "The extracted interface model"
                                },
                                {
                                  "name": "config",
                                  "type": "VitePressConfig",
                                  "optional": false,
                                  "rest": false,
                                  "description": "VitePress generation configuration"
                                }
                              ],
                              "returnType": "void",
                              "throws": []
                            }
                          ],
                          "_tag": "FunctionSignatureModel"
                        },
                        "description": "Generate VitePress documentation from interface model.",
                        "examples": [],
                        "tags": {},
                        "sourceLocation": {
                          "file": {
                            "path": {
                              "segments": [
                                "src",
                                "utils",
                                "paka",
                                "adaptors"
                              ],
                              "_tag": "PathRelative"
                            },
                            "file": {
                              "stem": "vitepress",
                              "extension": ".ts",
                              "_tag": "File"
                            },
                            "_tag": "LocRelFile"
                          },
                          "line": 78
                        },
                        "_tag": "value",
                        "type": "function"
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Extractor",
            "signature": {
              "text": "export * as Extractor",
              "_tag": "TypeSignatureModel"
            },
            "description": "",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 2
            },
            "_tag": "value",
            "type": "namespace",
            "module": {
              "location": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka",
                    "extractor"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "$$",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "description": "",
              "exports": [
                {
                  "name": "extractFromFiles",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "params",
                            "type": "{ projectRoot?: string; files: Layout; entrypoints?: string[]; extractorVersion?: string; filterUnderscoreExports?: boolean; }",
                            "optional": false,
                            "rest": false,
                            "description": "Extraction parameters including files layout"
                          }
                        ],
                        "returnType": "Package",
                        "returnDoc": "Complete interface model",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Pure extraction function that processes files without I/O. Takes all files as input and returns the extracted model.",
                  "examples": [
                    {
                      "code": "const layout = Dir.spec('/')\n  .add('package.json', { name: 'x', exports: { './foo': './build/foo/$.js' } })\n  .add('src/foo/$.ts', 'export const bar = () => {}')\n  .toLayout()\n\nconst model = extractFromFiles({ files: layout })",
                      "twoslashEnabled": true,
                      "language": "typescript"
                    }
                  ],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "extract",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 37
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "ExtractConfig",
                  "signature": {
                    "text": "type ExtractConfig = {\n  /** Project root directory */\n  projectRoot: string\n  /** Path to tsconfig.json */\n  tsconfigPath?: string\n  /** Specific entrypoints to extract (if not specified, extracts all from package.json) */\n  entrypoints?: string[]\n  /** Extractor version */\n  extractorVersion?: string\n  /** Filter exports that start with underscore `_` prefix (default: false) */\n  filterUnderscoreExports?: boolean\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Configuration for extraction.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "extract",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 261
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "extract",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "config",
                            "type": "ExtractConfig",
                            "optional": false,
                            "rest": false,
                            "description": "Extraction configuration"
                          }
                        ],
                        "returnType": "Package",
                        "returnDoc": "Complete interface model",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Extract documentation model from TypeScript source files.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "extract",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 280
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "Category",
                  "signature": {
                    "text": "type Category = {\n  level: ExportLevel\n  type: ValueExportType | TypeExportType\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Categorization result for a declaration node.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "categorize",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 7
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "categorize",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "decl",
                            "type": "Node<ts.Node>",
                            "optional": false,
                            "rest": false,
                            "description": "The declaration node to categorize"
                          }
                        ],
                        "returnType": "Category",
                        "returnDoc": "Category with level (value/type) and specific type",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Categorize a TypeScript declaration node into export level and type.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "categorize",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "extractExport",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "name",
                            "type": "string",
                            "optional": false,
                            "rest": false,
                            "description": "The export name"
                          },
                          {
                            "name": "decl",
                            "type": "ExportedDeclarations",
                            "optional": false,
                            "rest": false,
                            "description": "The declaration node"
                          }
                        ],
                        "returnType": "ValueExport | TypeExport",
                        "returnDoc": "Export object with all metadata",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Extract export information from a declaration node.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "export",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 18
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "JSDocInfo",
                  "signature": {
                    "text": "type JSDocInfo = {\n  description: string | undefined\n  examples: Example[]\n  deprecated: string | undefined\n  category: string | undefined\n  tags: Record<string, string>\n  /** Force this export to be treated as a namespace */\n  forceNamespace?: boolean\n  /** Mark this export as a builder pattern entry point */\n  isBuilder?: boolean\n  /** Mark this export as internal (should not appear in public documentation) */\n  internal?: boolean\n  /** Parameter descriptions from @param tags (name -> description) */\n  params: Record<string, string>\n  /** Return value description from @returns tag */\n  returns: string | undefined\n  /** Error descriptions from @throws tags */\n  throws: string[]\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Parsed JSDoc information.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "jsdoc",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 8
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "parseJSDoc",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "decl",
                            "type": "Node<ts.Node>",
                            "optional": false,
                            "rest": false,
                            "description": "The declaration node to extract JSDoc from"
                          }
                        ],
                        "returnType": "JSDocInfo",
                        "returnDoc": "Parsed JSDoc information",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Parse JSDoc from a declaration node.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "jsdoc",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 246
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "ModuleExtractionOptions",
                  "signature": {
                    "text": "type ModuleExtractionOptions = {\n  /** Filter exports marked with @internal */\n  filterInternal?: boolean\n  /** Filter exports starting with underscore _ prefix */\n  filterUnderscoreExports?: boolean\n}",
                    "_tag": "TypeSignatureModel"
                  },
                  "description": "Options for module extraction.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "module",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 143
                  },
                  "_tag": "type",
                  "type": "type-alias"
                },
                {
                  "name": "extractModuleFromFile",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "sourceFile",
                            "type": "SourceFile",
                            "optional": false,
                            "rest": false,
                            "description": "The source file to extract from"
                          },
                          {
                            "name": "location",
                            "type": "RelFile",
                            "optional": false,
                            "rest": false,
                            "description": "Relative file path from project root"
                          },
                          {
                            "name": "options",
                            "type": "ModuleExtractionOptions",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "{}",
                            "description": "Extraction options for filtering"
                          }
                        ],
                        "returnType": "Module",
                        "returnDoc": "Module with all exports",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Extract a module from a source file.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "module",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 175
                  },
                  "_tag": "value",
                  "type": "function"
                },
                {
                  "name": "extractModule",
                  "signature": {
                    "overloads": [
                      {
                        "typeParameters": [],
                        "parameters": [
                          {
                            "name": "moduleDecl",
                            "type": "ModuleDeclaration",
                            "optional": false,
                            "rest": false,
                            "description": "The module/namespace declaration"
                          },
                          {
                            "name": "location",
                            "type": "RelFile",
                            "optional": false,
                            "rest": false,
                            "description": "Relative file path from project root"
                          },
                          {
                            "name": "options",
                            "type": "ModuleExtractionOptions",
                            "optional": true,
                            "rest": false,
                            "defaultValue": "{}",
                            "description": "Extraction options for filtering"
                          }
                        ],
                        "returnType": "Module",
                        "returnDoc": "Module with all namespace exports",
                        "throws": []
                      }
                    ],
                    "_tag": "FunctionSignatureModel"
                  },
                  "description": "Extract a module from a namespace declaration.",
                  "examples": [],
                  "tags": {},
                  "sourceLocation": {
                    "file": {
                      "path": {
                        "segments": [
                          "src",
                          "utils",
                          "paka",
                          "extractor",
                          "nodes"
                        ],
                        "_tag": "PathRelative"
                      },
                      "file": {
                        "stem": "module",
                        "extension": ".ts",
                        "_tag": "File"
                      },
                      "_tag": "LocRelFile"
                    },
                    "line": 327
                  },
                  "_tag": "value",
                  "type": "function"
                }
              ]
            }
          },
          {
            "name": "ExportLevel",
            "signature": {
              "type": "Enums<{ readonly value: \"value\"; readonly type: \"type\"; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Export level distinguishes between runtime values and type-only exports.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 11
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "ValueExportType",
            "signature": {
              "type": "Enums<{ readonly function: \"function\"; readonly const: \"const\"; readonly class: \"class\"; readonly namespace: \"namespace\"; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Value export types - exports that exist at runtime.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 17
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "TypeExportType",
            "signature": {
              "type": "Enums<{ readonly interface: \"interface\"; readonly 'type-alias': \"type-alias\"; readonly enum: \"enum\"; readonly union: \"union\"; readonly intersection: \"intersection\"; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Type export types - exports that only exist in TypeScript's type system.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 30
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "BuilderMethodCategory",
            "signature": {
              "type": "Enums<{ readonly chainable: \"chainable\"; readonly terminal: \"terminal\"; readonly transform: \"transform\"; }>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Builder method classification based on return type.  \n\n- `chainable` - Returns the same builder type (for method chaining) - `terminal` - Returns void (ends the builder chain) - `transform` - Returns a different builder type (transforms to another builder)",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 48
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Example",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Code example extracted from JSDoc",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 64
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "SourceLocation",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Source location for \"View source\" links.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 78
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "TypeParameter",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Type parameter for generic functions/classes. Captures type parameter name, constraint, and default value.",
            "examples": [
              {
                "code": "// <T extends string = 'default'>\n{ name: 'T', constraint: 'string', default: \"'default'\" }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 99
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "Parameter",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Function/method parameter. Captures parameter name, type, modifiers, and JSDoc description.",
            "examples": [
              {
                "code": "// (items: T[], fn?: (item: T) => U, ...rest: unknown[])\n[\n  { name: 'items', type: 'T[]', optional: false, rest: false, description: 'Array of items to process' },\n  { name: 'fn', type: '(item: T) => U', optional: true, rest: false, description: 'Transform function' },\n  { name: 'rest', type: 'unknown[]', optional: false, rest: true }\n]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 122
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "FunctionSignature",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Single function signature (one overload). Captures type parameters, parameters, return type, and JSDoc documentation.  \n\nUsed within FunctionSignatureModel to support multiple overloads.",
            "examples": [
              {
                "code": "{\n  typeParameters: [{ name: 'T', constraint: 'string' }],\n  parameters: [{ name: 'value', type: 'T', description: 'Input value' }],\n  returnType: 'T',\n  returnDoc: 'The processed value',\n  throws: ['Error if value is invalid']\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 154
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "FunctionSignatureModel",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Function signature model supporting multiple overloads.  \n\nStructured representation of function signatures with full parameter, type parameter, and return type information.",
            "examples": [
              {
                "code": "// function parse(input: string): Config\n// function parse(input: Buffer): Config\n{\n  _tag: 'FunctionSignatureModel',\n  overloads: [\n    { typeParameters: [], parameters: [{ name: 'input', type: 'string', ... }], returnType: 'Config' },\n    { typeParameters: [], parameters: [{ name: 'input', type: 'Buffer', ... }], returnType: 'Config' }\n  ]\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 186
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "BuilderMethod",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Builder method on a builder interface.  \n\nCaptures method name, overloads, and classification based on return type. Methods are classified during extraction by analyzing their return types.",
            "examples": [
              {
                "code": "// inputType<I>(): TestBuilder<State & { input: I }>\n{\n  name: 'inputType',\n  overloads: [...],\n  category: 'chainable',\n  transformsTo: undefined\n}\n\n// test(): void\n{\n  name: 'test',\n  overloads: [...],\n  category: 'terminal',\n  transformsTo: undefined\n}\n\n// layer<R>(layer: any): OtherBuilder<State, R>\n{\n  name: 'layer',\n  overloads: [...],\n  category: 'transform',\n  transformsTo: 'OtherBuilder'\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 227
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "BuilderSignatureModel",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Builder signature model for fluent/builder pattern APIs.  \n\nBuilder patterns are detected when a function is marked with `@builder` JSDoc tag. The extractor automatically crawls the returned builder type interface and classifies methods based on their return types:  \n\n- **Chainable**: Returns the same builder type (enables method chaining) - **Terminal**: Returns void (ends the builder chain) - **Transform**: Returns a different builder type (transforms to another builder)",
            "examples": [
              {
                "code": "{\n  _tag: 'BuilderSignatureModel',\n  typeName: 'TestBuilder',\n  entryPoint: FunctionSignature { ... },\n  chainableMethods: [\n    { name: 'inputType', category: 'chainable', ... },\n    { name: 'cases', category: 'chainable', ... }\n  ],\n  terminalMethods: [\n    { name: 'test', category: 'terminal', overloads: [...2 overloads] }\n  ],\n  transformMethods: [\n    { name: 'layer', category: 'transform', transformsTo: 'OtherBuilder', ... }\n  ]\n}",
                "title": "Extracted as:",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 286
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "TypeSignatureModel",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Type signature model (interfaces, type aliases, etc).  \n\nFor now, these are kept as plain text since parsing TypeScript type definitions into structured form is complex with diminishing returns.  \n\nFuture: Could be expanded to structured form (properties, methods, etc).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 310
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "ValueSignatureModel",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Value signature model (simple const values, primitives).  \n\nUsed for exports that are simple constant values (not functions/classes). Stores the inferred type as text.",
            "examples": [
              {
                "code": "// export const PI = 3.14159\n{ _tag: 'ValueSignatureModel', type: 'number' }",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 330
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "ClassProperty",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Class property. Captures property name, type, modifiers, and JSDoc description.",
            "examples": [
              {
                "code": "// class User {\n//   readonly id: string\n//   name?: string\n//   static count: number\n// }\n[\n  { name: 'id', type: 'string', optional: false, readonly: true, static: false },\n  { name: 'name', type: 'string', optional: true, readonly: false, static: false },\n  { name: 'count', type: 'number', optional: false, readonly: false, static: true }\n]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 356
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "ClassMethod",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Class method. Captures method name, overloads, and modifiers.",
            "examples": [
              {
                "code": "// class User {\n//   getName(): string\n//   static create(name: string): User\n// }\n[\n  { name: 'getName', overloads: [...], static: false },\n  { name: 'create', overloads: [...], static: true }\n]",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 387
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "ClassSignatureModel",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Class signature model with structured class information.  \n\nStructured representation of class with constructor, properties, and methods.",
            "examples": [
              {
                "code": "// export class User {\n//   readonly id: string\n//   name: string\n//   constructor(id: string, name: string) { ... }\n//   getName(): string { return this.name }\n//   static create(name: string): User { return new User(crypto.randomUUID(), name) }\n// }\n{\n  _tag: 'ClassSignatureModel',\n  ctor: { typeParameters: [], parameters: [...], returnType: 'User' },\n  properties: [\n    { name: 'id', type: 'string', readonly: true, ... },\n    { name: 'name', type: 'string', readonly: false, ... }\n  ],\n  methods: [\n    { name: 'getName', overloads: [...], static: false },\n    { name: 'create', overloads: [...], static: true }\n  ]\n}",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 424
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "SignatureModel",
            "signature": {
              "type": "Union<[typeof FunctionSignatureModel, typeof BuilderSignatureModel, typeof ClassSignatureModel, typeof TypeSignatureModel, typeof ValueSignatureModel]>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Signature model - tagged union of all signature types.  \n\nDiscriminated by _tag field: - `FunctionSignatureModel` - Functions with structured overloads - `BuilderSignatureModel` - Builder pattern APIs with chainable/terminal methods - `ClassSignatureModel` - Classes with constructor, properties, methods - `TypeSignatureModel` - Types, interfaces, type aliases (text) - `ValueSignatureModel` - Const values (type as text)",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 446
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "Module",
            "signature": {
              "text": "interface Module {\n  readonly location: typeof FsLoc.RelFile.Type\n  readonly description: string\n  readonly category?: string\n  readonly exports: ReadonlyArray<Export>\n}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Module type definition.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 480
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "ModuleEncoded",
            "signature": {
              "text": "interface ModuleEncoded extends Module {}",
              "_tag": "TypeSignatureModel"
            },
            "description": "Module encoded type (same as Module since no transformations).",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 490
            },
            "_tag": "type",
            "type": "interface"
          },
          {
            "name": "ValueExport",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Value export - represents a runtime export. Namespace exports include a nested module.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 524
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "TypeExport",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Type export - represents a type-only export.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 535
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "Export",
            "signature": {
              "type": "Union<[typeof ValueExport, typeof TypeExport]>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Export is a tagged union of value and type exports.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 544
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "DrillableNamespaceEntrypoint",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Drillable Namespace Pattern entrypoint.  \n\nThis pattern is detected ONLY for the main entrypoint ('.') when ALL conditions are met:  \n\n1. The main entrypoint source file contains a namespace export: `export * as Name from './path'` 2. The namespace name (PascalCase, e.g., `A`) converts to kebab-case (e.g., `a`) 3. A subpath export exists in package.json with that kebab name (e.g., `./a`) 4. The file that the namespace export points to 5. AND the file that the subpath export points to 6. Must resolve to the SAME source file  \n\nWhen detected, this enables two import forms: - `import { Name } from 'package'` - imports the namespace from main entrypoint - `import * as Name from 'package/kebab-name'` - imports the barrel directly",
            "examples": [
              {
                "code": "// package.json\n{\n  \"exports\": {\n    \".\": \"./build/index.js\",\n    \"./a\": \"./build/a.js\"\n  }\n}\n\n// src/index.ts (main entrypoint)\nexport * as A from './a.js'\n\n// src/a.ts (barrel implementation)\nexport const foo = () => {}",
                "title": "Both the namespace export and the subpath export resolve to `src/a.ts`  Drillable!",
                "twoslashEnabled": true,
                "language": "typescript"
              },
              {
                "code": "// package.json\n{\n  \"exports\": {\n    \".\": \"./build/index.js\",\n    \"./a\": \"./build/a.js\"\n  }\n}\n\n// src/index.ts\nexport * as A from './z.js'  //  Points to z.js, not a.js\n\n// Namespace points to src/z.ts, subpath points to src/a.ts  NOT drillable (different files)",
                "title": "Non-drillable case - different files",
                "twoslashEnabled": true,
                "language": "typescript"
              }
            ],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 598
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "SimpleEntrypoint",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Simple entrypoint without special import pattern.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 613
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "Entrypoint",
            "signature": {
              "type": "Union<[typeof DrillableNamespaceEntrypoint, typeof SimpleEntrypoint]>",
              "_tag": "ValueSignatureModel"
            },
            "description": "Entrypoint union - all patterns.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 630
            },
            "_tag": "value",
            "type": "const"
          },
          {
            "name": "PackageMetadata",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Package metadata.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 639
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "Package",
            "signature": {
              "properties": [],
              "methods": [],
              "_tag": "ClassSignatureModel"
            },
            "description": "Package represents the complete extracted documentation model.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 649
            },
            "_tag": "value",
            "type": "class"
          },
          {
            "name": "InterfaceModel",
            "signature": {
              "type": "typeof Package",
              "_tag": "ValueSignatureModel"
            },
            "description": "The complete interface model output.",
            "examples": [],
            "tags": {},
            "sourceLocation": {
              "file": {
                "path": {
                  "segments": [
                    "src",
                    "utils",
                    "paka"
                  ],
                  "_tag": "PathRelative"
                },
                "file": {
                  "stem": "schema",
                  "extension": ".ts",
                  "_tag": "File"
                },
                "_tag": "LocRelFile"
              },
              "line": 663
            },
            "_tag": "value",
            "type": "const"
          }
        ]
      },
      "_tag": "DrillableNamespaceEntrypoint"
    }
  ],
  "metadata": {
    "extractedAt": "2025-10-15T16:41:21.002Z",
    "extractorVersion": "0.1.0"
  }
}