export interface MarkdownToJsDocMetadata {
  moduleName: string
  generatorPath: string
}

/**
 * Convert markdown documentation to JSDoc format for generated files.
 *
 * @remarks
 * Markdown structure is mapped to JSDoc tags:
 * - Content before first heading → Summary
 * - `# Description` → `@description`
 * - `# Remarks` → `@remarks`
 * - `# Example` with `## Subheading` → `@example Subheading`
 * - `# See Also` with links → `@see {@link url | text}`
 */
export const markdownToJsDoc = (markdown: string, metadata: MarkdownToJsDocMetadata): string => {
  const lines = markdown.trim().split('\n')
  const sections: Record<string, string[]> = {}
  let currentSection: string | null = null
  let summary: string[] = []

  // Parse markdown into sections
  for (const line of lines) {
    const h1Match = line.match(/^# (.+)$/)

    if (h1Match) {
      // Level 1 heading starts a new section
      currentSection = h1Match[1]!.toLowerCase()
      sections[currentSection] = []
    } else if (currentSection) {
      // Add line to current section
      sections[currentSection]!.push(line)
    } else {
      // Content before first heading is the summary
      summary.push(line)
    }
  }

  // Build JSDoc comment
  const jsDocLines: string[] = []

  // Add banner
  jsDocLines.push('/**')
  jsDocLines.push(' * ====================================================================================')
  jsDocLines.push(' * GENERATED FILE - DO NOT EDIT MANUALLY')
  jsDocLines.push(' * ====================================================================================')
  jsDocLines.push(' * ')
  jsDocLines.push(' * Generated by: Graffle Code Generator')
  jsDocLines.push(` * Source: ${metadata.generatorPath}`)
  jsDocLines.push(' * ')
  jsDocLines.push(` * @module ${metadata.moduleName}`)

  // Add summary
  if (summary.length > 0) {
    jsDocLines.push(' * ')
    for (const line of summary) {
      if (line.trim()) {
        jsDocLines.push(` * ${line}`)
      } else {
        jsDocLines.push(' * ')
      }
    }
  }

  // Add description section
  if (sections['description']) {
    jsDocLines.push(' * ')
    jsDocLines.push(' * @description')
    for (const line of sections['description']) {
      if (line.trim()) {
        jsDocLines.push(` * ${line}`)
      } else {
        jsDocLines.push(' * ')
      }
    }
  }

  // Add remarks section
  if (sections['remarks']) {
    jsDocLines.push(' * ')
    jsDocLines.push(' * @remarks')
    for (const line of sections['remarks']) {
      if (line.trim()) {
        jsDocLines.push(` * ${line}`)
      } else {
        jsDocLines.push(' * ')
      }
    }
  }

  // Add example section(s)
  if (sections['example']) {
    jsDocLines.push(' * ')
    let currentExampleLabel = ''
    let inExample = false

    for (const line of sections['example']) {
      const h2Match = line.match(/^## (.+)$/)

      if (h2Match) {
        // New example subsection
        if (inExample) {
          // Close previous example
          jsDocLines.push(' * ```')
        }
        currentExampleLabel = h2Match[1]!
        jsDocLines.push(` * @example ${currentExampleLabel}`)
        inExample = false
      } else if (line.trim().startsWith('```')) {
        // Code block delimiter
        if (!inExample) {
          jsDocLines.push(' * ```typescript')
          inExample = true
        } else {
          jsDocLines.push(' * ```')
          inExample = false
        }
      } else if (line.trim()) {
        jsDocLines.push(` * ${line}`)
      } else {
        jsDocLines.push(' * ')
      }
    }

    // Close final example if still open
    if (inExample) {
      jsDocLines.push(' * ```')
    }
  }

  // Add see also section
  if (sections['see also']) {
    jsDocLines.push(' * ')
    for (const line of sections['see also']) {
      // Parse markdown links: [text](url)
      const linkMatch = line.match(/\[(.+?)\]\((.+?)\)/)
      if (linkMatch) {
        const text = linkMatch[1]
        const url = linkMatch[2]
        jsDocLines.push(` * @see {@link ${url} | ${text}}`)
      }
    }
  }

  jsDocLines.push(' */')

  return jsDocLines.join('\n')
}
