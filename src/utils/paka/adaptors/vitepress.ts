import { FsLoc } from '#fs-loc'
import { Str } from '#str'
import { Match } from 'effect'
import { writeFileSync } from 'node:fs'
import { mkdirSync } from 'node:fs'
import { join } from 'node:path'
import type { Entrypoint, Example, Export, InterfaceModel, Module, SignatureModel, ValueExport } from '../schema.js'

// Convenient alias for markdown utilities
const Md = Str.Code.Md

/**
 * Configuration for VitePress generation.
 */
export type VitePressConfig = {
  /** Output directory for generated markdown files */
  outputDir: string
  /** Base URL for the docs site */
  baseUrl?: string
  /** GitHub repository URL for source links (e.g., 'https://github.com/owner/repo') */
  githubUrl?: string
  /** Group exports by @category tag (auto-detects if undefined) */
  groupByCategory?: boolean
  /** Optional category ordering for sidebar (defaults to alphabetical with "Other" last) */
  categoryOrder?: string[]
}

/**
 * Derive PascalCase module name from entrypoint path.
 * Examples: './err' → 'Err', './package-manager' → 'PackageManager'
 */
const deriveModuleName = (path: string): string => {
  // Extract stem (remove leading ./)
  const withoutLeadingDot = path.replace(/^\.\//, '')

  // Convert kebab-case to PascalCase
  return withoutLeadingDot
    .split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

/**
 * Page metadata for a generated page.
 */
type Page = {
  url: string
  filepath: string
  title: string
  entrypoint: Entrypoint
  module: Module
  breadcrumbs: string[]
  pageType?: 'overview' | 'exports' | 'namespace'
}

/**
 * Generation context passed through rendering functions.
 */
type Context = {
  packageName: string
  githubUrl?: string
  breadcrumbs?: string[]
  groupByCategory?: boolean
}

/**
 * Generate VitePress documentation from interface model.
 *
 * @param model - The extracted interface model
 * @param config - VitePress generation configuration
 */
export const generate = (model: InterfaceModel, config: VitePressConfig): void => {
  const { outputDir, githubUrl, groupByCategory, categoryOrder } = config
  const context: Context = {
    packageName: model.name,
    ...(githubUrl ? { githubUrl } : {}),
    ...(groupByCategory !== undefined ? { groupByCategory } : {}),
  }

  // Ensure output directories exist
  mkdirSync(join(outputDir, 'api'), { recursive: true })
  mkdirSync(join(outputDir, '.generated'), { recursive: true })

  // Generate sidebar configuration
  const sidebar = generateSidebar(model, categoryOrder)
  const sidebarContent = `// Auto-generated by Paka - do not edit manually
import type { DefaultTheme } from 'vitepress'

export const apiSidebar: DefaultTheme.SidebarItem[] = ${JSON.stringify(sidebar, null, 2)}
`
  writeFileSync(join(outputDir, '.generated/sidebar.ts'), sidebarContent, 'utf-8')

  // Generate API index page
  const indexContent = generateApiIndex(model)
  writeFileSync(join(outputDir, 'api/index.md'), indexContent, 'utf-8')

  // Generate pages for all modules and namespaces
  const pages = generatePages(model)

  for (const page of pages) {
    const content = generatePageContent(page, context)
    const filepath = join(outputDir, page.filepath)

    // Ensure directory exists
    const dir = filepath.substring(0, filepath.lastIndexOf('/'))
    mkdirSync(dir, { recursive: true })

    writeFileSync(filepath, content, 'utf-8')
  }

  console.log(`Generated ${pages.length} documentation pages and sidebar configuration`)
}

/**
 * Generate VitePress sidebar configuration from interface model.
 *
 * @param model - The extracted interface model
 * @param categoryOrder - Optional category ordering (defaults to alphabetical)
 * @returns Sidebar items grouped by category
 */
export const generateSidebar = (
  model: InterfaceModel,
  categoryOrder?: string[],
): Array<{ text: string; items: Array<{ text: string; link: string; items?: any[]; collapsed?: boolean }> }> => {
  const categories = new Map<string, Array<{ text: string; link: string; items?: any[]; collapsed?: boolean }>>()

  // Process each entrypoint
  for (const entrypoint of model.entrypoints) {
    // Extract the module name from path (e.g., "./arr" -> "arr")
    const moduleName = entrypoint.path.replace(/^\.\//, '')

    // Create title case for display (e.g., "arr" -> "Arr")
    const displayName = moduleName.charAt(0).toUpperCase() + moduleName.slice(1)

    // Find namespace exports with nested modules
    const namespaceExports = entrypoint.module.exports
      .filter((exp: any) => exp.type === 'namespace' && exp.module)
      .map((exp: any) => ({
        text: exp.name,
        link: `/api/${moduleName}/${exp.name.toLowerCase()}`,
      }))
      .sort((a, b) => a.text.localeCompare(b.text))

    // Check if module description came from external .md file
    const hasExternalReadme = entrypoint.module.docsProvenance?.description?._tag === 'md-file'

    // Create sidebar item
    const item: { text: string; link: string; items?: any[]; collapsed?: boolean } = {
      text: displayName,
      link: `/api/${moduleName}`,
    }

    // If has external README, create nested structure with Exports + namespaces
    if (hasExternalReadme) {
      item.items = [
        { text: 'Exports', link: `/api/${moduleName}/exports` },
        ...namespaceExports,
      ]
      item.collapsed = true
    } else if (namespaceExports.length > 0) {
      // Otherwise, just add namespace items if any exist
      item.items = namespaceExports
      item.collapsed = true
    }

    // Use category from module JSDoc, default to 'Other' if not specified
    const category = entrypoint.module.category ?? 'Other'

    // Add to category group
    if (!categories.has(category)) {
      categories.set(category, [])
    }
    categories.get(category)!.push(item)
  }

  // Build final sidebar structure
  const sidebar: Array<
    { text: string; items: Array<{ text: string; link: string; items?: any[]; collapsed?: boolean }> }
  > = []

  // Determine category order
  let sortedCategories: string[]
  if (categoryOrder) {
    // Use provided order, but include any missing categories alphabetically at the end
    const orderedSet = new Set(categoryOrder)
    const missingCategories = Array.from(categories.keys())
      .filter((cat) => !orderedSet.has(cat) && cat !== 'Other')
      .sort()
    sortedCategories = [...categoryOrder.filter((cat) => categories.has(cat)), ...missingCategories]
    // Ensure "Other" is always last if it exists
    if (categories.has('Other') && !sortedCategories.includes('Other')) {
      sortedCategories.push('Other')
    }
  } else {
    // Default to alphabetical, with "Other" last
    sortedCategories = Array.from(categories.keys()).sort((a, b) => {
      if (a === 'Other') return 1
      if (b === 'Other') return -1
      return a.localeCompare(b)
    })
  }

  for (const categoryName of sortedCategories) {
    const items = categories.get(categoryName)
    if (items && items.length > 0) {
      sidebar.push({
        text: categoryName,
        items: items.sort((a, b) => a.text.localeCompare(b.text)),
      })
    }
  }

  return sidebar
}

/**
 * Generate API index page listing all modules with their namespace trees.
 */
const generateApiIndex = (model: InterfaceModel): string => {
  const modules = model.entrypoints.map((entrypoint) => {
    const moduleName = deriveModuleName(entrypoint.path)
    const url = `/api/${Md.kebab(moduleName)}`
    const description = entrypoint.module.docs?.description
      ? entrypoint.module.docs.description.split('\n\n')[0]!.replace(/\n/g, ' ').trim()
      : ''

    // Find namespace exports
    const namespaceExports = entrypoint.module.exports
      .filter((exp: any) => exp.type === 'namespace' && exp.module)
      .sort((a, b) => a.name.localeCompare(b.name))

    // Build namespace list if any exist
    const namespaceList = namespaceExports.length > 0
      ? '\n\n' + namespaceExports.map((ns: any) => {
        const nsUrl = `/api/${Md.kebab(moduleName)}/${ns.name.toLowerCase()}`
        const nsLink = Md.link(nsUrl, Md.code(ns.name))
        const nsDesc = ns.docs?.description ? ` - ${ns.docs.description}` : ''
        return Md.listItem(`${nsLink}${nsDesc}`)
      }).join('\n')
      : ''

    return `## ${Md.link(url, moduleName)}

${description}${namespaceList}`
  })

  return Md.sections(
    Md.heading(1, 'API Reference'),
    'Browse the complete API documentation for @wollybeard/kit.',
    modules.join('\n\n'),
  )
}

/**
 * Generate all pages from the model.
 */
const generatePages = (model: InterfaceModel): Page[] => {
  const pages: Page[] = []

  for (const entrypoint of model.entrypoints) {
    const moduleName = deriveModuleName(entrypoint.path)
    const module = entrypoint.module

    // Check if module description came from external .md file
    if (module.docsProvenance?.description?._tag === 'md-file') {
      // Split into overview + exports pages

      // Overview page (just README)
      pages.push({
        url: `/api/${Md.kebab(moduleName)}`,
        filepath: `api/${Md.kebab(moduleName)}.md`,
        title: moduleName,
        entrypoint,
        module,
        breadcrumbs: [moduleName],
        pageType: 'overview',
      })

      // Exports page (imports + exports, no README)
      pages.push({
        url: `/api/${Md.kebab(moduleName)}/exports`,
        filepath: `api/${Md.kebab(moduleName)}/exports.md`,
        title: moduleName,
        entrypoint,
        module,
        breadcrumbs: [moduleName, 'Exports'],
        pageType: 'exports',
      })
    } else {
      // Single page with everything (current behavior)
      pages.push({
        url: `/api/${Md.kebab(moduleName)}`,
        filepath: `api/${Md.kebab(moduleName)}.md`,
        title: moduleName,
        entrypoint,
        module,
        breadcrumbs: [moduleName],
      })
    }

    // Namespace pages (recursive)
    pages.push(...generateNamespacePages(entrypoint, module, [moduleName]))
  }

  return pages
}

/**
 * Recursively generate pages for namespace exports.
 */
const generateNamespacePages = (entrypoint: Entrypoint, module: Module, breadcrumbs: string[]): Page[] => {
  const pages: Page[] = []

  const namespaceExports = module.exports.filter(
    (exp: any): exp is any => exp._tag === 'value' && exp.type === 'namespace' && exp.module !== undefined,
  )

  for (const nsExport of namespaceExports) {
    const newBreadcrumbs = [...breadcrumbs, nsExport.name]
    const urlPath = newBreadcrumbs.map(Md.kebab).join('/')

    if (!nsExport.module) continue

    pages.push({
      url: `/api/${urlPath}`,
      filepath: `api/${urlPath}.md`,
      title: newBreadcrumbs.join('.'),
      entrypoint,
      module: nsExport.module,
      breadcrumbs: newBreadcrumbs,
    })

    // Recursively process nested namespaces
    pages.push(...generateNamespacePages(entrypoint, nsExport.module, newBreadcrumbs))
  }

  return pages
}

/**
 * Generate markdown content for a page.
 */
const generatePageContent = (page: Page, context: Context): string => {
  const { entrypoint, module, breadcrumbs, pageType } = page

  // Handle overview pages (just README)
  if (pageType === 'overview') {
    const description = module.docs?.description || ''
    const guide = module.docs?.guide ? `\n\n${module.docs.guide}` : ''
    return Md.sections(
      Md.heading(1, breadcrumbs.join('.')),
      description + guide,
    )
  }

  // Handle exports pages (skip README)
  if (pageType === 'exports') {
    // Separate namespace exports from regular exports
    const namespaceExports = module.exports.filter(
      (exp: any) => exp._tag === 'value' && exp.type === 'namespace',
    )
    const regularExports = module.exports.filter(
      (exp: any) => !(exp._tag === 'value' && exp.type === 'namespace'),
    )

    // Add breadcrumbs to context for namespace usage in examples
    const contextWithBreadcrumbs = { ...context, breadcrumbs }

    return Md.sections(
      Md.heading(1, breadcrumbs.join('.')),
      renderImportSection(entrypoint, context.packageName, [breadcrumbs[0]!]), // Use module name only
      namespaceExports.length > 0 ? renderNamespacesSection(namespaceExports, [breadcrumbs[0]!]) : '',
      renderExportsSection(regularExports, contextWithBreadcrumbs),
    )
  }

  // Default behavior for single-page modules
  const namespaceExports = module.exports.filter(
    (exp: any) => exp._tag === 'value' && exp.type === 'namespace',
  )
  const regularExports = module.exports.filter(
    (exp: any) => !(exp._tag === 'value' && exp.type === 'namespace'),
  )

  // Add breadcrumbs to context for namespace usage in examples
  const contextWithBreadcrumbs = { ...context, breadcrumbs }

  const description = module.docs?.description || ''
  const guide = module.docs?.guide ? `\n\n${module.docs.guide}` : ''

  return Md.sections(
    Md.heading(1, breadcrumbs.join('.')),
    description + guide,
    renderImportSection(entrypoint, context.packageName, breadcrumbs),
    namespaceExports.length > 0 ? renderNamespacesSection(namespaceExports, breadcrumbs) : '',
    renderExportsSection(regularExports, contextWithBreadcrumbs),
  )
}

/**
 * Render import examples based on entrypoint pattern.
 */
const renderImportSection = (
  entrypoint: Entrypoint,
  packageName: string,
  breadcrumbs: string[],
): string => {
  const importExamples = (() => {
    if (entrypoint._tag === 'DrillableNamespaceEntrypoint') {
      return entrypoint.getImportExamples(packageName, breadcrumbs)
    } else {
      return entrypoint.getImportExamples(packageName, entrypoint.path)
    }
  })()

  if (importExamples.length === 0) return ''

  // Single import example - use code fence
  if (importExamples.length === 1) {
    return Md.sections(
      Md.heading(2, 'Import'),
      Md.codeFence(importExamples[0]!.content),
    )
  }

  // Multiple import examples - use code group with tabs
  return Md.sections(
    Md.heading(2, 'Import'),
    Md.codeGroup(
      importExamples.map((example) => ({
        label: example.label,
        code: example.content,
      })),
    ),
  )
}

/**
 * Render namespaces section with links.
 */
const renderNamespacesSection = (namespaces: Export[], breadcrumbs: string[]): string => {
  const items = namespaces.map((ns) => {
    const nsPath = `/api/${[...breadcrumbs, ns.name].map(Md.kebab).join('/')}`
    const link = Md.link(nsPath, `**${Md.code(ns.name)}**`)
    const nsDesc = ns.docs?.description ? ` - ${ns.docs.description}` : ''
    return Md.listItem(`${link}${nsDesc}`)
  })

  return Md.sections(Md.heading(2, 'Namespaces'), items.join('\n'))
}

/**
 * Render all exports grouped by type or category.
 */
const renderExportsSection = (exports: Export[], context: Context): string => {
  // Auto-detect category mode if not explicitly configured
  const shouldGroupByCategory = context.groupByCategory ?? exports.some((e) => e.category != null)

  if (shouldGroupByCategory) {
    // Group by category with seamless interleaving
    const categorized = new Map<string, Export[]>()

    for (const exp of exports) {
      const category = exp.category ?? 'Other'
      const existing = categorized.get(category) ?? []
      categorized.set(category, [...existing, exp])
    }

    // Sort categories alphabetically, with "Other" last
    const sortedCategories = Array.from(categorized.keys()).sort((a, b) => {
      if (a === 'Other') return 1
      if (b === 'Other') return -1
      return a.localeCompare(b)
    })

    // Render each category with seamlessly interleaved exports
    const categorySection = sortedCategories.map((category) => {
      const categoryExports = categorized.get(category) ?? []
      return Md.sections(
        Md.heading(2, category),
        categoryExports.map((e) => renderExport(e, context)).join('\n\n'),
      )
    })

    return Md.sections(...categorySection)
  }

  // Traditional type-based grouping
  const functions = exports.filter((e: any) => e._tag === 'value' && e.type === 'function')
  const constants = exports.filter((e: any) => e._tag === 'value' && e.type === 'const')
  const classes = exports.filter((e: any) => e._tag === 'value' && e.type === 'class')
  const types = exports.filter((e: any) => e._tag === 'type')

  return Md.sections(
    functions.length > 0
      ? Md.sections(Md.heading(2, 'Functions'), functions.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
    constants.length > 0
      ? Md.sections(Md.heading(2, 'Constants'), constants.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
    classes.length > 0
      ? Md.sections(Md.heading(2, 'Classes'), classes.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
    types.length > 0
      ? Md.sections(Md.heading(2, 'Types'), types.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
  )
}

/**
 * Get type icon/badge for an export.
 */
const getTypeIcon = (exp: Export): string => {
  return Match.value(exp).pipe(
    Match.tags({
      value: (valueExp) =>
        Match.value(valueExp.type).pipe(
          Match.when('function', () => 'F'),
          Match.when('const', () => 'C'),
          Match.when('class', () => 'Class'),
          Match.when('namespace', () => 'NS'),
          Match.exhaustive,
        ),
      type: (typeExp) =>
        Match.value(typeExp.type).pipe(
          Match.when('interface', () => 'I'),
          Match.when('type-alias', () => 'T'),
          Match.when('enum', () => 'E'),
          Match.when('union', () => 'U'),
          Match.when('intersection', () => '∩'),
          Match.exhaustive,
        ),
    }),
    Match.exhaustive,
  )
}

/**
 * Escape HTML angle brackets while preserving backtick-wrapped inline code.
 */
const escapeHtmlPreservingCode = (text: string): string => {
  // Extract all backtick-wrapped content and replace with placeholders
  const codeBlocks: string[] = []
  const withPlaceholders = text.replace(/`([^`]+)`/g, (_, code) => {
    codeBlocks.push(code)
    return `%%CODE_${codeBlocks.length - 1}%%`
  })

  // Escape angle brackets in non-code content
  const escaped = withPlaceholders.replace(/</g, '&lt;').replace(/>/g, '&gt;')

  // Restore backtick-wrapped content (unescaped)
  return escaped.replace(/%%CODE_(\d+)%%/g, (_, index) => {
    return `\`${codeBlocks[Number(index)]}\``
  })
}

/**
 * Render a single export.
 */
const renderExport = (exp: Export, context: Context): string => {
  // Deprecation warning with proper link conversion
  const deprecated = exp.deprecated ? Md.deprecation(exp.deprecated) : ''

  // Transform description: normalize whitespace, demote headings, convert links, escape HTML
  // CRITICAL: Must convert double-space separators to newlines BEFORE demoting headings,
  // since demoteHeadings requires actual line breaks to match ^## patterns
  const transformMarkdown = (text: string) =>
    escapeHtmlPreservingCode(
      Md.demoteHeadings(
        Md.convertJSDocLinks(
          text
            .replace(/  /g, '\n\n') // Convert double-space paragraph separators to newlines FIRST
            .replace(/ - /g, '\n- '), // Convert list item separators to proper markdown list items
        ),
        2, // Demote headings AFTER newlines are added (exports are h3, so description content becomes h4+)
      )
        // Wrap list items that start with code-like patterns in backticks
        .replace(/^- (\[\[.*?\]\]|\{[^}]+\})/gm, '- `$1`'),
    )

  const description = exp.docs?.description ? transformMarkdown(exp.docs.description) : ''
  const guide = exp.docs?.guide ? `\n\n${transformMarkdown(exp.docs.guide)}` : ''

  const examples = exp.examples.length > 0
    ? `**Examples:**\n\n${exp.examples.map((ex) => renderExample(ex, exp.name, context)).join('\n\n')}`
    : ''

  // Build heading with type icon (using backticks for monospace)
  const typeIcon = getTypeIcon(exp)
  const heading = Md.heading(
    3,
    `<span style="opacity: 0.6; font-weight: normal; font-size: 0.85em;">\`[${typeIcon}]\`</span> ${Md.code(exp.name)}`,
  )

  // Source link as info line (after signature) using custom Vue component
  const sourceLink = context.githubUrl && exp.sourceLocation
    ? `<SourceLink href="${context.githubUrl}/blob/main/${exp.sourceLocation.file}#L${exp.sourceLocation.line}" />`
    : ''

  // Render signature - use simple signature if available, with full signature in toggle
  let signatureSection: string
  let signatureDetails: string

  if (exp.signatureSimple) {
    // Simple signature as primary
    const simpleSignatureText = renderSignature(exp.signatureSimple)
    const fullSignatureText = renderSignature(exp.signature)

    signatureSection = Md.sections(
      Md.codeFence(simpleSignatureText),
      '<details>',
      '<summary>Full Signature</summary>',
      '',
      Md.codeFence(fullSignatureText),
      '',
      '</details>',
    )

    // Use simple signature for parameter docs
    signatureDetails = renderSignatureDetails(exp.signatureSimple)
  } else {
    // No simple signature - render normally
    const signatureText = renderSignature(exp.signature)
    signatureSection = Md.codeFence(signatureText)
    signatureDetails = renderSignatureDetails(exp.signature)
  }

  return Md.sections(
    heading,
    signatureSection,
    sourceLink,
    signatureDetails,
    deprecated,
    description + guide,
    examples,
  )
}

/**
 * Render signature details (parameter descriptions, return documentation, throws).
 */
const renderSignatureDetails = (sig: SignatureModel): string => {
  return Match.value(sig).pipe(
    Match.tags({
      FunctionSignatureModel: (fnSig) => {
        // Collect documentation from all overloads
        const allParams = new Map<string, string>()
        let returnDoc: string | undefined
        const allThrows: string[] = []

        for (const overload of fnSig.overloads) {
          // Collect parameter descriptions
          for (const param of overload.parameters) {
            if (param.description && !allParams.has(param.name)) {
              allParams.set(param.name, param.description)
            }
          }

          // Use first non-empty return doc
          if (overload.returnDoc && !returnDoc) {
            returnDoc = overload.returnDoc
          }

          // Collect all throws
          for (const throwsDesc of overload.throws) {
            if (!allThrows.includes(throwsDesc)) {
              allThrows.push(throwsDesc)
            }
          }
        }

        // Build sections
        const sections: string[] = []

        if (allParams.size > 0) {
          const paramsList = Array.from(allParams.entries())
            .map(([name, desc]) => `- \`${name}\` - ${desc}`)
            .join('\n')
          sections.push(`**Parameters:**\n\n${paramsList}`)
        }

        if (returnDoc) {
          sections.push(`**Returns:** ${returnDoc}`)
        }

        if (allThrows.length > 0) {
          const throwsList = allThrows.map((desc) => `- ${desc}`).join('\n')
          sections.push(`**Throws:**\n\n${throwsList}`)
        }

        return sections.length > 0 ? sections.join('\n\n') : ''
      },
      BuilderSignatureModel: (builderSig) => {
        // Render docs for entry point
        const entryPoint = builderSig.entryPoint
        const sections: string[] = []

        // Entry point parameters
        if (entryPoint.parameters.some((p) => p.description)) {
          const paramsList = entryPoint.parameters
            .filter((p) => p.description)
            .map((p) => `- \`${p.name}\` - ${p.description}`)
            .join('\n')
          sections.push(`**Parameters:**\n\n${paramsList}`)
        }

        // Entry point return doc
        if (entryPoint.returnDoc) {
          sections.push(`**Returns:** ${entryPoint.returnDoc}`)
        }

        // Entry point throws
        if (entryPoint.throws.length > 0) {
          const throwsList = entryPoint.throws.map((desc) => `- ${desc}`).join('\n')
          sections.push(`**Throws:**\n\n${throwsList}`)
        }

        return sections.length > 0 ? sections.join('\n\n') : ''
      },
      ClassSignatureModel: (classSig) => {
        const sections: string[] = []

        // Constructor documentation
        if (classSig.ctor) {
          // Constructor parameters
          if (classSig.ctor.parameters.some((p) => p.description)) {
            const paramsList = classSig.ctor.parameters
              .filter((p) => p.description)
              .map((p) => `- \`${p.name}\` - ${p.description}`)
              .join('\n')
            sections.push(`**Constructor Parameters:**\n\n${paramsList}`)
          }

          // Constructor throws
          if (classSig.ctor.throws.length > 0) {
            const throwsList = classSig.ctor.throws.map((desc) => `- ${desc}`).join('\n')
            sections.push(`**Constructor Throws:**\n\n${throwsList}`)
          }
        }

        // Property descriptions
        const propsWithDesc = classSig.properties.filter((p) => p.description)
        if (propsWithDesc.length > 0) {
          const propsList = propsWithDesc
            .map((p) => `- \`${p.name}\` - ${p.description}`)
            .join('\n')
          sections.push(`**Properties:**\n\n${propsList}`)
        }

        return sections.length > 0 ? sections.join('\n\n') : ''
      },
      TypeSignatureModel: () => '',
      ValueSignatureModel: () => '',
    }),
    Match.exhaustive,
  )
}

/**
 * Render type parameters to string (e.g., "<T, U extends string>").
 */
const renderTypeParameters = (typeParams: readonly typeof import('../schema.js').TypeParameter.Type[]): string => {
  if (typeParams.length === 0) return ''

  const rendered = typeParams.map((tp) => {
    let text = tp.name
    if (tp.constraint) text += ` extends ${tp.constraint}`
    if (tp.default) text += ` = ${tp.default}`
    return text
  }).join(', ')

  return `<${rendered}>`
}

/**
 * Render function parameters to string (e.g., "a: number, b?: string").
 */
const renderParameters = (params: readonly typeof import('../schema.js').Parameter.Type[]): string => {
  return params.map((param) => {
    let text = ''
    if (param.rest) text += '...'
    text += param.name
    if (param.optional) text += '?'
    text += `: ${param.type}`
    if (param.defaultValue) text += ` = ${param.defaultValue}`
    return text
  }).join(', ')
}

/**
 * Render SignatureModel to string for display in code fence.
 */
const renderSignature = (sig: SignatureModel): string => {
  return Match.value(sig).pipe(
    Match.tags({
      FunctionSignatureModel: (fnSig) => {
        // Render all overloads
        return fnSig.overloads.map((overload) => {
          const typeParams = renderTypeParameters(overload.typeParameters)
          const params = renderParameters(overload.parameters)
          return `${typeParams}(${params}): ${overload.returnType}`
        }).join('\n')
      },
      BuilderSignatureModel: (builderSig) => {
        // Render builder entry point
        const entryPoint = builderSig.entryPoint
        const typeParams = renderTypeParameters(entryPoint.typeParameters)
        const params = renderParameters(entryPoint.parameters)
        let result = `${typeParams}(${params}): ${builderSig.typeName}\n`

        // Render chainable methods
        if (builderSig.chainableMethods.length > 0) {
          result += '\n// Chainable methods:\n'
          for (const method of builderSig.chainableMethods) {
            // Render all overloads for this method
            for (const overload of method.overloads) {
              const methodTypeParams = renderTypeParameters(overload.typeParameters)
              const methodParams = renderParameters(overload.parameters)
              result += `  .${method.name}${methodTypeParams}(${methodParams}): ${builderSig.typeName}\n`
            }
          }
        }

        // Render terminal methods
        if (builderSig.terminalMethods.length > 0) {
          result += '\n// Terminal methods:\n'
          for (const method of builderSig.terminalMethods) {
            // Render all overloads for this method
            for (const overload of method.overloads) {
              const methodTypeParams = renderTypeParameters(overload.typeParameters)
              const methodParams = renderParameters(overload.parameters)
              result += `  .${method.name}${methodTypeParams}(${methodParams}): ${overload.returnType}\n`
            }
          }
        }

        // Render transform methods
        if (builderSig.transformMethods.length > 0) {
          result += '\n// Transform methods:\n'
          for (const method of builderSig.transformMethods) {
            // Render all overloads for this method
            for (const overload of method.overloads) {
              const methodTypeParams = renderTypeParameters(overload.typeParameters)
              const methodParams = renderParameters(overload.parameters)
              const returnType = method.transformsTo || overload.returnType
              result += `  .${method.name}${methodTypeParams}(${methodParams}): ${returnType}\n`
            }
          }
        }

        return result
      },
      ClassSignatureModel: (classSig) => {
        let result = 'class {\n'

        // Render constructor
        if (classSig.ctor) {
          const typeParams = renderTypeParameters(classSig.ctor.typeParameters)
          const params = renderParameters(classSig.ctor.parameters)
          result += `  constructor${typeParams}(${params})\n`
        }

        // Render properties
        if (classSig.properties.length > 0) {
          result += '\n  // Properties\n'
          for (const prop of classSig.properties) {
            let propLine = '  '
            if (prop.static) propLine += 'static '
            if (prop.readonly) propLine += 'readonly '
            propLine += prop.name
            if (prop.optional) propLine += '?'
            propLine += `: ${prop.type}\n`
            result += propLine
          }
        }

        // Render methods
        if (classSig.methods.length > 0) {
          result += '\n  // Methods\n'
          for (const method of classSig.methods) {
            for (const overload of method.overloads) {
              let methodLine = '  '
              if (method.static) methodLine += 'static '
              const typeParams = renderTypeParameters(overload.typeParameters)
              const params = renderParameters(overload.parameters)
              methodLine += `${method.name}${typeParams}(${params}): ${overload.returnType}\n`
              result += methodLine
            }
          }
        }

        result += '}'
        return result
      },
      TypeSignatureModel: (typeSig) => typeSig.text,
      ValueSignatureModel: (valSig) => valSig.type,
    }),
    Match.exhaustive,
  )
}

/**
 * Render a code example with Twoslash.
 */
const renderExample = (example: any, exportName: string, context: Context): string => {
  // Don't wrap title in bold - it may already contain markdown formatting (e.g., headings)
  const title = example.title || ''

  let code = example.code

  // Transform code to use namespace notation
  if (context.breadcrumbs && context.breadcrumbs.length > 0) {
    const namespace = context.breadcrumbs.join('.')
    const namespaceCall = `${namespace}.${exportName}`
    const topLevelModule = context.breadcrumbs[0]

    // Replace standalone function calls with namespace calls
    const regex = new RegExp(`(?<!\\.)\\b${exportName}(?=\\(|\\.)`, 'g')
    code = code.replace(regex, namespaceCall)

    // Add Twoslash setup (import + @noErrors directive)
    const hasImports = code.includes('import ')
    if (topLevelModule) {
      if (!hasImports) {
        const importStatement = `import { ${topLevelModule} } from '${context.packageName}/${Md.kebab(topLevelModule)}'`
        code = `// @noErrors\n${importStatement}\n// ---cut---\n${code}`
      } else {
        code = `// @noErrors\n${code}`
      }
    }
  }

  return Md.sections(title, Md.codeFence(code, example.language, 'twoslash'))
}
